{"version":3,"sources":["webpack://WarpField/./node_modules/tiled-geometry/lib/compass/axis.js","webpack://WarpField/./node_modules/tiled-geometry/lib/compass/cardinal-direction-flags.js","webpack://WarpField/./node_modules/tiled-geometry/lib/compass/cardinal-direction.js","webpack://WarpField/./node_modules/tiled-geometry/lib/compass/cardinal-orientation.js","webpack://WarpField/./node_modules/tiled-geometry/lib/compass/cardinal-turn.js","webpack://WarpField/./node_modules/tiled-geometry/lib/compass/direction.js","webpack://WarpField/./node_modules/tiled-geometry/lib/compass/flip.js","webpack://WarpField/./node_modules/tiled-geometry/lib/compass/index.js","webpack://WarpField/./node_modules/tiled-geometry/lib/compass/turn.js","webpack://WarpField/./node_modules/tiled-geometry/lib/grid/cardinal-path.js","webpack://WarpField/./node_modules/tiled-geometry/lib/grid/index.js","webpack://WarpField/./node_modules/tiled-geometry/lib/grid/mask-rectangle.js","webpack://WarpField/./node_modules/tiled-geometry/lib/grid/mask.js","webpack://WarpField/./node_modules/tiled-geometry/lib/grid/offset.js","webpack://WarpField/./node_modules/tiled-geometry/lib/grid/raster-mask.js","webpack://WarpField/./node_modules/tiled-geometry/lib/grid/rectangle.js","webpack://WarpField/./node_modules/tiled-geometry/lib/grid/size.js","webpack://WarpField/./node_modules/tiled-geometry/lib/grid/transform-rectangle.js","webpack://WarpField/./node_modules/tiled-geometry/lib/index.js","webpack://WarpField/./src/compute.ts","webpack://WarpField/./src/constants.ts","webpack://WarpField/./src/field-of-view-impl.ts","webpack://WarpField/./src/field-of-view-map.ts","webpack://WarpField/./src/index.ts","webpack://WarpField/./src/tile-flags.ts","webpack://WarpField/./src/warp-data.ts","webpack://WarpField/./src/wedge.ts","webpack://WarpField/webpack/bootstrap","webpack://WarpField/webpack/startup"],"names":["Axis","Object","defineProperty","exports","value","axisAddCardinalTurn","axisFromNorthSouthTurn","axisFromCardinalDirection","axisOrthogonal","axisToString","AXES","NORTH_SOUTH","WEST_EAST","AXES_STR","axis","dir","turn","CardinalDirectionFlags","cardinalDirectionFlagsFromCardinalDirection","cardinalDirectionFlagsRemoveCardinalDirection","cardinalDirectionFlagsSetCardinalDirection","cardinalDirectionFlagsHasCardinalDirection","cardinalDirectionFlagsToString","flags","ret","NORTH","EAST","SOUTH","WEST","CardinalDirection","cardinalDirectionAddCardinalTurn","cardinalDirectionFromCardinalOrientation","cardinalDirectionFromNorthTurn","cardinalDirectionFromDirection","cardinalDirectionOpposite","cardinalDirectionToString","CARDINAL_DIRECTIONS","CARDINAL_DIRECTIONS_STR","orientation","cardinalOrientationAddCardinalTurn","cardinalOrientationFromFlipAndCardinalDirection","cardinalOrientationReverse","cardinalOrientationFlip","cardinalOrientationToString","CARDINAL_ORIENTATIONS","CardinalOrientation","axis_1","flip_1","HEADS_NORTH","TAILS_NORTH","HEADS_EAST","TAILS_EAST","HEADS_SOUTH","TAILS_SOUTH","HEADS_WEST","TAILS_WEST","CARDINAL_ORIENTATIONS_STR","flip","Flip","HEADS","CardinalTurn","cardinalTurnAddCardinalTurn","cardinalTurnFromTurn","cardinalTurnFromCardinalDirections","cardinalTurnReverse","cardinalTurnToDegrees","cardinalTurnToString","CARDINAL_TURNS","NONE","RIGHT","AROUND","LEFT","CARDINAL_TURNS_STR","from","to","turn1","turn2","Direction","directionAddCardinalTurn","directionAddTurn","directionFromCardinalDirection","directionOpposite","directionIsCardinal","directionToString","DIRECTIONS","NORTHEAST","SOUTHEAST","SOUTHWEST","NORTHWEST","DIRECTIONS_STR","flipFromCardinalOrientation","flipFromBoolean","flipOpposite","flipToString","FLIPS","TAILS","FLIPS_STR","tails","__createBinding","this","create","o","m","k","k2","undefined","enumerable","get","__exportStar","p","prototype","hasOwnProperty","call","Turn","turnAddTurn","turnFromDirections","turnFromCardinalTurn","turnFromCardinalDirections","turnReverse","turnIsCardinal","turnToDegrees","turnToString","TURNS","R_45","R_90","R_135","T_180","L_135","L_90","L_45","TURNS_STR","CardinalPath","compass_1","offset_1","rectangle_1","raster_mask_1","LOCAL_OFF","Offset","sortedInsert","array","push","i","length","start","segments","_start","copyFrom","_segments","toString","map","segment","join","other","equals","every","v","addCardinalDirection","x","y","setFromCardinalDirection","northY","southY","westX","eastX","Math","min","max","Error","Rectangle","total","abs","bounds","lines","Array","getBounds","height","RasterMask","width","MaskRectangle","mask_1","rect","initialValue","outsideValue","_rect","_mask","Mask","_outsideValue","northWest","contains","index","getAtIndex","off","set","setAtIndex","loc","locations","offsetsWithTrue","size_1","size","_size","Size","_bits","ceil","area","fill","arrayIndex","bitMask","slice","offsets","X_FROM_DIRECTION","Y_FROM_DIRECTION","X_FROM_CARDINAL_DIRECTION","Y_FROM_CARDINAL_DIRECTION","add","factor","anchor","subtractOffset","rotate","addOffset","dirx","diry","nx","ny","cursor","radius","dy","dx","_lines","shape","line","end","w","j","ROTATE_CORNER_X","ROTATE_CORNER_Y","empty","off1","off2","multiply","cx","cy","predicate","TransformRectangle","LOCAL_OFF2","LOCAL_SIZE","_flip","_rotate","_translate","_matrix","_targetRect","_update","flipSign","forEach","nrotate","translate","applyToCardinalOrientation","unapplyFromCardinalOrientation","offOut","tx","ty","applyTo","unapplyFrom","rectOut","applyToOffset","setFromCorners","unapplyFromOffset","__setModuleDefault","__importStar","mod","__esModule","result","computeFieldOfView","geom","constants","wedge_1","tile_flags_1","field_of_view_impl_1","warp_data_1","quadrant","field","origin","chebyshevRadius","xSign","ySign","warpDataCache","baseWarp","yDir","xDir","farYFlag","TileFlags","WALL_NORTH","WALL_SOUTH","farXFlag","WALL_WEST","WALL_EAST","wedges","initWedges","slopeY","slopeFar","slopeMid","Number","POSITIVE_INFINITY","slopeX","wedge","getBestWedge","warps","visible","warp","shadow","newWedges","low","high","warpData","shiftX","shiftY","mapIndex","tileFlags","getTileFlagsAtIndex","warpY","getWarpAtIndex","warpX","wallY","wallX","shadowWedges","addShadow","WALL_OUTSET","BODY","BODY_INSET","shadowWedge","warpDataY","warpCount","offsetShift","warpWedges","addWarp","WARP_OUTSET","warpDataX","warpWedge","mergeWedges","FieldOfViewImpl","WarpDataCache","PICK_WEDGE_EPSILON","boundRect","_getWarp","getVisible","id","FieldOfViewMap","addEdgeWalls","_warps","_tileFlags","_addFlag","_tileWarpIds","_removeFlag","oneWay","containsOffset","ALL","getWalls","sourceX","sourceY","targetMap","targetX","targetY","targetWarpId","_findOrMakeWarp","_addWarp","warpId","_removeWarp","_a","shift","flag","offsetShiftX","offsetShiftY","fid","fwarp","_makeWarp","field_of_view_map_1","compute_1","tiled_geometry_1","_data","wcData","mapData","yData","data","middle","bestWedge","bestDist","curDist","candidate","targetDist","candidateDist","target","newWedge","assign","b","a","__webpack_module_cache__","__webpack_require__","moduleId","module","__webpack_modules__"],"mappings":"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","file":"warp-field-2.0.0.min.js","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.axisAddCardinalTurn = exports.axisFromNorthSouthTurn = exports.axisFromCardinalDirection = exports.axisOrthogonal = exports.axisToString = exports.AXES = exports.Axis = void 0;\r\nvar Axis;\r\n(function (Axis) {\r\n    Axis[Axis[\"NORTH_SOUTH\"] = 0] = \"NORTH_SOUTH\";\r\n    Axis[Axis[\"WEST_EAST\"] = 1] = \"WEST_EAST\";\r\n})(Axis = exports.Axis || (exports.Axis = {}));\r\nexports.AXES = [\r\n    Axis.NORTH_SOUTH,\r\n    Axis.WEST_EAST,\r\n];\r\nconst AXES_STR = [\r\n    'N-S',\r\n    'W-E',\r\n];\r\nfunction axisToString(axis) {\r\n    return AXES_STR[axis];\r\n}\r\nexports.axisToString = axisToString;\r\nfunction axisOrthogonal(axis) {\r\n    return (axis ^ 1);\r\n}\r\nexports.axisOrthogonal = axisOrthogonal;\r\n// conversion\r\nfunction axisFromCardinalDirection(dir) {\r\n    return (dir & 1);\r\n}\r\nexports.axisFromCardinalDirection = axisFromCardinalDirection;\r\nfunction axisFromNorthSouthTurn(turn) {\r\n    return (turn & 1);\r\n}\r\nexports.axisFromNorthSouthTurn = axisFromNorthSouthTurn;\r\n// math\r\nfunction axisAddCardinalTurn(axis, turn) {\r\n    return ((axis + turn) & 1);\r\n}\r\nexports.axisAddCardinalTurn = axisAddCardinalTurn;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.cardinalDirectionFlagsFromCardinalDirection = exports.cardinalDirectionFlagsRemoveCardinalDirection = exports.cardinalDirectionFlagsSetCardinalDirection = exports.cardinalDirectionFlagsHasCardinalDirection = exports.cardinalDirectionFlagsToString = exports.CardinalDirectionFlags = void 0;\r\nvar CardinalDirectionFlags;\r\n(function (CardinalDirectionFlags) {\r\n    CardinalDirectionFlags[CardinalDirectionFlags[\"NONE\"] = 0] = \"NONE\";\r\n    CardinalDirectionFlags[CardinalDirectionFlags[\"NORTH\"] = 1] = \"NORTH\";\r\n    CardinalDirectionFlags[CardinalDirectionFlags[\"EAST\"] = 2] = \"EAST\";\r\n    CardinalDirectionFlags[CardinalDirectionFlags[\"SOUTH\"] = 4] = \"SOUTH\";\r\n    CardinalDirectionFlags[CardinalDirectionFlags[\"WEST\"] = 8] = \"WEST\";\r\n    CardinalDirectionFlags[CardinalDirectionFlags[\"ALL\"] = 15] = \"ALL\";\r\n})(CardinalDirectionFlags = exports.CardinalDirectionFlags || (exports.CardinalDirectionFlags = {}));\r\nfunction cardinalDirectionFlagsToString(flags) {\r\n    let ret = '[';\r\n    if ((flags & CardinalDirectionFlags.NORTH) !== 0) {\r\n        ret += 'N';\r\n    }\r\n    if ((flags & CardinalDirectionFlags.EAST) !== 0) {\r\n        ret += 'E';\r\n    }\r\n    if ((flags & CardinalDirectionFlags.SOUTH) !== 0) {\r\n        ret += 'S';\r\n    }\r\n    if ((flags & CardinalDirectionFlags.WEST) !== 0) {\r\n        ret += 'W';\r\n    }\r\n    return ret + ']';\r\n}\r\nexports.cardinalDirectionFlagsToString = cardinalDirectionFlagsToString;\r\nfunction cardinalDirectionFlagsHasCardinalDirection(flags, dir) {\r\n    return (flags & cardinalDirectionFlagsFromCardinalDirection(dir)) !== 0;\r\n}\r\nexports.cardinalDirectionFlagsHasCardinalDirection = cardinalDirectionFlagsHasCardinalDirection;\r\nfunction cardinalDirectionFlagsSetCardinalDirection(flags, dir) {\r\n    return (flags | cardinalDirectionFlagsFromCardinalDirection(dir));\r\n}\r\nexports.cardinalDirectionFlagsSetCardinalDirection = cardinalDirectionFlagsSetCardinalDirection;\r\nfunction cardinalDirectionFlagsRemoveCardinalDirection(flags, dir) {\r\n    return (flags & ~cardinalDirectionFlagsFromCardinalDirection(dir));\r\n}\r\nexports.cardinalDirectionFlagsRemoveCardinalDirection = cardinalDirectionFlagsRemoveCardinalDirection;\r\n// conversion\r\nfunction cardinalDirectionFlagsFromCardinalDirection(dir) {\r\n    return (1 << dir);\r\n}\r\nexports.cardinalDirectionFlagsFromCardinalDirection = cardinalDirectionFlagsFromCardinalDirection;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.cardinalDirectionAddCardinalTurn = exports.cardinalDirectionFromCardinalOrientation = exports.cardinalDirectionFromNorthTurn = exports.cardinalDirectionFromDirection = exports.cardinalDirectionOpposite = exports.cardinalDirectionToString = exports.CARDINAL_DIRECTIONS = exports.CardinalDirection = void 0;\r\nvar CardinalDirection;\r\n(function (CardinalDirection) {\r\n    CardinalDirection[CardinalDirection[\"NORTH\"] = 0] = \"NORTH\";\r\n    CardinalDirection[CardinalDirection[\"EAST\"] = 1] = \"EAST\";\r\n    CardinalDirection[CardinalDirection[\"SOUTH\"] = 2] = \"SOUTH\";\r\n    CardinalDirection[CardinalDirection[\"WEST\"] = 3] = \"WEST\";\r\n})(CardinalDirection = exports.CardinalDirection || (exports.CardinalDirection = {}));\r\nexports.CARDINAL_DIRECTIONS = [\r\n    CardinalDirection.NORTH,\r\n    CardinalDirection.EAST,\r\n    CardinalDirection.SOUTH,\r\n    CardinalDirection.WEST,\r\n];\r\nconst CARDINAL_DIRECTIONS_STR = [\r\n    'N',\r\n    'E',\r\n    'S',\r\n    'W',\r\n];\r\nfunction cardinalDirectionToString(dir) {\r\n    return CARDINAL_DIRECTIONS_STR[dir];\r\n}\r\nexports.cardinalDirectionToString = cardinalDirectionToString;\r\nfunction cardinalDirectionOpposite(dir) {\r\n    return ((dir + 2) & 3);\r\n}\r\nexports.cardinalDirectionOpposite = cardinalDirectionOpposite;\r\n// conversion\r\nfunction cardinalDirectionFromDirection(dir) {\r\n    return (dir >> 1);\r\n}\r\nexports.cardinalDirectionFromDirection = cardinalDirectionFromDirection;\r\nfunction cardinalDirectionFromNorthTurn(turn) {\r\n    return turn;\r\n}\r\nexports.cardinalDirectionFromNorthTurn = cardinalDirectionFromNorthTurn;\r\nfunction cardinalDirectionFromCardinalOrientation(orientation) {\r\n    return (orientation >>> 1);\r\n}\r\nexports.cardinalDirectionFromCardinalOrientation = cardinalDirectionFromCardinalOrientation;\r\n// math\r\nfunction cardinalDirectionAddCardinalTurn(dir, turn) {\r\n    return ((dir + turn) & 3);\r\n}\r\nexports.cardinalDirectionAddCardinalTurn = cardinalDirectionAddCardinalTurn;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.cardinalOrientationAddCardinalTurn = exports.cardinalOrientationFromFlipAndCardinalDirection = exports.cardinalOrientationReverse = exports.cardinalOrientationFlip = exports.cardinalOrientationToString = exports.CARDINAL_ORIENTATIONS = exports.CardinalOrientation = void 0;\r\nconst axis_1 = require(\"./axis\");\r\nconst flip_1 = require(\"./flip\");\r\nvar CardinalOrientation;\r\n(function (CardinalOrientation) {\r\n    CardinalOrientation[CardinalOrientation[\"HEADS_NORTH\"] = 0] = \"HEADS_NORTH\";\r\n    CardinalOrientation[CardinalOrientation[\"TAILS_NORTH\"] = 1] = \"TAILS_NORTH\";\r\n    CardinalOrientation[CardinalOrientation[\"HEADS_EAST\"] = 2] = \"HEADS_EAST\";\r\n    CardinalOrientation[CardinalOrientation[\"TAILS_EAST\"] = 3] = \"TAILS_EAST\";\r\n    CardinalOrientation[CardinalOrientation[\"HEADS_SOUTH\"] = 4] = \"HEADS_SOUTH\";\r\n    CardinalOrientation[CardinalOrientation[\"TAILS_SOUTH\"] = 5] = \"TAILS_SOUTH\";\r\n    CardinalOrientation[CardinalOrientation[\"HEADS_WEST\"] = 6] = \"HEADS_WEST\";\r\n    CardinalOrientation[CardinalOrientation[\"TAILS_WEST\"] = 7] = \"TAILS_WEST\";\r\n})(CardinalOrientation = exports.CardinalOrientation || (exports.CardinalOrientation = {}));\r\nexports.CARDINAL_ORIENTATIONS = [\r\n    CardinalOrientation.HEADS_NORTH,\r\n    CardinalOrientation.TAILS_NORTH,\r\n    CardinalOrientation.HEADS_EAST,\r\n    CardinalOrientation.TAILS_EAST,\r\n    CardinalOrientation.HEADS_SOUTH,\r\n    CardinalOrientation.TAILS_SOUTH,\r\n    CardinalOrientation.HEADS_WEST,\r\n    CardinalOrientation.TAILS_WEST,\r\n];\r\nconst CARDINAL_ORIENTATIONS_STR = [\r\n    'HN',\r\n    'TN',\r\n    'HE',\r\n    'TE',\r\n    'HS',\r\n    'TS',\r\n    'HW',\r\n    'TW',\r\n];\r\nfunction cardinalOrientationToString(orientation) {\r\n    return CARDINAL_ORIENTATIONS_STR[orientation];\r\n}\r\nexports.cardinalOrientationToString = cardinalOrientationToString;\r\nfunction cardinalOrientationFlip(orientation, axis) {\r\n    if (axis === axis_1.Axis.NORTH_SOUTH) {\r\n        return ((9 - orientation) & 7);\r\n    }\r\n    else {\r\n        return ((13 - orientation) & 7);\r\n    }\r\n}\r\nexports.cardinalOrientationFlip = cardinalOrientationFlip;\r\nfunction cardinalOrientationReverse(orientation) {\r\n    if (orientation === CardinalOrientation.HEADS_EAST) {\r\n        return CardinalOrientation.HEADS_WEST;\r\n    }\r\n    else if (orientation === CardinalOrientation.HEADS_WEST) {\r\n        return CardinalOrientation.HEADS_EAST;\r\n    }\r\n    else {\r\n        return orientation;\r\n    }\r\n}\r\nexports.cardinalOrientationReverse = cardinalOrientationReverse;\r\n// conversion\r\nfunction cardinalOrientationFromFlipAndCardinalDirection(flip, dir) {\r\n    return (dir * 2 + (flip !== flip_1.Flip.HEADS ? 1 : 0));\r\n}\r\nexports.cardinalOrientationFromFlipAndCardinalDirection = cardinalOrientationFromFlipAndCardinalDirection;\r\n// math\r\nfunction cardinalOrientationAddCardinalTurn(orientation, turn) {\r\n    return ((orientation + turn * 2) & 7);\r\n}\r\nexports.cardinalOrientationAddCardinalTurn = cardinalOrientationAddCardinalTurn;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.cardinalTurnAddCardinalTurn = exports.cardinalTurnFromTurn = exports.cardinalTurnFromCardinalDirections = exports.cardinalTurnReverse = exports.cardinalTurnToDegrees = exports.cardinalTurnToString = exports.CARDINAL_TURNS = exports.CardinalTurn = void 0;\r\nvar CardinalTurn;\r\n(function (CardinalTurn) {\r\n    CardinalTurn[CardinalTurn[\"NONE\"] = 0] = \"NONE\";\r\n    CardinalTurn[CardinalTurn[\"RIGHT\"] = 1] = \"RIGHT\";\r\n    CardinalTurn[CardinalTurn[\"AROUND\"] = 2] = \"AROUND\";\r\n    CardinalTurn[CardinalTurn[\"LEFT\"] = 3] = \"LEFT\";\r\n})(CardinalTurn = exports.CardinalTurn || (exports.CardinalTurn = {}));\r\nexports.CARDINAL_TURNS = [\r\n    CardinalTurn.NONE,\r\n    CardinalTurn.RIGHT,\r\n    CardinalTurn.AROUND,\r\n    CardinalTurn.LEFT,\r\n];\r\nconst CARDINAL_TURNS_STR = [\r\n    'T0',\r\n    'T+90',\r\n    'T180',\r\n    'T-90',\r\n];\r\nfunction cardinalTurnToString(dir) {\r\n    return CARDINAL_TURNS_STR[dir];\r\n}\r\nexports.cardinalTurnToString = cardinalTurnToString;\r\nfunction cardinalTurnToDegrees(turn) {\r\n    return turn * 90;\r\n}\r\nexports.cardinalTurnToDegrees = cardinalTurnToDegrees;\r\nfunction cardinalTurnReverse(dir) {\r\n    return ((4 - dir) & 3);\r\n}\r\nexports.cardinalTurnReverse = cardinalTurnReverse;\r\n// conversion\r\nfunction cardinalTurnFromCardinalDirections(from, to) {\r\n    return ((to - from) & 3);\r\n}\r\nexports.cardinalTurnFromCardinalDirections = cardinalTurnFromCardinalDirections;\r\nfunction cardinalTurnFromTurn(turn) {\r\n    return (turn >> 1);\r\n}\r\nexports.cardinalTurnFromTurn = cardinalTurnFromTurn;\r\n// math\r\nfunction cardinalTurnAddCardinalTurn(turn1, turn2) {\r\n    return ((turn1 + turn2) & 3);\r\n}\r\nexports.cardinalTurnAddCardinalTurn = cardinalTurnAddCardinalTurn;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.directionAddCardinalTurn = exports.directionAddTurn = exports.directionFromCardinalDirection = exports.directionOpposite = exports.directionIsCardinal = exports.directionToString = exports.DIRECTIONS = exports.Direction = void 0;\r\nvar Direction;\r\n(function (Direction) {\r\n    Direction[Direction[\"NORTH\"] = 0] = \"NORTH\";\r\n    Direction[Direction[\"NORTHEAST\"] = 1] = \"NORTHEAST\";\r\n    Direction[Direction[\"EAST\"] = 2] = \"EAST\";\r\n    Direction[Direction[\"SOUTHEAST\"] = 3] = \"SOUTHEAST\";\r\n    Direction[Direction[\"SOUTH\"] = 4] = \"SOUTH\";\r\n    Direction[Direction[\"SOUTHWEST\"] = 5] = \"SOUTHWEST\";\r\n    Direction[Direction[\"WEST\"] = 6] = \"WEST\";\r\n    Direction[Direction[\"NORTHWEST\"] = 7] = \"NORTHWEST\";\r\n})(Direction = exports.Direction || (exports.Direction = {}));\r\nexports.DIRECTIONS = [\r\n    Direction.NORTH,\r\n    Direction.NORTHEAST,\r\n    Direction.EAST,\r\n    Direction.SOUTHEAST,\r\n    Direction.SOUTH,\r\n    Direction.SOUTHWEST,\r\n    Direction.WEST,\r\n    Direction.NORTHWEST,\r\n];\r\nconst DIRECTIONS_STR = [\r\n    'N',\r\n    'NE',\r\n    'E',\r\n    'SE',\r\n    'S',\r\n    'SW',\r\n    'W',\r\n    'NW',\r\n];\r\nfunction directionToString(dir) {\r\n    return DIRECTIONS_STR[dir];\r\n}\r\nexports.directionToString = directionToString;\r\nfunction directionIsCardinal(dir) {\r\n    return (dir & 1) === 0;\r\n}\r\nexports.directionIsCardinal = directionIsCardinal;\r\nfunction directionOpposite(dir) {\r\n    return ((dir + 4) & 7);\r\n}\r\nexports.directionOpposite = directionOpposite;\r\n// conversion\r\nfunction directionFromCardinalDirection(dir) {\r\n    return (dir << 1);\r\n}\r\nexports.directionFromCardinalDirection = directionFromCardinalDirection;\r\n// math\r\nfunction directionAddTurn(dir, turn) {\r\n    return ((dir + turn) & 7);\r\n}\r\nexports.directionAddTurn = directionAddTurn;\r\nfunction directionAddCardinalTurn(dir, turn) {\r\n    return ((dir + turn * 2) & 7);\r\n}\r\nexports.directionAddCardinalTurn = directionAddCardinalTurn;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.flipFromCardinalOrientation = exports.flipFromBoolean = exports.flipOpposite = exports.flipToString = exports.FLIPS = exports.Flip = void 0;\r\nvar Flip;\r\n(function (Flip) {\r\n    Flip[Flip[\"HEADS\"] = 0] = \"HEADS\";\r\n    Flip[Flip[\"TAILS\"] = 1] = \"TAILS\";\r\n})(Flip = exports.Flip || (exports.Flip = {}));\r\nexports.FLIPS = [\r\n    Flip.HEADS,\r\n    Flip.TAILS,\r\n];\r\nconst FLIPS_STR = [\r\n    'H',\r\n    'T',\r\n];\r\nfunction flipToString(flip) {\r\n    return FLIPS_STR[flip];\r\n}\r\nexports.flipToString = flipToString;\r\nfunction flipOpposite(flip) {\r\n    return (flip ^ 1);\r\n}\r\nexports.flipOpposite = flipOpposite;\r\n// conversion\r\nfunction flipFromBoolean(tails) {\r\n    return tails ? Flip.TAILS : Flip.HEADS;\r\n}\r\nexports.flipFromBoolean = flipFromBoolean;\r\nfunction flipFromCardinalOrientation(orientation) {\r\n    return (orientation & 1);\r\n}\r\nexports.flipFromCardinalOrientation = flipFromCardinalOrientation;\r\n","\"use strict\";\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n__exportStar(require(\"./direction\"), exports);\r\n__exportStar(require(\"./turn\"), exports);\r\n__exportStar(require(\"./cardinal-direction\"), exports);\r\n__exportStar(require(\"./cardinal-turn\"), exports);\r\n__exportStar(require(\"./cardinal-direction-flags\"), exports);\r\n__exportStar(require(\"./flip\"), exports);\r\n__exportStar(require(\"./cardinal-orientation\"), exports);\r\n__exportStar(require(\"./axis\"), exports);\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.turnAddTurn = exports.turnFromDirections = exports.turnFromCardinalTurn = exports.turnFromCardinalDirections = exports.turnReverse = exports.turnIsCardinal = exports.turnToDegrees = exports.turnToString = exports.TURNS = exports.Turn = void 0;\r\nvar Turn;\r\n(function (Turn) {\r\n    Turn[Turn[\"NONE\"] = 0] = \"NONE\";\r\n    Turn[Turn[\"R_45\"] = 1] = \"R_45\";\r\n    Turn[Turn[\"R_90\"] = 2] = \"R_90\";\r\n    Turn[Turn[\"R_135\"] = 3] = \"R_135\";\r\n    Turn[Turn[\"T_180\"] = 4] = \"T_180\";\r\n    Turn[Turn[\"L_135\"] = 5] = \"L_135\";\r\n    Turn[Turn[\"L_90\"] = 6] = \"L_90\";\r\n    Turn[Turn[\"L_45\"] = 7] = \"L_45\";\r\n})(Turn = exports.Turn || (exports.Turn = {}));\r\nexports.TURNS = [\r\n    Turn.NONE,\r\n    Turn.R_45,\r\n    Turn.R_90,\r\n    Turn.R_135,\r\n    Turn.T_180,\r\n    Turn.L_135,\r\n    Turn.L_90,\r\n    Turn.L_45,\r\n];\r\nconst TURNS_STR = [\r\n    'T0',\r\n    'T+45',\r\n    'T+90',\r\n    'T+135',\r\n    'T180',\r\n    'T-135',\r\n    'T-90',\r\n    'T-45',\r\n];\r\nfunction turnToString(turn) {\r\n    return TURNS_STR[turn];\r\n}\r\nexports.turnToString = turnToString;\r\nfunction turnToDegrees(turn) {\r\n    return turn * 45;\r\n}\r\nexports.turnToDegrees = turnToDegrees;\r\nfunction turnIsCardinal(turn) {\r\n    return (turn & 1) === 0;\r\n}\r\nexports.turnIsCardinal = turnIsCardinal;\r\nfunction turnReverse(turn) {\r\n    return ((8 - turn) & 7);\r\n}\r\nexports.turnReverse = turnReverse;\r\n// conversion\r\nfunction turnFromCardinalDirections(from, to) {\r\n    return (((to - from) * 2) & 7);\r\n}\r\nexports.turnFromCardinalDirections = turnFromCardinalDirections;\r\nfunction turnFromCardinalTurn(turn) {\r\n    return (turn << 1);\r\n}\r\nexports.turnFromCardinalTurn = turnFromCardinalTurn;\r\nfunction turnFromDirections(from, to) {\r\n    return ((to - from) & 7);\r\n}\r\nexports.turnFromDirections = turnFromDirections;\r\n// math\r\nfunction turnAddTurn(turn1, turn2) {\r\n    return ((turn1 + turn2) & 7);\r\n}\r\nexports.turnAddTurn = turnAddTurn;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.CardinalPath = void 0;\r\nconst compass_1 = require(\"../compass\");\r\nconst offset_1 = require(\"./offset\");\r\nconst rectangle_1 = require(\"./rectangle\");\r\nconst raster_mask_1 = require(\"./raster-mask\");\r\nconst LOCAL_OFF = new offset_1.Offset();\r\nfunction sortedInsert(array, value) {\r\n    array.push(value);\r\n    let i = array.length - 1;\r\n    while (i > 0 && value < array[i - 1]) {\r\n        array[i] = array[i - 1];\r\n        i--;\r\n    }\r\n    array[i] = value;\r\n}\r\nclass CardinalPath {\r\n    constructor(start, segments) {\r\n        this._start = new offset_1.Offset();\r\n        this._start.copyFrom(start);\r\n        this._segments = segments;\r\n    }\r\n    // accessors\r\n    toString() {\r\n        return `${this._start.toString()}:`\r\n            + `${this._segments.map((segment) => compass_1.cardinalDirectionToString(segment)).join('')}`;\r\n    }\r\n    equals(other) {\r\n        return this._start.equals(other._start)\r\n            && this._segments.length === other._segments.length\r\n            && this._segments.every((v, i) => v === other._segments[i]);\r\n    }\r\n    get length() {\r\n        return this._segments.length;\r\n    }\r\n    // utilities\r\n    getIsClosed() {\r\n        LOCAL_OFF.copyFrom(this._start);\r\n        for (const segment of this._segments) {\r\n            LOCAL_OFF.addCardinalDirection(segment);\r\n        }\r\n        return this._start.equals(LOCAL_OFF);\r\n    }\r\n    *offsets() {\r\n        let { x, y } = this._start;\r\n        yield { x, y };\r\n        for (const segment of this._segments) {\r\n            LOCAL_OFF.setFromCardinalDirection(segment);\r\n            x += LOCAL_OFF.x;\r\n            y += LOCAL_OFF.y;\r\n            yield { x, y };\r\n        }\r\n    }\r\n    getBounds() {\r\n        let northY = this._start.y;\r\n        let southY = northY;\r\n        let westX = this._start.x;\r\n        let eastX = westX;\r\n        LOCAL_OFF.copyFrom(this._start);\r\n        for (const segment of this._segments) {\r\n            LOCAL_OFF.addCardinalDirection(segment);\r\n            switch (segment) {\r\n                case compass_1.CardinalDirection.NORTH:\r\n                    northY = Math.min(northY, LOCAL_OFF.y);\r\n                    break;\r\n                case compass_1.CardinalDirection.EAST:\r\n                    eastX = Math.max(eastX, LOCAL_OFF.x);\r\n                    break;\r\n                case compass_1.CardinalDirection.SOUTH:\r\n                    southY = Math.max(southY, LOCAL_OFF.y);\r\n                    break;\r\n                case compass_1.CardinalDirection.WEST:\r\n                    westX = Math.min(westX, LOCAL_OFF.x);\r\n                    break;\r\n                // istanbul ignore next\r\n                default:\r\n                    throw new Error(`bad direction ${segment} in cardinal path`);\r\n            }\r\n        }\r\n        return new rectangle_1.Rectangle(westX, northY, eastX - westX + 1, southY - northY + 1);\r\n    }\r\n    getArea() {\r\n        let total = 0;\r\n        LOCAL_OFF.copyFrom(this._start);\r\n        for (const segment of this._segments) {\r\n            LOCAL_OFF.addCardinalDirection(segment);\r\n            switch (segment) {\r\n                case compass_1.CardinalDirection.NORTH:\r\n                    total -= LOCAL_OFF.x;\r\n                    break;\r\n                case compass_1.CardinalDirection.SOUTH:\r\n                    total += LOCAL_OFF.x;\r\n                    break;\r\n            }\r\n        }\r\n        return Math.abs(total);\r\n    }\r\n    rasterize(bounds) {\r\n        const lines = new Array();\r\n        if (typeof bounds === 'undefined') {\r\n            bounds = this.getBounds();\r\n        }\r\n        // assert(this.getIsClosed())\r\n        LOCAL_OFF.copyFrom(this._start);\r\n        const { northY } = bounds;\r\n        const southY = northY + bounds.height - 1;\r\n        for (let y = northY; y < southY; y++) {\r\n            lines.push([]);\r\n        }\r\n        LOCAL_OFF.copyFrom(this._start);\r\n        // assert(LOCAL_OFF.y >= northY && LOCAL_OFF.y <= southY)\r\n        for (const segment of this._segments) {\r\n            if (segment === compass_1.CardinalDirection.SOUTH) {\r\n                sortedInsert(lines[LOCAL_OFF.y - northY], LOCAL_OFF.x);\r\n            }\r\n            LOCAL_OFF.addCardinalDirection(segment);\r\n            // assert(LOCAL_OFF.y >= northY && LOCAL_OFF.y <= southY)\r\n            if (segment === compass_1.CardinalDirection.NORTH) {\r\n                sortedInsert(lines[LOCAL_OFF.y - northY], LOCAL_OFF.x);\r\n            }\r\n        }\r\n        return new raster_mask_1.RasterMask({\r\n            westX: bounds.westX,\r\n            northY: bounds.northY,\r\n            width: bounds.width - 1,\r\n            height: bounds.height - 1,\r\n        }, lines);\r\n    }\r\n}\r\nexports.CardinalPath = CardinalPath;\r\n","\"use strict\";\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n__exportStar(require(\"./offset\"), exports);\r\n__exportStar(require(\"./size\"), exports);\r\n__exportStar(require(\"./rectangle\"), exports);\r\n__exportStar(require(\"./mask\"), exports);\r\n__exportStar(require(\"./mask-rectangle\"), exports);\r\n__exportStar(require(\"./raster-mask\"), exports);\r\n__exportStar(require(\"./cardinal-path\"), exports);\r\n__exportStar(require(\"./transform-rectangle\"), exports);\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.MaskRectangle = void 0;\r\nconst rectangle_1 = require(\"./rectangle\");\r\nconst mask_1 = require(\"./mask\");\r\nclass MaskRectangle {\r\n    constructor(rect, initialValue = false, outsideValue = false) {\r\n        this._rect = new rectangle_1.Rectangle();\r\n        if (typeof rect !== 'undefined') {\r\n            this._rect.copyFrom(rect);\r\n        }\r\n        this._mask = new mask_1.Mask(rect, initialValue);\r\n        this._outsideValue = outsideValue;\r\n    }\r\n    // accessors\r\n    toString() {\r\n        return `${this._rect.northWest}/${this._outsideValue}\\n${this._mask}`;\r\n    }\r\n    equals(other) {\r\n        return this._rect.equals(other._rect)\r\n            && this._mask.equals(other._mask)\r\n            && this._outsideValue === other._outsideValue;\r\n    }\r\n    get westX() {\r\n        return this._rect.westX;\r\n    }\r\n    get northY() {\r\n        return this._rect.northY;\r\n    }\r\n    get width() {\r\n        return this._rect.width;\r\n    }\r\n    get height() {\r\n        return this._rect.height;\r\n    }\r\n    get(x, y) {\r\n        if (!this._rect.contains(x, y)) {\r\n            return this._outsideValue;\r\n        }\r\n        return this._mask.get(x - this.westX, y - this.northY);\r\n    }\r\n    getAtIndex(index) {\r\n        return this._mask.getAtIndex(index);\r\n    }\r\n    getAtOffset(off) {\r\n        return this.get(off.x, off.y);\r\n    }\r\n    // mutators\r\n    copyFrom(other) {\r\n        this._rect.copyFrom(other._rect);\r\n        this._mask.copyFrom(other._mask);\r\n        this._outsideValue = other._outsideValue;\r\n        return this;\r\n    }\r\n    set(x, y, value) {\r\n        this._mask.set(x - this.westX, y - this.northY, value);\r\n        return this;\r\n    }\r\n    setAtOffset(off, value) {\r\n        return this.set(off.x, off.y, value);\r\n    }\r\n    setAtIndex(index, value) {\r\n        this._mask.setAtIndex(index, value);\r\n        return this;\r\n    }\r\n    // utilities\r\n    index(x, y) {\r\n        return this._mask.index(x - this.westX, y - this.northY);\r\n    }\r\n    *locations() {\r\n        for (const loc of this._mask.locations()) {\r\n            const x = loc.x + this.westX;\r\n            const y = loc.y + this.northY;\r\n            const { value } = loc;\r\n            yield { x, y, value };\r\n        }\r\n    }\r\n    *offsetsWithTrue() {\r\n        for (const off of this._mask.offsetsWithTrue()) {\r\n            const x = off.x + this.westX;\r\n            const y = off.y + this.northY;\r\n            yield { x, y };\r\n        }\r\n    }\r\n}\r\nexports.MaskRectangle = MaskRectangle;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Mask = void 0;\r\nconst size_1 = require(\"./size\");\r\nclass Mask {\r\n    constructor(size, initialValue = false) {\r\n        this._size = new size_1.Size();\r\n        if (typeof size !== 'undefined') {\r\n            this._size.copyFrom(size);\r\n        }\r\n        this._bits = new Array(Math.ceil(this._size.area / 32)).fill(initialValue ? 0xffffffff : 0);\r\n    }\r\n    // accessors\r\n    toString() {\r\n        let ret = '';\r\n        for (let y = 0; y < this.height; y++) {\r\n            for (let x = 0; x < this.width; x++) {\r\n                ret += this.get(x, y) ? '' : '';\r\n            }\r\n            ret += '\\n';\r\n        }\r\n        return ret;\r\n    }\r\n    equals(other) {\r\n        return this._size.equals(other._size)\r\n            && this._bits.length === other._bits.length\r\n            && this._bits.every((v, i) => v === other._bits[i]);\r\n    }\r\n    get width() {\r\n        return this._size.width;\r\n    }\r\n    get height() {\r\n        return this._size.height;\r\n    }\r\n    get(x, y) {\r\n        return this.getAtIndex(this.index(x, y));\r\n    }\r\n    getAtOffset(off) {\r\n        return this.get(off.x, off.y);\r\n    }\r\n    getAtIndex(index) {\r\n        // assert(index >= 0 && index < this._size.area)\r\n        const arrayIndex = index >>> 5;\r\n        const bitMask = 1 << (index & 31);\r\n        return (this._bits[arrayIndex] & bitMask) !== 0;\r\n    }\r\n    // mutators\r\n    copyFrom(other) {\r\n        this._size.copyFrom(other._size);\r\n        this._bits = other._bits.slice();\r\n        return this;\r\n    }\r\n    set(x, y, value) {\r\n        return this.setAtIndex(this.index(x, y), value);\r\n    }\r\n    setAtOffset(off, value) {\r\n        return this.set(off.x, off.y, value);\r\n    }\r\n    setAtIndex(index, value) {\r\n        // assert(index >= 0 && index < this._size.area)\r\n        const arrayIndex = index >>> 5;\r\n        const bitMask = 1 << (index & 31);\r\n        if (value) {\r\n            this._bits[arrayIndex] |= bitMask;\r\n        }\r\n        else {\r\n            this._bits[arrayIndex] &= ~bitMask;\r\n        }\r\n        return this;\r\n    }\r\n    // utilities\r\n    index(x, y) {\r\n        return this._size.index(x, y);\r\n    }\r\n    *locations() {\r\n        let arrayIndex = 0;\r\n        let bitMask = 1;\r\n        for (const { x, y } of this._size.offsets()) {\r\n            const value = (this._bits[arrayIndex] & bitMask) !== 0;\r\n            yield { x, y, value };\r\n            if (bitMask === (1 << 31)) {\r\n                bitMask = 1;\r\n                arrayIndex++;\r\n            }\r\n            else {\r\n                bitMask <<= 1;\r\n            }\r\n        }\r\n    }\r\n    *offsetsWithTrue() {\r\n        for (const { x, y, value } of this.locations()) {\r\n            if (value) {\r\n                yield { x, y };\r\n            }\r\n        }\r\n    }\r\n}\r\nexports.Mask = Mask;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Offset = void 0;\r\nconst compass_1 = require(\"../compass\");\r\nconst X_FROM_DIRECTION = [0, 1, 1, 1, 0, -1, -1, -1];\r\nconst Y_FROM_DIRECTION = [-1, -1, 0, 1, 1, 1, 0, -1];\r\nconst X_FROM_CARDINAL_DIRECTION = [0, 1, 0, -1];\r\nconst Y_FROM_CARDINAL_DIRECTION = [-1, 0, 1, 0];\r\nclass Offset {\r\n    constructor(x, y) {\r\n        if (typeof x === 'undefined') {\r\n            x = 0;\r\n        }\r\n        if (typeof y === 'undefined') {\r\n            y = 0;\r\n        }\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n    // accessors\r\n    toString() {\r\n        return `(${this.x},${this.y})`;\r\n    }\r\n    equals(other) {\r\n        return this.x === other.x && this.y === other.y;\r\n    }\r\n    // mutators\r\n    set(x, y) {\r\n        this.x = x;\r\n        this.y = y;\r\n        return this;\r\n    }\r\n    copyFrom(other) {\r\n        return this.set(other.x, other.y);\r\n    }\r\n    setFromDirection(dir) {\r\n        return this.set(X_FROM_DIRECTION[dir], Y_FROM_DIRECTION[dir]);\r\n    }\r\n    setFromCardinalDirection(dir) {\r\n        return this.set(X_FROM_CARDINAL_DIRECTION[dir], Y_FROM_CARDINAL_DIRECTION[dir]);\r\n    }\r\n    add(x, y) {\r\n        this.x += x;\r\n        this.y += y;\r\n        return this;\r\n    }\r\n    addSize(size) {\r\n        return this.add(size.width, size.height);\r\n    }\r\n    addOffset(off) {\r\n        return this.add(off.x, off.y);\r\n    }\r\n    addDirection(dir) {\r\n        return this.add(X_FROM_DIRECTION[dir], Y_FROM_DIRECTION[dir]);\r\n    }\r\n    addCardinalDirection(dir) {\r\n        return this.add(X_FROM_CARDINAL_DIRECTION[dir], Y_FROM_CARDINAL_DIRECTION[dir]);\r\n    }\r\n    subtractOffset(off) {\r\n        return this.add(-off.x, -off.y);\r\n    }\r\n    multiply(factor) {\r\n        this.x *= factor;\r\n        this.y *= factor;\r\n        return this;\r\n    }\r\n    rotate(turn, anchor) {\r\n        if (anchor) {\r\n            return this.subtractOffset(anchor).rotate(turn).addOffset(anchor);\r\n        }\r\n        else {\r\n            const dir = compass_1.cardinalDirectionFromNorthTurn(turn);\r\n            const { x, y } = this;\r\n            const dirx = X_FROM_CARDINAL_DIRECTION[dir];\r\n            const diry = Y_FROM_CARDINAL_DIRECTION[dir];\r\n            const nx = -y * dirx - x * diry;\r\n            const ny = x * dirx - y * diry;\r\n            return this.set(nx, ny);\r\n        }\r\n    }\r\n    // utilities\r\n    // chebyshev: can move in any direction (diagonals are ok)\r\n    distanceChebyshev(other) {\r\n        return Math.max(Math.abs(this.x - other.x), Math.abs(this.y - other.y));\r\n    }\r\n    // manhattan: can move only in cardinal directions (no diagonals)\r\n    distanceManhattan(other) {\r\n        return Math.abs(this.x - other.x) + Math.abs(this.y - other.y);\r\n    }\r\n    // chebyshev: can move in any direction (diagonals are ok)\r\n    *nearbyChebyshevOffsets(cursor, radius) {\r\n        if (radius >= 0) {\r\n            for (let dy = -radius; dy <= radius; dy++) {\r\n                for (let dx = -radius; dx <= radius; dx++) {\r\n                    yield cursor.set(this.x + dx, this.y + dy);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\nexports.Offset = Offset;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.RasterMask = void 0;\r\nconst rectangle_1 = require(\"./rectangle\");\r\nclass RasterMask {\r\n    constructor(bounds, lines) {\r\n        this._rect = new rectangle_1.Rectangle();\r\n        if (lines.length !== bounds.height) {\r\n            throw new Error(`bad lines array length ${lines.length} for bounds ${bounds}`);\r\n        }\r\n        this._rect.copyFrom(bounds);\r\n        this._lines = lines;\r\n    }\r\n    // accessors\r\n    toString() {\r\n        let shape = '';\r\n        const { eastX } = this._rect;\r\n        for (let y = 0; y < this.height; y++) {\r\n            const line = this._lines[y];\r\n            let x = this.westX;\r\n            for (let i = 0; i < line.length; i += 2) {\r\n                const start = line[i];\r\n                const end = line[i + 1];\r\n                while (x < start) {\r\n                    shape += '';\r\n                    x++;\r\n                }\r\n                while (x < end) {\r\n                    shape += '';\r\n                    x++;\r\n                }\r\n            }\r\n            while (x <= eastX) {\r\n                shape += '';\r\n                x++;\r\n            }\r\n            shape += '\\n';\r\n        }\r\n        return `(${this._rect.westX},${this._rect.northY})\\n${shape}`;\r\n    }\r\n    equals(other) {\r\n        return this._rect.equals(other._rect)\r\n            && this._lines.length === other._lines.length\r\n            && this._lines.every((v, i) => (v.length === other._lines[i].length\r\n                && v.every((w, j) => w === other._lines[i][j])));\r\n    }\r\n    get northY() {\r\n        return this._rect.northY;\r\n    }\r\n    get southY() {\r\n        return this._rect.southY;\r\n    }\r\n    get westX() {\r\n        return this._rect.westX;\r\n    }\r\n    get width() {\r\n        return this._rect.width;\r\n    }\r\n    get height() {\r\n        return this._rect.height;\r\n    }\r\n    get(x, y) {\r\n        if (y < this.northY || y > this._rect.southY) {\r\n            return false;\r\n        }\r\n        const line = this._lines[y - this.northY];\r\n        for (let i = 0; i < line.length; i += 2) {\r\n            if (x >= line[i] && x < line[i + 1]) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    getAtOffset(off) {\r\n        return this.get(off.x, off.y);\r\n    }\r\n    // utilities\r\n    *bandsAt(y) {\r\n        if (y >= this.northY && y <= this._rect.southY) {\r\n            const line = this._lines[y - this.northY];\r\n            for (let i = 0; i < line.length; i += 2) {\r\n                yield {\r\n                    westX: line[i],\r\n                    eastX: line[i + 1] - 1,\r\n                };\r\n            }\r\n        }\r\n    }\r\n}\r\nexports.RasterMask = RasterMask;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Rectangle = void 0;\r\nconst size_1 = require(\"./size\");\r\nconst offset_1 = require(\"./offset\");\r\nconst ROTATE_CORNER_X = [0, 0, 1, 1];\r\nconst ROTATE_CORNER_Y = [0, 1, 1, 0];\r\nclass Rectangle {\r\n    constructor(westX, northY, width, height) {\r\n        if (typeof westX === 'undefined') {\r\n            westX = 0;\r\n        }\r\n        if (typeof northY === 'undefined') {\r\n            northY = 0;\r\n        }\r\n        if (typeof width === 'undefined') {\r\n            width = 0;\r\n        }\r\n        if (typeof height === 'undefined') {\r\n            height = 0;\r\n        }\r\n        this.northWest = new offset_1.Offset(westX, northY);\r\n        this.size = new size_1.Size(width, height);\r\n    }\r\n    // accessors\r\n    toString() {\r\n        return `(${this.westX},${this.northY} ${this.width}x${this.height})`;\r\n    }\r\n    equals(other) {\r\n        return this.westX === other.westX && this.northY === other.northY && this.size.equals(other);\r\n    }\r\n    get northY() {\r\n        return this.northWest.y;\r\n    }\r\n    get southY() {\r\n        return this.northWest.y + this.size.height - 1;\r\n    }\r\n    get westX() {\r\n        return this.northWest.x;\r\n    }\r\n    get eastX() {\r\n        return this.northWest.x + this.size.width - 1;\r\n    }\r\n    get width() {\r\n        return this.size.width;\r\n    }\r\n    get height() {\r\n        return this.size.height;\r\n    }\r\n    get empty() {\r\n        return this.size.empty;\r\n    }\r\n    get area() {\r\n        return this.size.area;\r\n    }\r\n    // mutators\r\n    set(westX, northY, width, height) {\r\n        this.northWest.set(westX, northY);\r\n        this.size.set(width, height);\r\n        return this;\r\n    }\r\n    setFromCorners(off1, off2) {\r\n        const westX = Math.min(off1.x, off2.x);\r\n        const eastX = Math.max(off1.x, off2.x);\r\n        const northY = Math.min(off1.y, off2.y);\r\n        const southY = Math.max(off1.y, off2.y);\r\n        return this.set(westX, northY, eastX - westX + 1, southY - northY + 1);\r\n    }\r\n    copyFrom(other) {\r\n        return this.set(other.westX, other.northY, other.width, other.height);\r\n    }\r\n    addOffset(off) {\r\n        this.northWest.addOffset(off);\r\n        return this;\r\n    }\r\n    scale(factor) {\r\n        this.northWest.multiply(factor);\r\n        this.size.multiply(factor);\r\n        return this;\r\n    }\r\n    rotate(turn, anchor) {\r\n        const cx = ROTATE_CORNER_X[turn];\r\n        const cy = ROTATE_CORNER_Y[turn];\r\n        this.northWest.add(cx * (this.width - 1), cy * (this.height - 1)).rotate(turn, anchor);\r\n        this.size.rotate(turn);\r\n        return this;\r\n    }\r\n    extendToInclude(off) {\r\n        const dx = off.x - this.westX;\r\n        if (dx < 0) {\r\n            this.size.width -= dx;\r\n            this.northWest.x = off.x;\r\n        }\r\n        else if (dx >= this.size.width) {\r\n            this.size.width = dx + 1;\r\n        }\r\n        const dy = off.y - this.northWest.y;\r\n        if (dy < 0) {\r\n            this.size.height -= dy;\r\n            this.northWest.y = off.y;\r\n        }\r\n        else if (dy >= this.size.height) {\r\n            this.size.height = dy + 1;\r\n        }\r\n        return this;\r\n    }\r\n    // utilities\r\n    contains(x, y) {\r\n        return this.size.contains(x - this.westX, y - this.northY);\r\n    }\r\n    index(x, y) {\r\n        return this.size.index(x - this.westX, y - this.northY);\r\n    }\r\n    containsOffset(off) {\r\n        return this.contains(off.x, off.y);\r\n    }\r\n    containsRectangle(other) {\r\n        if (other.width === 0 && other.height === 0) {\r\n            return false;\r\n        }\r\n        const x = other.westX - this.westX;\r\n        const y = other.northY - this.northY;\r\n        if (!this.size.contains(x, y)) {\r\n            return false;\r\n        }\r\n        return this.size.contains(x + other.width - 1, y + other.height - 1);\r\n    }\r\n    overlapsRectangle(other) {\r\n        return this.northY <= other.northY + other.height - 1\r\n            && this.southY >= other.northY\r\n            && this.westX <= other.westX + other.width - 1\r\n            && this.eastX >= other.westX\r\n            && !this.empty\r\n            && other.width !== 0 && other.height !== 0;\r\n    }\r\n    *offsets() {\r\n        const { eastX, southY } = this;\r\n        for (let y = this.northY; y <= southY; y++) {\r\n            for (let x = this.westX; x <= eastX; x++) {\r\n                yield { x, y };\r\n            }\r\n        }\r\n    }\r\n    anyOf(predicate) {\r\n        for (const { x, y } of this.offsets()) {\r\n            if (predicate(x, y)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}\r\nexports.Rectangle = Rectangle;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Size = void 0;\r\nconst compass_1 = require(\"../compass\");\r\nclass Size {\r\n    constructor(width, height) {\r\n        if (typeof width === 'undefined') {\r\n            width = 0;\r\n        }\r\n        if (typeof height === 'undefined') {\r\n            height = 0;\r\n        }\r\n        if (width < 0 || height < 0) {\r\n            throw new Error(`bad size (${width}x${height})`);\r\n        }\r\n        this.width = width;\r\n        this.height = height;\r\n    }\r\n    // accessors\r\n    toString() {\r\n        return `(${this.width}x${this.height})`;\r\n    }\r\n    equals(other) {\r\n        return this.width === other.width && this.height === other.height;\r\n    }\r\n    get empty() {\r\n        return this.width === 0 || this.height === 0;\r\n    }\r\n    get area() {\r\n        return this.width * this.height;\r\n    }\r\n    // mutators\r\n    set(width, height) {\r\n        if (width < 0 || height < 0) {\r\n            throw new Error(`bad size (${width}x${height})`);\r\n        }\r\n        this.width = width;\r\n        this.height = height;\r\n        return this;\r\n    }\r\n    copyFrom(other) {\r\n        return this.set(other.width, other.height);\r\n    }\r\n    add(width, height) {\r\n        this.width += width;\r\n        this.height += height;\r\n        return this;\r\n    }\r\n    multiply(factor) {\r\n        this.width *= factor;\r\n        this.height *= factor;\r\n        return this;\r\n    }\r\n    rotate(turn) {\r\n        if (compass_1.axisFromNorthSouthTurn(turn) === compass_1.Axis.WEST_EAST) {\r\n            this.set(this.height, this.width);\r\n        }\r\n        return this;\r\n    }\r\n    // utilities\r\n    contains(x, y) {\r\n        return x >= 0 && y >= 0 && x < this.width && y < this.height;\r\n    }\r\n    containsOffset(off) {\r\n        return this.contains(off.x, off.y);\r\n    }\r\n    index(x, y) {\r\n        return y * this.width + x;\r\n    }\r\n    *offsets() {\r\n        for (let y = 0; y < this.height; y++) {\r\n            for (let x = 0; x < this.width; x++) {\r\n                yield { x, y };\r\n            }\r\n        }\r\n    }\r\n    anyOf(predicate) {\r\n        for (const { x, y } of this.offsets()) {\r\n            if (predicate(x, y)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}\r\nexports.Size = Size;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.TransformRectangle = void 0;\r\nconst rectangle_1 = require(\"./rectangle\");\r\nconst compass_1 = require(\"../compass\");\r\nconst offset_1 = require(\"./offset\");\r\nconst size_1 = require(\"./size\");\r\nconst LOCAL_OFF = new offset_1.Offset();\r\nconst LOCAL_OFF2 = new offset_1.Offset();\r\nconst LOCAL_SIZE = new size_1.Size();\r\nclass TransformRectangle {\r\n    constructor(width, height) {\r\n        this._size = new size_1.Size();\r\n        this._flip = compass_1.Flip.HEADS;\r\n        this._rotate = compass_1.CardinalTurn.NONE;\r\n        this._translate = new offset_1.Offset();\r\n        this._matrix = [1, 0, 0, 0, 1, 0];\r\n        this._targetRect = new rectangle_1.Rectangle();\r\n        if (typeof width === 'undefined') {\r\n            // nothing\r\n        }\r\n        else if (typeof width === 'number') {\r\n            this._size.set(width, height);\r\n        }\r\n        else {\r\n            this._size.copyFrom(width);\r\n        }\r\n        this._update();\r\n    }\r\n    // accessors\r\n    toString() {\r\n        return `[${this._size}`\r\n            + ` -> ${compass_1.flipToString(this._flip)} ${compass_1.cardinalTurnToString(this._rotate)} ${this._translate}`\r\n            + ` -> ${this._targetRect}]`;\r\n    }\r\n    equals(other) {\r\n        return this._size.equals(other._size)\r\n            && this._flip === other._flip\r\n            && this._rotate === other._rotate\r\n            && this._translate.equals(other._translate);\r\n    }\r\n    get flip() {\r\n        return this._flip;\r\n    }\r\n    get rotate() {\r\n        return this._rotate;\r\n    }\r\n    get northY() {\r\n        return this._translate.y;\r\n    }\r\n    get southY() {\r\n        return this._translate.y + this._targetRect.height - 1;\r\n    }\r\n    get westX() {\r\n        return this._translate.x;\r\n    }\r\n    get eastX() {\r\n        return this._translate.x + this._targetRect.width - 1;\r\n    }\r\n    get width() {\r\n        return this._targetRect.width;\r\n    }\r\n    get height() {\r\n        return this._targetRect.height;\r\n    }\r\n    // internal\r\n    // 0\r\n    //    0 -1\r\n    // +90\r\n    //    1  0\r\n    // 180\r\n    //    0  1\r\n    // -90\r\n    //   -1  0\r\n    //\r\n    // heads:\r\n    //   0\r\n    //      1  0  x\r\n    //      0  1  y\r\n    //   +90\r\n    //      0 -1  x + h - 1\r\n    //      1  0  y\r\n    //   180\r\n    //     -1  0  x + w - 1\r\n    //      0 -1  y + h - 1\r\n    //   -90\r\n    //      0  1  x\r\n    //     -1  0  y + w - 1\r\n    //\r\n    // tails:\r\n    //   0\r\n    //     -1  0  x + w - 1\r\n    //      0  1  y\r\n    //   +90\r\n    //      0 -1  x + h - 1\r\n    //     -1  0  y + w - 1\r\n    //   180\r\n    //      1  0  x\r\n    //      0 -1  y + h - 1\r\n    //   -90\r\n    //      0  1  x\r\n    //      1  0  y\r\n    _update() {\r\n        LOCAL_OFF.setFromCardinalDirection(compass_1.cardinalDirectionFromNorthTurn(this._rotate));\r\n        const flipSign = this._flip === compass_1.Flip.TAILS ? -1 : 1;\r\n        this._matrix[0] = -LOCAL_OFF.y * flipSign;\r\n        this._matrix[1] = -LOCAL_OFF.x;\r\n        this._matrix[2] = this._translate.x;\r\n        this._matrix[3] = LOCAL_OFF.x * flipSign;\r\n        this._matrix[4] = -LOCAL_OFF.y;\r\n        this._matrix[5] = this._translate.y;\r\n        switch (this._rotate) {\r\n            case compass_1.CardinalTurn.NONE:\r\n                if (this._flip === compass_1.Flip.TAILS) {\r\n                    this._matrix[2] += this._size.width - 1;\r\n                }\r\n                break;\r\n            case compass_1.CardinalTurn.RIGHT:\r\n                this._matrix[2] += this._size.height - 1;\r\n                if (this._flip === compass_1.Flip.TAILS) {\r\n                    this._matrix[5] += this._size.width - 1;\r\n                }\r\n                break;\r\n            case compass_1.CardinalTurn.AROUND:\r\n                this._matrix[5] += this._size.height - 1;\r\n                if (this._flip === compass_1.Flip.HEADS) {\r\n                    this._matrix[2] += this._size.width - 1;\r\n                }\r\n                break;\r\n            case compass_1.CardinalTurn.LEFT:\r\n                if (this._flip === compass_1.Flip.HEADS) {\r\n                    this._matrix[5] += this._size.width - 1;\r\n                }\r\n                break;\r\n        }\r\n        LOCAL_SIZE.copyFrom(this._size).rotate(this._rotate);\r\n        this._targetRect.set(this._translate.x, this._translate.y, LOCAL_SIZE.width, LOCAL_SIZE.height);\r\n        return this;\r\n    }\r\n    // mutators\r\n    copyFrom(other) {\r\n        this._size.copyFrom(other._size);\r\n        this._flip = other._flip;\r\n        this._rotate = other._rotate;\r\n        this._translate.copyFrom(other._translate);\r\n        other._matrix.forEach((v, i) => this._matrix[i] = v);\r\n        this._targetRect.copyFrom(other._targetRect);\r\n        return this;\r\n    }\r\n    reset() {\r\n        this._flip = compass_1.Flip.HEADS;\r\n        this._rotate = compass_1.CardinalTurn.NONE;\r\n        this._translate.set(0, 0);\r\n        return this._update();\r\n    }\r\n    invert() {\r\n        const nrotate = compass_1.cardinalTurnFromCardinalDirections(compass_1.CardinalDirection.NORTH, compass_1.cardinalDirectionFromCardinalOrientation(compass_1.cardinalOrientationReverse(compass_1.cardinalOrientationFromFlipAndCardinalDirection(this._flip, compass_1.cardinalDirectionFromNorthTurn(this._rotate)))));\r\n        this._rotate = nrotate;\r\n        this._size.rotate(nrotate);\r\n        this._translate.multiply(-1);\r\n        return this._update();\r\n    }\r\n    setTransform(flip, rotate, translate) {\r\n        this._flip = flip;\r\n        this._rotate = rotate;\r\n        this._translate.copyFrom(translate);\r\n        return this._update();\r\n    }\r\n    setFlip(flip) {\r\n        this._flip = flip;\r\n        return this._update();\r\n    }\r\n    setRotate(rotate) {\r\n        this._rotate = rotate;\r\n        return this._update();\r\n    }\r\n    setTranslate(x, y) {\r\n        this._translate.set(x, y);\r\n        return this._update();\r\n    }\r\n    setTranslateOffset(translate) {\r\n        this._translate.copyFrom(translate);\r\n        return this._update();\r\n    }\r\n    // utility\r\n    applyToCardinalOrientation(orientation) {\r\n        if (this._flip === compass_1.Flip.TAILS) {\r\n            orientation = compass_1.cardinalOrientationFlip(orientation, compass_1.Axis.NORTH_SOUTH);\r\n        }\r\n        return compass_1.cardinalOrientationAddCardinalTurn(orientation, this._rotate);\r\n    }\r\n    unapplyFromCardinalOrientation(orientation) {\r\n        orientation = compass_1.cardinalOrientationAddCardinalTurn(orientation, compass_1.cardinalTurnReverse(this._rotate));\r\n        if (this._flip === compass_1.Flip.TAILS) {\r\n            orientation = compass_1.cardinalOrientationFlip(orientation, compass_1.Axis.NORTH_SOUTH);\r\n        }\r\n        return orientation;\r\n    }\r\n    applyToCardinalDirection(orientation) {\r\n        return compass_1.cardinalDirectionFromCardinalOrientation(this.applyToCardinalOrientation(compass_1.cardinalOrientationFromFlipAndCardinalDirection(compass_1.Flip.HEADS, orientation)));\r\n    }\r\n    unapplyFromCardinalDirection(orientation) {\r\n        return compass_1.cardinalDirectionFromCardinalOrientation(this.unapplyFromCardinalOrientation(compass_1.cardinalOrientationFromFlipAndCardinalDirection(compass_1.Flip.HEADS, orientation)));\r\n    }\r\n    applyTo(offOut, x, y) {\r\n        const nx = x * this._matrix[0] + y * this._matrix[1] + this._matrix[2];\r\n        const ny = x * this._matrix[3] + y * this._matrix[4] + this._matrix[5];\r\n        return offOut.set(nx, ny);\r\n    }\r\n    unapplyFrom(offOut, x, y) {\r\n        const tx = x - this._matrix[2];\r\n        const ty = y - this._matrix[5];\r\n        const nx = tx * this._matrix[0] + ty * this._matrix[3];\r\n        const ny = tx * this._matrix[1] + ty * this._matrix[4];\r\n        return offOut.set(nx, ny);\r\n    }\r\n    applyToOffset(offOut, off) {\r\n        if (typeof off === 'undefined') {\r\n            off = offOut;\r\n        }\r\n        return this.applyTo(offOut, off.x, off.y);\r\n    }\r\n    unapplyFromOffset(offOut, off) {\r\n        if (typeof off === 'undefined') {\r\n            off = offOut;\r\n        }\r\n        return this.unapplyFrom(offOut, off.x, off.y);\r\n    }\r\n    applyToRectangle(rectOut, rect) {\r\n        if (typeof rect !== 'undefined') {\r\n            rectOut.copyFrom(rect);\r\n        }\r\n        LOCAL_OFF.set(rectOut.westX, rectOut.northY);\r\n        LOCAL_OFF2.set(rectOut.eastX, rectOut.southY);\r\n        this.applyToOffset(LOCAL_OFF);\r\n        this.applyToOffset(LOCAL_OFF2);\r\n        return rectOut.setFromCorners(LOCAL_OFF, LOCAL_OFF2);\r\n    }\r\n    unapplyFromRectangle(rectOut, rect) {\r\n        if (typeof rect !== 'undefined') {\r\n            rectOut.copyFrom(rect);\r\n        }\r\n        LOCAL_OFF.set(rectOut.westX, rectOut.northY);\r\n        LOCAL_OFF2.set(rectOut.eastX, rectOut.southY);\r\n        this.unapplyFromOffset(LOCAL_OFF);\r\n        this.unapplyFromOffset(LOCAL_OFF2);\r\n        return rectOut.setFromCorners(LOCAL_OFF, LOCAL_OFF2);\r\n    }\r\n}\r\nexports.TransformRectangle = TransformRectangle;\r\n","\"use strict\";\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n__exportStar(require(\"./compass\"), exports);\r\n__exportStar(require(\"./grid\"), exports);\r\n","\"use strict\";\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n});\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.computeFieldOfView = void 0;\r\nconst geom = __importStar(require(\"tiled-geometry\"));\r\nconst constants = __importStar(require(\"./constants\"));\r\nconst wedge_1 = require(\"./wedge\");\r\nconst tile_flags_1 = require(\"./tile-flags\");\r\nconst field_of_view_impl_1 = require(\"./field-of-view-impl\");\r\nconst warp_data_1 = require(\"./warp-data\");\r\n/* eslint-disable indent */\r\n/**\r\n * Compute the field of view for a camera at the given tile.\r\n * chebyshevRadius is the vision radius.  It uses chebyshev distance\r\n * (https://en.wikipedia.org/wiki/Chebyshev_distance), which just means\r\n * that the limit of vision in a large empty field will be square.\r\n *\r\n * This returns a WarpRect, which indicates which tiles are visible\r\n * and which map is seen in each tile.  warpRect.getMask(x, y) will return\r\n * true for visible tiles, warpRect.getMap(x, y) will return\r\n * the map for that tile, and warpRect.getOffset(x, y) will return the\r\n * location in that map which is visible there.\r\n */\r\nfunction computeFieldOfView(map, x, y, chebyshevRadius) {\r\n    if (!map.contains(x, y)) {\r\n        throw new Error(`origin is not on the map`);\r\n    }\r\n    const origin = new geom.Offset(x, y);\r\n    const field = new field_of_view_impl_1.FieldOfViewImpl(map, origin, chebyshevRadius);\r\n    const warpDataCache = new warp_data_1.WarpDataCache();\r\n    const baseWarp = warpDataCache.get(map, 0, x, y);\r\n    // the field is divided into quadrants\r\n    quadrant(field, origin, chebyshevRadius, -1, -1, warpDataCache, baseWarp);\r\n    quadrant(field, origin, chebyshevRadius, 1, -1, warpDataCache, baseWarp);\r\n    quadrant(field, origin, chebyshevRadius, -1, 1, warpDataCache, baseWarp);\r\n    quadrant(field, origin, chebyshevRadius, 1, 1, warpDataCache, baseWarp);\r\n    return field;\r\n}\r\nexports.computeFieldOfView = computeFieldOfView;\r\nfunction quadrant(field, origin, chebyshevRadius, xSign, ySign, warpDataCache, baseWarp) {\r\n    const yDir = [geom.CardinalDirection.NORTH, geom.CardinalDirection.SOUTH][(ySign + 1) / 2];\r\n    const xDir = [geom.CardinalDirection.WEST, geom.CardinalDirection.EAST][(xSign + 1) / 2];\r\n    const farYFlag = [tile_flags_1.TileFlags.WALL_NORTH, tile_flags_1.TileFlags.WALL_SOUTH][(ySign + 1) / 2];\r\n    const farXFlag = [tile_flags_1.TileFlags.WALL_WEST, tile_flags_1.TileFlags.WALL_EAST][(xSign + 1) / 2];\r\n    let wedges = wedge_1.initWedges(baseWarp);\r\n    for (let ny = 0; ny <= chebyshevRadius; ny++) {\r\n        const dy = ny * ySign;\r\n        for (let nx = 0; nx <= chebyshevRadius; nx++) {\r\n            const dx = nx * xSign;\r\n            // the slopes of the four corners of this tile\r\n            // these are named as follows:\r\n            //   slopeY is the slope closest to the Y axis\r\n            //   slopeFar is the slope to the farthest corner\r\n            //   slopeMid is the slope to the center\r\n            //   slopeX is the slope closest to the X axis\r\n            // these are always true:\r\n            //   slopeY < slopeFar < slopeX\r\n            //   slopeY < slopeMid < slopeX\r\n            //\r\n            // O = origin, C = current\r\n            // +---+---+---+\r\n            // | O |   |   |\r\n            // +---+---+---X\r\n            // |   |   | C |\r\n            // +---+---Y---F\r\n            const slopeY = (nx - 0.5) / (ny + 0.5);\r\n            const slopeFar = (nx + 0.5) / (ny + 0.5);\r\n            const slopeMid = ny !== 0 ? nx / ny : Number.POSITIVE_INFINITY;\r\n            const slopeX = ny !== 0 ? (nx + 0.5) / (ny - 0.5) : Number.POSITIVE_INFINITY;\r\n            // among all non-shadow wedges that intersect this tile,\r\n            // choose the one closest to slopeMid (with additional rules\r\n            // for breaking ties)\r\n            {\r\n                const wedge = wedge_1.getBestWedge(wedges, slopeY, slopeMid, slopeX);\r\n                field.warps[field.visible.index(dx, dy)] = wedge.warp;\r\n                if (wedge.shadow) {\r\n                    field.visible.set(dx, dy, false);\r\n                }\r\n            }\r\n            const newWedges = [];\r\n            // add shadows and warps to each wedge that passes through this tile\r\n            for (const wedge of wedges) {\r\n                if (wedge.low >= slopeX || wedge.high <= slopeY) {\r\n                    newWedges.push(wedge);\r\n                    continue;\r\n                }\r\n                const warpData = wedge.warp;\r\n                const map = warpData.map;\r\n                const x = warpData.shiftX + dx;\r\n                const y = warpData.shiftY + dy;\r\n                if (!map.contains(x, y)) {\r\n                    newWedges.push(wedge);\r\n                    continue;\r\n                }\r\n                // the walls of this tile\r\n                // these are named as follows:\r\n                //   wallY is the farthest horizontal wall (slopeY to slopeFar)\r\n                //   wallX is the farthest vertical wall (slopeFar to slopeX)\r\n                //\r\n                // O = origin, C = current\r\n                // +---+---+---+\r\n                // | O |   |   |\r\n                // +---+---+---+\r\n                // |   |   | C X\r\n                // +---+---+-Y-+\r\n                const mapIndex = map.index(x, y);\r\n                const tileFlags = map.getTileFlagsAtIndex(mapIndex);\r\n                const warpY = map.getWarpAtIndex(mapIndex, yDir);\r\n                const warpX = map.getWarpAtIndex(mapIndex, xDir);\r\n                // warps override walls\r\n                const wallY = !warpY && (tileFlags & farYFlag) !== 0;\r\n                const wallX = !warpX && (tileFlags & farXFlag) !== 0;\r\n                // shadows\r\n                // /- slopeY - WALL_OUTSET\r\n                // |  /- slopeY\r\n                // |  .  /- slopeY + BODY_INSET\r\n                // |  .  |     /- slopeFar - WALL_OUTSET\r\n                // |  .  |     |  /- slopeFar\r\n                // |  .  |     |  .  /- slopeFar + WALL_OUTSET\r\n                // |  .  |     |  .  |     /- slopeX - BODY_INSET\r\n                // |  .  |     |  .  |     |  /- slopeX\r\n                // |  .  |     |  .  |     |  .  /- slopeX + WALL_OUTSET\r\n                // |  .  |     |  .  |     |  .  |\r\n                // |  .  |     |  .  |     |  .  |\r\n                // =======wallY=======\r\n                //       ========body=======\r\n                //             =======wallX=======\r\n                let shadowWedges;\r\n                if (wallY && wallX) {\r\n                    // add full shadow, covering wallY and wallX\r\n                    shadowWedges = wedge_1.addShadow(wedge, slopeY - constants.WALL_OUTSET, slopeX + constants.WALL_OUTSET);\r\n                }\r\n                else {\r\n                    const body = (nx !== 0 || ny !== 0) && (tileFlags & tile_flags_1.TileFlags.BODY) !== 0;\r\n                    if (body) {\r\n                        if (wallY) {\r\n                            // add shadow covering wallY and body\r\n                            shadowWedges = wedge_1.addShadow(wedge, slopeY - constants.WALL_OUTSET, slopeX - constants.BODY_INSET);\r\n                        }\r\n                        else if (wallX) {\r\n                            // add shadow covering body and wallX\r\n                            shadowWedges = wedge_1.addShadow(wedge, slopeY + constants.BODY_INSET, slopeX + constants.WALL_OUTSET);\r\n                        }\r\n                        else {\r\n                            // add shadow covering body\r\n                            shadowWedges = wedge_1.addShadow(wedge, slopeY + constants.BODY_INSET, slopeX - constants.BODY_INSET);\r\n                        }\r\n                    }\r\n                    else if (wallY) {\r\n                        // add shadow covering wallY\r\n                        shadowWedges = wedge_1.addShadow(wedge, slopeY - constants.WALL_OUTSET, slopeFar + constants.WALL_OUTSET);\r\n                    }\r\n                    else if (wallX) {\r\n                        // add shadow covering wallX\r\n                        shadowWedges = wedge_1.addShadow(wedge, slopeFar - constants.WALL_OUTSET, slopeX + constants.WALL_OUTSET);\r\n                    }\r\n                    else {\r\n                        // no new shadows\r\n                        shadowWedges = [wedge];\r\n                    }\r\n                }\r\n                for (const shadowWedge of shadowWedges) {\r\n                    // warps\r\n                    // /- slopeY - WARP_OUTSET\r\n                    // |  /- slopeY\r\n                    // |  .     /- slopeFar - WARP_OUTSET\r\n                    // |  .     |  /- slopeFar\r\n                    // |  .     |  .  /- slopeFar + WARP_OUTSET\r\n                    // |  .     |  .  |     /- slopeX\r\n                    // |  .     |  .  |     .  /- slopeX + WARP_OUTSET\r\n                    // |  .     |  .  |     .  |\r\n                    // |  .     |  .  |     .  |\r\n                    // =====warpY======\r\n                    //          =====warpX======\r\n                    // if warpY and warpX, then they don't overlap:\r\n                    // ====warpY====\r\n                    //             ====warpX====\r\n                    if (warpY && warpX) {\r\n                        // add warp from slopeY - WARP_OUTSET to slopeFar\r\n                        const warpDataY = warpDataCache.get(warpY.map, warpData.warpCount + 1, warpData.shiftX + warpY.offsetShift.x, warpData.shiftY + warpY.offsetShift.y);\r\n                        const warpWedges = wedge_1.addWarp(shadowWedge, warpDataY, slopeY - constants.WARP_OUTSET, slopeFar);\r\n                        // add warp from slopeFar to slopeX + WARP_OUTSET\r\n                        const warpDataX = warpDataCache.get(warpX.map, warpData.warpCount + 1, warpData.shiftX + warpX.offsetShift.x, warpData.shiftY + warpX.offsetShift.y);\r\n                        for (const warpWedge of warpWedges) {\r\n                            newWedges.push(...wedge_1.addWarp(warpWedge, warpDataX, slopeFar, slopeX + constants.WARP_OUTSET));\r\n                        }\r\n                    }\r\n                    else if (warpY) {\r\n                        // no warpX\r\n                        // add warp from slopeY - WARP_OUTSET to slopeFar + WARP_OUTSET\r\n                        const warpDataY = warpDataCache.get(warpY.map, warpData.warpCount + 1, warpData.shiftX + warpY.offsetShift.x, warpData.shiftY + warpY.offsetShift.y);\r\n                        newWedges.push(...wedge_1.addWarp(shadowWedge, warpDataY, slopeY - constants.WARP_OUTSET, slopeFar + constants.WARP_OUTSET));\r\n                    }\r\n                    else if (warpX) {\r\n                        // no warpY\r\n                        // add warp from slopeFar - WARP_OUTSET to slopeX + WARP_OUTSET\r\n                        const warpDataX = warpDataCache.get(warpX.map, warpData.warpCount + 1, warpData.shiftX + warpX.offsetShift.x, warpData.shiftY + warpX.offsetShift.y);\r\n                        newWedges.push(...wedge_1.addWarp(shadowWedge, warpDataX, slopeFar - constants.WARP_OUTSET, slopeX + constants.WARP_OUTSET));\r\n                    }\r\n                    else {\r\n                        // no warps\r\n                        newWedges.push(shadowWedge);\r\n                    }\r\n                }\r\n            }\r\n            wedges = wedge_1.mergeWedges(newWedges);\r\n        }\r\n    }\r\n}\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.PICK_WEDGE_EPSILON = exports.WARP_OUTSET = exports.WALL_OUTSET = exports.BODY_INSET = void 0;\r\n/**\r\n * A smallish number, to adjust some wedges.\r\n */\r\nconst EPSILON = 0.00001;\r\n/**\r\n * Bodies in this algorithm do not entirely fill their tiles.  This is\r\n * implemented by adjusting the angles of the shadows the bodies cast,\r\n * making the wedge very slightly narrower.  BODY_INSET represents the\r\n * amount of reduction on either side of the wedge.\r\n */\r\nexports.BODY_INSET = EPSILON;\r\n/**\r\n * Walls do fill the entire tile edge.  With infinite precision, there would be\r\n * no need to adjust the shadow cast by a wall.  But we're using floating point\r\n * math here, which means imprecision can creep in and cause angles not to line\r\n * up properly.  To fix that, we widen the wedges of the shadows cast by walls.\r\n * We must make sure not to widen them as much as we narrow the body shadows,\r\n * or else they might close the gap we want between a body and a wall.\r\n */\r\nexports.WALL_OUTSET = exports.BODY_INSET / 4;\r\n// TODO make this / 10 so it's easier to see in the number\r\n/**\r\n * Warps also fill the entire tile edge.  But we don't extend warps as much as\r\n * walls, just in case a sliver of warp might make it past a wall on the other\r\n * side of the warp, at the edge of the warp range.\r\n */\r\nexports.WARP_OUTSET = exports.WALL_OUTSET / 4;\r\n// TODO make this / 10 so it's easier to see in the number\r\n// must be bigger than WALL_OUTSET\r\nexports.PICK_WEDGE_EPSILON = exports.WALL_OUTSET * 2;\r\n","\"use strict\";\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n});\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.FieldOfViewImpl = void 0;\r\nconst geom = __importStar(require(\"tiled-geometry\"));\r\nclass FieldOfViewImpl {\r\n    constructor(map, origin, chebyshevRadius) {\r\n        this.map = map;\r\n        this.origin = origin;\r\n        this.chebyshevRadius = chebyshevRadius;\r\n        const boundRect = new geom.Rectangle(-chebyshevRadius, -chebyshevRadius, chebyshevRadius * 2 + 1, chebyshevRadius * 2 + 1);\r\n        this.visible = new geom.MaskRectangle(boundRect, true);\r\n        // the origin is always visible\r\n        this.visible.set(0, 0, true);\r\n        this.warps = new Array(boundRect.area);\r\n    }\r\n    getVisible(dx, dy) {\r\n        return this.visible.get(dx, dy);\r\n    }\r\n    getTargetMap(dx, dy) {\r\n        return this._getWarp(dx, dy).map;\r\n    }\r\n    getTargetOffset(dx, dy) {\r\n        const warp = this._getWarp(dx, dy);\r\n        return { x: warp.shiftX + dx, y: warp.shiftY + dy };\r\n    }\r\n    toString() {\r\n        let ret = '';\r\n        for (let dy = -this.chebyshevRadius; dy <= this.chebyshevRadius; dy++) {\r\n            for (let dx = -this.chebyshevRadius; dx <= this.chebyshevRadius; dx++) {\r\n                if (dx === 0 && dy === 0) {\r\n                    ret += '@';\r\n                }\r\n                else if (this.getVisible(dx, dy)) {\r\n                    const warp = this._getWarp(dx, dy);\r\n                    ret += warp.map.id[0];\r\n                }\r\n                else {\r\n                    ret += '.';\r\n                }\r\n            }\r\n            ret += '\\n';\r\n        }\r\n        return ret;\r\n    }\r\n    // internal\r\n    _getWarp(dx, dy) {\r\n        return this.warps[this.visible.index(dx, dy)];\r\n    }\r\n}\r\nexports.FieldOfViewImpl = FieldOfViewImpl;\r\n","\"use strict\";\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n});\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.FieldOfViewMap = void 0;\r\nconst geom = __importStar(require(\"tiled-geometry\"));\r\nconst tile_flags_1 = require(\"./tile-flags\");\r\n/**\r\n * We avoid heap allocations during the core part of the algorithm by using this\r\n * preallocated offset object.\r\n */\r\nconst LOCAL_OFF = new geom.Offset();\r\n/**\r\n * The FieldOfViewMap class describes the map over which the field of view will be\r\n * computed.  It starts empty.\r\n */\r\nclass FieldOfViewMap {\r\n    constructor(id, width, height, addEdgeWalls = false) {\r\n        this._size = new geom.Size();\r\n        this._warps = new Array();\r\n        this.id = id;\r\n        this._size.set(width, height);\r\n        this._tileFlags = new Array(this._size.area).fill(0);\r\n        if (addEdgeWalls) {\r\n            for (let y = 0; y < this._size.height; y++) {\r\n                this._addFlag(0, y, tile_flags_1.TileFlags.WALL_WEST);\r\n                this._addFlag(this._size.width - 1, y, tile_flags_1.TileFlags.WALL_EAST);\r\n            }\r\n            for (let x = 0; x < this._size.width; x++) {\r\n                this._addFlag(x, 0, tile_flags_1.TileFlags.WALL_NORTH);\r\n                this._addFlag(x, this._size.height - 1, tile_flags_1.TileFlags.WALL_SOUTH);\r\n            }\r\n        }\r\n        this._tileWarpIds = geom.CARDINAL_DIRECTIONS.map(() => new Array(this._size.area).fill(-1));\r\n    }\r\n    get width() {\r\n        return this._size.width;\r\n    }\r\n    get height() {\r\n        return this._size.height;\r\n    }\r\n    // bodies\r\n    addBody(x, y) {\r\n        this._addFlag(x, y, tile_flags_1.TileFlags.BODY);\r\n        return this;\r\n    }\r\n    removeBody(x, y) {\r\n        this._removeFlag(x, y, tile_flags_1.TileFlags.BODY);\r\n        return this;\r\n    }\r\n    getBody(x, y) {\r\n        const index = this.index(x, y);\r\n        return (this._tileFlags[index] & tile_flags_1.TileFlags.BODY) !== 0;\r\n    }\r\n    // walls\r\n    /**\r\n     * Adds a wall at a particular edge.  This automatically adds the\r\n     * corresponding wall on the other side.\r\n     */\r\n    addWall(x, y, dir, oneWay = false) {\r\n        this._addFlag(x, y, 1 << dir);\r\n        LOCAL_OFF.set(x, y);\r\n        LOCAL_OFF.addCardinalDirection(dir);\r\n        if (!oneWay && this._size.containsOffset(LOCAL_OFF)) {\r\n            this._addFlag(LOCAL_OFF.x, LOCAL_OFF.y, 1 << geom.cardinalDirectionOpposite(dir));\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Removes a wall at a particular edge.  This automatically removes the\r\n     * corresponding wall on the other side.\r\n     */\r\n    removeWall(x, y, dir, oneWay = false) {\r\n        this._removeFlag(x, y, 1 << dir);\r\n        LOCAL_OFF.set(x, y);\r\n        LOCAL_OFF.addCardinalDirection(dir);\r\n        if (!oneWay && this._size.containsOffset(LOCAL_OFF)) {\r\n            this._removeFlag(LOCAL_OFF.x, LOCAL_OFF.y, 1 << geom.cardinalDirectionOpposite(dir));\r\n        }\r\n        return this;\r\n    }\r\n    getWalls(x, y) {\r\n        const index = this.index(x, y);\r\n        return this._tileFlags[index] & geom.CardinalDirectionFlags.ALL;\r\n    }\r\n    getWall(x, y, dir) {\r\n        return (this.getWalls(x, y) & (1 << dir)) !== 0;\r\n    }\r\n    // warps\r\n    // TODO add length argument\r\n    addWarp(sourceX, sourceY, dir, targetMap, targetX, targetY, oneWay) {\r\n        if (!oneWay) {\r\n            LOCAL_OFF.set(sourceX - targetX, sourceY - targetY)\r\n                .addCardinalDirection(dir);\r\n            const targetWarpId = targetMap._findOrMakeWarp(this, LOCAL_OFF);\r\n            targetMap._addWarp(targetX, targetY, geom.cardinalDirectionOpposite(dir), targetWarpId);\r\n        }\r\n        LOCAL_OFF.set(targetX - sourceX, targetY - sourceY)\r\n            .addCardinalDirection(geom.cardinalDirectionOpposite(dir));\r\n        const warpId = this._findOrMakeWarp(targetMap, LOCAL_OFF);\r\n        this._addWarp(sourceX, sourceY, dir, warpId);\r\n        return this;\r\n    }\r\n    // TODO add length argument\r\n    removeWarp(sourceX, sourceY, dir, oneWay = false) {\r\n        if (!oneWay) {\r\n            const warp = this._getWarp(sourceX, sourceY, dir);\r\n            if (!warp) {\r\n                return this;\r\n            }\r\n            LOCAL_OFF.set(sourceX, sourceY)\r\n                .addCardinalDirection(dir)\r\n                .addOffset(warp.offsetShift);\r\n            warp.map._removeWarp(LOCAL_OFF.x, LOCAL_OFF.y, geom.cardinalDirectionOpposite(dir));\r\n        }\r\n        this._removeWarp(sourceX, sourceY, dir);\r\n        return this;\r\n    }\r\n    getWarpFlags(sourceX, sourceY) {\r\n        let ret = geom.CardinalDirectionFlags.NONE;\r\n        geom.CARDINAL_DIRECTIONS.forEach((dir) => {\r\n            if (this._getWarp(sourceX, sourceY, dir)) {\r\n                ret = geom.cardinalDirectionFlagsSetCardinalDirection(ret, dir);\r\n            }\r\n        });\r\n        return ret;\r\n    }\r\n    getWarpFlag(sourceX, sourceY, dir) {\r\n        return !!this._getWarp(sourceX, sourceY, dir);\r\n    }\r\n    getWarpTargetMap(sourceX, sourceY, dir) {\r\n        var _a;\r\n        return (_a = this._getWarp(sourceX, sourceY, dir)) === null || _a === void 0 ? void 0 : _a.map;\r\n    }\r\n    getWarpTargetOffset(sourceX, sourceY, dir) {\r\n        var _a;\r\n        const shift = (_a = this._getWarp(sourceX, sourceY, dir)) === null || _a === void 0 ? void 0 : _a.offsetShift;\r\n        if (shift) {\r\n            LOCAL_OFF.copyFrom(shift)\r\n                .add(sourceX, sourceY)\r\n                .addCardinalDirection(dir);\r\n            return { x: LOCAL_OFF.x, y: LOCAL_OFF.y };\r\n        }\r\n        return undefined;\r\n    }\r\n    // internal\r\n    index(x, y) {\r\n        return this._size.index(x, y);\r\n    }\r\n    _addFlag(x, y, flag) {\r\n        const index = this.index(x, y);\r\n        this._tileFlags[index] |= flag;\r\n    }\r\n    _removeFlag(x, y, flag) {\r\n        const index = this.index(x, y);\r\n        this._tileFlags[index] &= ~flag;\r\n    }\r\n    _makeWarp(map, offsetShiftX, offsetShiftY) {\r\n        const id = this._warps.length;\r\n        this._warps.push({\r\n            map,\r\n            offsetShift: new geom.Offset(offsetShiftX, offsetShiftY),\r\n        });\r\n        return id;\r\n    }\r\n    _findOrMakeWarp(map, offsetShift) {\r\n        for (let fid = 0; fid < this._warps.length; fid++) {\r\n            const fwarp = this._warps[fid];\r\n            if (fwarp.map === map && fwarp.offsetShift.equals(offsetShift)) {\r\n                return fid;\r\n            }\r\n        }\r\n        return this._makeWarp(map, offsetShift.x, offsetShift.y);\r\n    }\r\n    _addWarp(x, y, dir, warpId) {\r\n        const index = this.index(x, y);\r\n        this._tileWarpIds[dir][index] = warpId;\r\n    }\r\n    _removeWarp(x, y, dir) {\r\n        const index = this.index(x, y);\r\n        delete this._tileWarpIds[dir][index];\r\n    }\r\n    _getWarp(x, y, dir) {\r\n        const index = this.index(x, y);\r\n        return this.getWarpAtIndex(index, dir);\r\n    }\r\n    contains(x, y) {\r\n        return this._size.contains(x, y);\r\n    }\r\n    getTileFlagsAtIndex(index) {\r\n        return this._tileFlags[index];\r\n    }\r\n    getWarpAtIndex(index, dir) {\r\n        const warpId = this._tileWarpIds[dir][index];\r\n        if (warpId === -1) {\r\n            return undefined;\r\n        }\r\n        else {\r\n            return this._warps[warpId];\r\n        }\r\n    }\r\n}\r\nexports.FieldOfViewMap = FieldOfViewMap;\r\n","\"use strict\";\r\n/*\r\n *  WarpField\r\n *  github.com/sbj42/warp-field\r\n *  James Clark\r\n *  Licensed under the MIT license.\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Offset = exports.CardinalDirectionFlags = exports.CardinalDirection = exports.computeFieldOfView = exports.FieldOfViewMap = void 0;\r\nvar field_of_view_map_1 = require(\"./field-of-view-map\");\r\nObject.defineProperty(exports, \"FieldOfViewMap\", { enumerable: true, get: function () { return field_of_view_map_1.FieldOfViewMap; } });\r\nvar compute_1 = require(\"./compute\");\r\nObject.defineProperty(exports, \"computeFieldOfView\", { enumerable: true, get: function () { return compute_1.computeFieldOfView; } });\r\nvar tiled_geometry_1 = require(\"tiled-geometry\");\r\nObject.defineProperty(exports, \"CardinalDirection\", { enumerable: true, get: function () { return tiled_geometry_1.CardinalDirection; } });\r\nObject.defineProperty(exports, \"CardinalDirectionFlags\", { enumerable: true, get: function () { return tiled_geometry_1.CardinalDirectionFlags; } });\r\nObject.defineProperty(exports, \"Offset\", { enumerable: true, get: function () { return tiled_geometry_1.Offset; } });\r\n","\"use strict\";\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n});\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.TileFlags = void 0;\r\nconst geom = __importStar(require(\"tiled-geometry\"));\r\n/**\r\n * These flags determine whether a given tile has walls in any of the cardinal\r\n * directions, and whether there is a \"body\" in the tile.\r\n */\r\nvar TileFlags;\r\n(function (TileFlags) {\r\n    TileFlags[TileFlags[\"NONE\"] = 0] = \"NONE\";\r\n    TileFlags[TileFlags[\"WALL_NORTH\"] = 1] = \"WALL_NORTH\";\r\n    TileFlags[TileFlags[\"WALL_EAST\"] = 2] = \"WALL_EAST\";\r\n    TileFlags[TileFlags[\"WALL_WEST\"] = 8] = \"WALL_WEST\";\r\n    TileFlags[TileFlags[\"WALL_SOUTH\"] = 4] = \"WALL_SOUTH\";\r\n    TileFlags[TileFlags[\"BODY\"] = 1 << geom.CARDINAL_DIRECTIONS.length] = \"BODY\";\r\n})(TileFlags = exports.TileFlags || (exports.TileFlags = {}));\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.WarpDataCache = void 0;\r\nclass WarpDataCache {\r\n    constructor() {\r\n        this._data = {};\r\n    }\r\n    get(map, warpCount, shiftX, shiftY) {\r\n        let wcData = this._data[map.id];\r\n        if (!wcData) {\r\n            this._data[map.id] = wcData = {};\r\n        }\r\n        let mapData = wcData[warpCount];\r\n        if (!mapData) {\r\n            wcData[warpCount] = mapData = {};\r\n        }\r\n        let yData = mapData[shiftY];\r\n        if (!yData) {\r\n            mapData[shiftY] = yData = {};\r\n        }\r\n        let data = yData[shiftX];\r\n        if (data) {\r\n            return data;\r\n        }\r\n        yData[shiftX] = data = {\r\n            map,\r\n            warpCount,\r\n            shiftX,\r\n            shiftY,\r\n        };\r\n        return data;\r\n    }\r\n}\r\nexports.WarpDataCache = WarpDataCache;\r\n","\"use strict\";\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n});\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.mergeWedges = exports.addWarp = exports.addShadow = exports.getBestWedge = exports.initWedges = void 0;\r\nconst constants = __importStar(require(\"./constants\"));\r\nfunction initWedges(warp) {\r\n    return [{\r\n            low: 0,\r\n            high: Number.POSITIVE_INFINITY,\r\n            shadow: false,\r\n            warp,\r\n        }];\r\n}\r\nexports.initWedges = initWedges;\r\nfunction getBestWedge(wedges, low, middle, high) {\r\n    let bestWedge;\r\n    let bestDist = Number.POSITIVE_INFINITY;\r\n    for (const wedge of wedges) {\r\n        if (wedge.low >= high) {\r\n            break;\r\n        }\r\n        if (wedge.high <= low) {\r\n            continue;\r\n        }\r\n        const curDist = Math.max(middle - wedge.high, wedge.low - middle);\r\n        if (!bestWedge || wedgeIsBetter(bestWedge, wedge, bestDist, curDist)) {\r\n            bestWedge = wedge;\r\n            bestDist = curDist;\r\n        }\r\n    }\r\n    // istanbul ignore next\r\n    if (!bestWedge) {\r\n        throw new Error(`[bug] no wedge found`);\r\n    }\r\n    return bestWedge;\r\n}\r\nexports.getBestWedge = getBestWedge;\r\nfunction wedgeIsBetter(target, candidate, targetDist, candidateDist) {\r\n    // prefer visible wedges\r\n    if (target.shadow !== candidate.shadow) {\r\n        return target.shadow;\r\n    }\r\n    // prefer wedges closer to the target\r\n    if (candidateDist > targetDist + constants.PICK_WEDGE_EPSILON) {\r\n        return false;\r\n    }\r\n    if (targetDist > candidateDist + constants.PICK_WEDGE_EPSILON) {\r\n        return true;\r\n    }\r\n    // two wedges are close\r\n    // use the one with the lowest warp count\r\n    if (candidate.warp.warpCount !== target.warp.warpCount) {\r\n        return candidate.warp.warpCount < target.warp.warpCount;\r\n    }\r\n    // they have the same warp count\r\n    // use the one with the lowest map id\r\n    if (candidate.warp.map.id !== target.warp.map.id) {\r\n        return candidate.warp.map.id < target.warp.map.id;\r\n    }\r\n    // they have the same map id\r\n    // arbitrarily pick one based on the offsets\r\n    // at this point it doesn't really matter how we choose but we want to be deterministic\r\n    if (candidate.warp.shiftY !== target.warp.shiftY) {\r\n        return candidate.warp.shiftY < target.warp.shiftY;\r\n    }\r\n    if (candidate.warp.shiftX !== target.warp.shiftX) {\r\n        return candidate.warp.shiftX < target.warp.shiftX;\r\n    }\r\n    return false;\r\n}\r\nfunction addShadow(wedge, low, high) {\r\n    if (wedge.shadow || high <= wedge.low || low >= wedge.high) {\r\n        return [wedge];\r\n    }\r\n    if (low <= wedge.low) {\r\n        if (high >= wedge.high) {\r\n            // wedge is entirely in shadow\r\n            wedge.shadow = true;\r\n            return [wedge];\r\n        }\r\n        else {\r\n            // low part of wedge is in shadow, split it\r\n            const newWedge = Object.assign(Object.assign({}, wedge), { shadow: true, high });\r\n            wedge.low = high;\r\n            return [newWedge, wedge];\r\n        }\r\n    }\r\n    else if (high >= wedge.high) {\r\n        // high part of wedge is in shadow, split it\r\n        const newWedge = Object.assign(Object.assign({}, wedge), { shadow: true, low });\r\n        wedge.high = low;\r\n        return [wedge, newWedge];\r\n    }\r\n    else {\r\n        // middle part of wedge is in shadow, split it\r\n        return [Object.assign(Object.assign({}, wedge), { high: low }), Object.assign(Object.assign({}, wedge), { shadow: true, low, high }), Object.assign(Object.assign({}, wedge), { low: high })];\r\n    }\r\n}\r\nexports.addShadow = addShadow;\r\nfunction addWarp(wedge, warp, low, high) {\r\n    if (wedge.warp === warp || high <= wedge.low || low >= wedge.high) {\r\n        return [wedge];\r\n    }\r\n    if (low <= wedge.low) {\r\n        if (high >= wedge.high) {\r\n            // wedge is entirely in warp\r\n            wedge.warp = warp;\r\n            return [wedge];\r\n        }\r\n        else {\r\n            // low part of wedge is in warp, split it\r\n            const newWedge = Object.assign(Object.assign({}, wedge), { warp, high });\r\n            wedge.low = high;\r\n            return [newWedge, wedge];\r\n        }\r\n    }\r\n    else if (high >= wedge.high) {\r\n        // high part of wedge is in warp, split it\r\n        const newWedge = Object.assign(Object.assign({}, wedge), { warp, low });\r\n        wedge.high = low;\r\n        return [wedge, newWedge];\r\n    }\r\n    else {\r\n        // middle part of wedge is in warp, split it\r\n        return [Object.assign(Object.assign({}, wedge), { high: low }), Object.assign(Object.assign({}, wedge), { warp, low, high }), Object.assign(Object.assign({}, wedge), { low: high })];\r\n    }\r\n}\r\nexports.addWarp = addWarp;\r\nfunction mergeWedges(wedges) {\r\n    // istanbul ignore next\r\n    if (wedges.length === 0) {\r\n        throw new Error(`[bug] no wedges`);\r\n    }\r\n    if (wedges.length === 1) {\r\n        return wedges;\r\n    }\r\n    const ret = [];\r\n    for (const wedge of wedges) {\r\n        if (ret.length === 0 || !wedgesMatch(ret[ret.length - 1], wedge)) {\r\n            ret.push(wedge);\r\n        }\r\n        else {\r\n            ret[ret.length - 1].high = wedge.high;\r\n        }\r\n    }\r\n    return ret;\r\n}\r\nexports.mergeWedges = mergeWedges;\r\nfunction wedgesMatch(a, b) {\r\n    return a.shadow === b.shadow && a.warp === b.warp;\r\n}\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// module exports must be returned from runtime so entry inlining is disabled\n// startup\n// Load entry module and return exports\nreturn __webpack_require__(607);\n"],"sourceRoot":""}