{"version":3,"file":"warp-field-2.0.2.js","mappings":";;;;;;;;;;;AAAa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,2BAA2B,GAAG,8BAA8B,GAAG,iCAAiC,GAAG,sBAAsB,GAAG,oBAAoB,GAAG,YAAY,GAAG,YAAY;AAC9K;AACA;AACA;AACA;AACA,CAAC,0BAA0B,YAAY,KAAK;AAC5C,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA,2BAA2B;;;;;;;;;;;ACrCd;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mDAAmD,GAAG,qDAAqD,GAAG,kDAAkD,GAAG,kDAAkD,GAAG,sCAAsC,GAAG,8BAA8B;AAC/R;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8DAA8D,8BAA8B,KAAK;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA,mDAAmD;;;;;;;;;;;AC7CtC;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,wCAAwC,GAAG,gDAAgD,GAAG,sCAAsC,GAAG,sCAAsC,GAAG,iCAAiC,GAAG,iCAAiC,GAAG,2BAA2B,GAAG,yBAAyB;AAC/S;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oDAAoD,yBAAyB,KAAK;AACnF,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA,wCAAwC;;;;;;;;;;;AC/C3B;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,0CAA0C,GAAG,uDAAuD,GAAG,kCAAkC,GAAG,+BAA+B,GAAG,mCAAmC,GAAG,6BAA6B,GAAG,2BAA2B;AAC/Q,eAAe,mBAAO,CAAC,iEAAQ;AAC/B,eAAe,mBAAO,CAAC,iEAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wDAAwD,2BAA2B,KAAK;AACzF,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA,0CAA0C;;;;;;;;;;;ACtE7B;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mCAAmC,GAAG,4BAA4B,GAAG,0CAA0C,GAAG,2BAA2B,GAAG,6BAA6B,GAAG,4BAA4B,GAAG,sBAAsB,GAAG,oBAAoB;AAC5P;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0CAA0C,oBAAoB,KAAK;AACpE,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA,mCAAmC;;;;;;;;;;;AC/CtB;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gCAAgC,GAAG,wBAAwB,GAAG,sCAAsC,GAAG,yBAAyB,GAAG,2BAA2B,GAAG,yBAAyB,GAAG,kBAAkB,GAAG,iBAAiB;AACnO;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC,iBAAiB,KAAK;AAC3D,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA,gCAAgC;;;;;;;;;;;AC3DnB;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mCAAmC,GAAG,uBAAuB,GAAG,oBAAoB,GAAG,oBAAoB,GAAG,aAAa,GAAG,YAAY;AAC1I;AACA;AACA;AACA;AACA,CAAC,0BAA0B,YAAY,KAAK;AAC5C,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA,mCAAmC;;;;;;;;;;;AChCtB;AACb;AACA;AACA,mCAAmC,oCAAoC,gBAAgB;AACvF,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,aAAa,mBAAO,CAAC,2EAAa;AAClC,aAAa,mBAAO,CAAC,iEAAQ;AAC7B,aAAa,mBAAO,CAAC,6FAAsB;AAC3C,aAAa,mBAAO,CAAC,mFAAiB;AACtC,aAAa,mBAAO,CAAC,yGAA4B;AACjD,aAAa,mBAAO,CAAC,iEAAQ;AAC7B,aAAa,mBAAO,CAAC,iGAAwB;AAC7C,aAAa,mBAAO,CAAC,iEAAQ;;;;;;;;;;;ACnBhB;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mBAAmB,GAAG,0BAA0B,GAAG,4BAA4B,GAAG,kCAAkC,GAAG,mBAAmB,GAAG,sBAAsB,GAAG,qBAAqB,GAAG,oBAAoB,GAAG,aAAa,GAAG,YAAY;AACjP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B,YAAY,KAAK;AAC5C,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA,mBAAmB;;;;;;;;;;;ACnEN;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oBAAoB;AACpB,kBAAkB,mBAAO,CAAC,sEAAY;AACtC,iBAAiB,mBAAO,CAAC,kEAAU;AACnC,oBAAoB,mBAAO,CAAC,wEAAa;AACzC,sBAAsB,mBAAO,CAAC,4EAAe;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uBAAuB;AACzC,iBAAiB,uFAAuF;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,gBAAgB;AAChB;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,SAAS;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA,6BAA6B,YAAY;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,oBAAoB;;;;;;;;;;;AClIP;AACb;AACA;AACA,mCAAmC,oCAAoC,gBAAgB;AACvF,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,aAAa,mBAAO,CAAC,kEAAU;AAC/B,aAAa,mBAAO,CAAC,8DAAQ;AAC7B,aAAa,mBAAO,CAAC,wEAAa;AAClC,aAAa,mBAAO,CAAC,8DAAQ;AAC7B,aAAa,mBAAO,CAAC,kFAAkB;AACvC,aAAa,mBAAO,CAAC,4EAAe;AACpC,aAAa,mBAAO,CAAC,gFAAiB;AACtC,aAAa,mBAAO,CAAC,4FAAuB;;;;;;;;;;;ACnB/B;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB;AACrB,oBAAoB,mBAAO,CAAC,wEAAa;AACzC,eAAe,mBAAO,CAAC,8DAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,qBAAqB,GAAG,mBAAmB,IAAI,WAAW;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,qBAAqB;;;;;;;;;;;ACrFR;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,YAAY;AACZ,eAAe,mBAAO,CAAC,8DAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC,4BAA4B,gBAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,OAAO;AAC5B;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,cAAc;AACnC;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA,YAAY;;;;;;;;;;;ACjGC;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,cAAc;AACd,kBAAkB,mBAAO,CAAC,sEAAY;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO,GAAG,OAAO;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,cAAc;AACjD,uCAAuC,cAAc;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;;;;;;;;;;;ACpGD;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB;AAClB,oBAAoB,mBAAO,CAAC,wEAAa;AACzC;AACA;AACA;AACA;AACA,sDAAsD,cAAc,aAAa,OAAO;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB,wBAAwB,iBAAiB;AACzC;AACA;AACA,4BAA4B,iBAAiB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB,GAAG,kBAAkB,KAAK,MAAM;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iBAAiB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;;;;;;;;;;;ACzFL;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB;AACjB,eAAe,mBAAO,CAAC,8DAAQ;AAC/B,iBAAiB,mBAAO,CAAC,kEAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,WAAW,GAAG,aAAa,EAAE,WAAW,GAAG,YAAY;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gBAAgB;AAChC,kCAAkC,aAAa;AAC/C,qCAAqC,YAAY;AACjD,wBAAwB;AACxB;AACA;AACA;AACA;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;;;;;;;;;;ACxJJ;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,YAAY;AACZ,kBAAkB,mBAAO,CAAC,sEAAY;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,MAAM,GAAG,OAAO;AACzD;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,WAAW,GAAG,YAAY;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,MAAM,GAAG,OAAO;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC,4BAA4B,gBAAgB;AAC5C,wBAAwB;AACxB;AACA;AACA;AACA;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;;;;;;;;;;;ACrFC;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,0BAA0B;AAC1B,oBAAoB,mBAAO,CAAC,wEAAa;AACzC,kBAAkB,mBAAO,CAAC,sEAAY;AACtC,iBAAiB,mBAAO,CAAC,kEAAU;AACnC,eAAe,mBAAO,CAAC,8DAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B,qBAAqB,oCAAoC,EAAE,8CAA8C,EAAE,gBAAgB;AAC3H,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;;;;;;;;;;;ACzPb;AACb;AACA;AACA,mCAAmC,oCAAoC,gBAAgB;AACvF,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,aAAa,mBAAO,CAAC,qEAAW;AAChC,aAAa,mBAAO,CAAC,+DAAQ;;;;;;;;;;;ACbhB;AACb;AACA;AACA,mCAAmC,oCAAoC,gBAAgB;AACvF,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA,0CAA0C,4BAA4B;AACtE,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,0BAA0B;AAC1B,0BAA0B,mBAAO,CAAC,kEAAgB;AAClD,+BAA+B,mBAAO,CAAC,uCAAa;AACpD,gBAAgB,mBAAO,CAAC,+BAAS;AACjC,qBAAqB,mBAAO,CAAC,yCAAc;AAC3C,6BAA6B,mBAAO,CAAC,yDAAsB;AAC3D,oBAAoB,mBAAO,CAAC,uCAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,uBAAuB;AAC5C;AACA,yBAAyB,uBAAuB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AClOa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,0BAA0B,GAAG,mBAAmB,GAAG,mBAAmB,GAAG,kBAAkB;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA,0BAA0B;;;;;;;;;;;AChCb;AACb;AACA;AACA,mCAAmC,oCAAoC,gBAAgB;AACvF,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA,0CAA0C,4BAA4B;AACtE,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uBAAuB;AACvB,0BAA0B,mBAAO,CAAC,kEAAgB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,6CAA6C,4BAA4B;AACzE,iDAAiD,4BAA4B;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;;;;;;;;;;;ACpEV;AACb;AACA;AACA,mCAAmC,oCAAoC,gBAAgB;AACvF,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA,0CAA0C,4BAA4B;AACtE,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,sBAAsB;AACtB,0BAA0B,mBAAO,CAAC,kEAAgB;AAClD,qBAAqB,mBAAO,CAAC,yCAAc;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA,4BAA4B,sBAAsB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,0BAA0B,0BAA0B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;;;;;;;;;;;AC3NT;AACb;AACA;AACA,mCAAmC,oCAAoC,gBAAgB;AACvF,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA,0CAA0C,4BAA4B;AACtE,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB;AACjB,0BAA0B,mBAAO,CAAC,kEAAgB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC,iBAAiB,KAAK;;;;;;;;;;;ACnC9C;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;;;;;;;;;;;ACjCR;AACb;AACA;AACA,mCAAmC,oCAAoC,gBAAgB;AACvF,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA,0CAA0C,4BAA4B;AACtE,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mBAAmB,GAAG,eAAe,GAAG,iBAAiB,GAAG,oBAAoB,GAAG,kBAAkB;AACrG,+BAA+B,mBAAO,CAAC,uCAAa;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,YAAY,oBAAoB;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,YAAY,mBAAmB;AACtF;AACA;AACA;AACA;AACA;AACA,8CAA8C,YAAY,WAAW,iCAAiC,YAAY,yBAAyB,iCAAiC,YAAY,WAAW;AACnM;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,YAAY,YAAY;AACnF;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,YAAY,WAAW;AAC9E;AACA;AACA;AACA;AACA;AACA,8CAA8C,YAAY,WAAW,iCAAiC,YAAY,iBAAiB,iCAAiC,YAAY,WAAW;AAC3L;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;;;;;;;UCxKA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;;;;;;ACtBa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,cAAc,GAAG,8BAA8B,GAAG,yBAAyB,GAAG,0BAA0B,GAAG,sBAAsB;AACjI,0BAA0B,mBAAO,CAAC,uDAAqB;AACvD,kDAAiD,EAAE,qCAAqC,8CAA8C,EAAC;AACvI,gBAAgB,mBAAO,CAAC,mCAAW;AACnC,sDAAqD,EAAE,qCAAqC,wCAAwC,EAAC;AACrI,uBAAuB,mBAAO,CAAC,kEAAgB;AAC/C,qDAAoD,EAAE,qCAAqC,8CAA8C,EAAC;AAC1I,0DAAyD,EAAE,qCAAqC,mDAAmD,EAAC;AACpJ,0CAAyC,EAAE,qCAAqC,mCAAmC,EAAC","sources":["webpack://WarpField/./node_modules/tiled-geometry/lib/compass/axis.js","webpack://WarpField/./node_modules/tiled-geometry/lib/compass/cardinal-direction-flags.js","webpack://WarpField/./node_modules/tiled-geometry/lib/compass/cardinal-direction.js","webpack://WarpField/./node_modules/tiled-geometry/lib/compass/cardinal-orientation.js","webpack://WarpField/./node_modules/tiled-geometry/lib/compass/cardinal-turn.js","webpack://WarpField/./node_modules/tiled-geometry/lib/compass/direction.js","webpack://WarpField/./node_modules/tiled-geometry/lib/compass/flip.js","webpack://WarpField/./node_modules/tiled-geometry/lib/compass/index.js","webpack://WarpField/./node_modules/tiled-geometry/lib/compass/turn.js","webpack://WarpField/./node_modules/tiled-geometry/lib/grid/cardinal-path.js","webpack://WarpField/./node_modules/tiled-geometry/lib/grid/index.js","webpack://WarpField/./node_modules/tiled-geometry/lib/grid/mask-rectangle.js","webpack://WarpField/./node_modules/tiled-geometry/lib/grid/mask.js","webpack://WarpField/./node_modules/tiled-geometry/lib/grid/offset.js","webpack://WarpField/./node_modules/tiled-geometry/lib/grid/raster-mask.js","webpack://WarpField/./node_modules/tiled-geometry/lib/grid/rectangle.js","webpack://WarpField/./node_modules/tiled-geometry/lib/grid/size.js","webpack://WarpField/./node_modules/tiled-geometry/lib/grid/transform-rectangle.js","webpack://WarpField/./node_modules/tiled-geometry/lib/index.js","webpack://WarpField/./src/compute.ts","webpack://WarpField/./src/constants.ts","webpack://WarpField/./src/field-of-view-impl.ts","webpack://WarpField/./src/field-of-view-map.ts","webpack://WarpField/./src/tile-flags.ts","webpack://WarpField/./src/warp-data.ts","webpack://WarpField/./src/wedge.ts","webpack://WarpField/webpack/bootstrap","webpack://WarpField/./src/index.ts"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.axisAddCardinalTurn = exports.axisFromNorthSouthTurn = exports.axisFromCardinalDirection = exports.axisOrthogonal = exports.axisToString = exports.AXES = exports.Axis = void 0;\r\nvar Axis;\r\n(function (Axis) {\r\n    Axis[Axis[\"NORTH_SOUTH\"] = 0] = \"NORTH_SOUTH\";\r\n    Axis[Axis[\"WEST_EAST\"] = 1] = \"WEST_EAST\";\r\n})(Axis = exports.Axis || (exports.Axis = {}));\r\nexports.AXES = [\r\n    Axis.NORTH_SOUTH,\r\n    Axis.WEST_EAST,\r\n];\r\nconst AXES_STR = [\r\n    'N-S',\r\n    'W-E',\r\n];\r\nfunction axisToString(axis) {\r\n    return AXES_STR[axis];\r\n}\r\nexports.axisToString = axisToString;\r\nfunction axisOrthogonal(axis) {\r\n    return (axis ^ 1);\r\n}\r\nexports.axisOrthogonal = axisOrthogonal;\r\n// conversion\r\nfunction axisFromCardinalDirection(dir) {\r\n    return (dir & 1);\r\n}\r\nexports.axisFromCardinalDirection = axisFromCardinalDirection;\r\nfunction axisFromNorthSouthTurn(turn) {\r\n    return (turn & 1);\r\n}\r\nexports.axisFromNorthSouthTurn = axisFromNorthSouthTurn;\r\n// math\r\nfunction axisAddCardinalTurn(axis, turn) {\r\n    return ((axis + turn) & 1);\r\n}\r\nexports.axisAddCardinalTurn = axisAddCardinalTurn;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.cardinalDirectionFlagsFromCardinalDirection = exports.cardinalDirectionFlagsRemoveCardinalDirection = exports.cardinalDirectionFlagsSetCardinalDirection = exports.cardinalDirectionFlagsHasCardinalDirection = exports.cardinalDirectionFlagsToString = exports.CardinalDirectionFlags = void 0;\r\nvar CardinalDirectionFlags;\r\n(function (CardinalDirectionFlags) {\r\n    CardinalDirectionFlags[CardinalDirectionFlags[\"NONE\"] = 0] = \"NONE\";\r\n    CardinalDirectionFlags[CardinalDirectionFlags[\"NORTH\"] = 1] = \"NORTH\";\r\n    CardinalDirectionFlags[CardinalDirectionFlags[\"EAST\"] = 2] = \"EAST\";\r\n    CardinalDirectionFlags[CardinalDirectionFlags[\"SOUTH\"] = 4] = \"SOUTH\";\r\n    CardinalDirectionFlags[CardinalDirectionFlags[\"WEST\"] = 8] = \"WEST\";\r\n    CardinalDirectionFlags[CardinalDirectionFlags[\"ALL\"] = 15] = \"ALL\";\r\n})(CardinalDirectionFlags = exports.CardinalDirectionFlags || (exports.CardinalDirectionFlags = {}));\r\nfunction cardinalDirectionFlagsToString(flags) {\r\n    let ret = '[';\r\n    if ((flags & CardinalDirectionFlags.NORTH) !== 0) {\r\n        ret += 'N';\r\n    }\r\n    if ((flags & CardinalDirectionFlags.EAST) !== 0) {\r\n        ret += 'E';\r\n    }\r\n    if ((flags & CardinalDirectionFlags.SOUTH) !== 0) {\r\n        ret += 'S';\r\n    }\r\n    if ((flags & CardinalDirectionFlags.WEST) !== 0) {\r\n        ret += 'W';\r\n    }\r\n    return ret + ']';\r\n}\r\nexports.cardinalDirectionFlagsToString = cardinalDirectionFlagsToString;\r\nfunction cardinalDirectionFlagsHasCardinalDirection(flags, dir) {\r\n    return (flags & cardinalDirectionFlagsFromCardinalDirection(dir)) !== 0;\r\n}\r\nexports.cardinalDirectionFlagsHasCardinalDirection = cardinalDirectionFlagsHasCardinalDirection;\r\nfunction cardinalDirectionFlagsSetCardinalDirection(flags, dir) {\r\n    return (flags | cardinalDirectionFlagsFromCardinalDirection(dir));\r\n}\r\nexports.cardinalDirectionFlagsSetCardinalDirection = cardinalDirectionFlagsSetCardinalDirection;\r\nfunction cardinalDirectionFlagsRemoveCardinalDirection(flags, dir) {\r\n    return (flags & ~cardinalDirectionFlagsFromCardinalDirection(dir));\r\n}\r\nexports.cardinalDirectionFlagsRemoveCardinalDirection = cardinalDirectionFlagsRemoveCardinalDirection;\r\n// conversion\r\nfunction cardinalDirectionFlagsFromCardinalDirection(dir) {\r\n    return (1 << dir);\r\n}\r\nexports.cardinalDirectionFlagsFromCardinalDirection = cardinalDirectionFlagsFromCardinalDirection;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.cardinalDirectionAddCardinalTurn = exports.cardinalDirectionFromCardinalOrientation = exports.cardinalDirectionFromNorthTurn = exports.cardinalDirectionFromDirection = exports.cardinalDirectionOpposite = exports.cardinalDirectionToString = exports.CARDINAL_DIRECTIONS = exports.CardinalDirection = void 0;\r\nvar CardinalDirection;\r\n(function (CardinalDirection) {\r\n    CardinalDirection[CardinalDirection[\"NORTH\"] = 0] = \"NORTH\";\r\n    CardinalDirection[CardinalDirection[\"EAST\"] = 1] = \"EAST\";\r\n    CardinalDirection[CardinalDirection[\"SOUTH\"] = 2] = \"SOUTH\";\r\n    CardinalDirection[CardinalDirection[\"WEST\"] = 3] = \"WEST\";\r\n})(CardinalDirection = exports.CardinalDirection || (exports.CardinalDirection = {}));\r\nexports.CARDINAL_DIRECTIONS = [\r\n    CardinalDirection.NORTH,\r\n    CardinalDirection.EAST,\r\n    CardinalDirection.SOUTH,\r\n    CardinalDirection.WEST,\r\n];\r\nconst CARDINAL_DIRECTIONS_STR = [\r\n    'N',\r\n    'E',\r\n    'S',\r\n    'W',\r\n];\r\nfunction cardinalDirectionToString(dir) {\r\n    return CARDINAL_DIRECTIONS_STR[dir];\r\n}\r\nexports.cardinalDirectionToString = cardinalDirectionToString;\r\nfunction cardinalDirectionOpposite(dir) {\r\n    return ((dir + 2) & 3);\r\n}\r\nexports.cardinalDirectionOpposite = cardinalDirectionOpposite;\r\n// conversion\r\nfunction cardinalDirectionFromDirection(dir) {\r\n    return (dir >> 1);\r\n}\r\nexports.cardinalDirectionFromDirection = cardinalDirectionFromDirection;\r\nfunction cardinalDirectionFromNorthTurn(turn) {\r\n    return turn;\r\n}\r\nexports.cardinalDirectionFromNorthTurn = cardinalDirectionFromNorthTurn;\r\nfunction cardinalDirectionFromCardinalOrientation(orientation) {\r\n    return (orientation >>> 1);\r\n}\r\nexports.cardinalDirectionFromCardinalOrientation = cardinalDirectionFromCardinalOrientation;\r\n// math\r\nfunction cardinalDirectionAddCardinalTurn(dir, turn) {\r\n    return ((dir + turn) & 3);\r\n}\r\nexports.cardinalDirectionAddCardinalTurn = cardinalDirectionAddCardinalTurn;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.cardinalOrientationAddCardinalTurn = exports.cardinalOrientationFromFlipAndCardinalDirection = exports.cardinalOrientationReverse = exports.cardinalOrientationFlip = exports.cardinalOrientationToString = exports.CARDINAL_ORIENTATIONS = exports.CardinalOrientation = void 0;\r\nconst axis_1 = require(\"./axis\");\r\nconst flip_1 = require(\"./flip\");\r\nvar CardinalOrientation;\r\n(function (CardinalOrientation) {\r\n    CardinalOrientation[CardinalOrientation[\"HEADS_NORTH\"] = 0] = \"HEADS_NORTH\";\r\n    CardinalOrientation[CardinalOrientation[\"TAILS_NORTH\"] = 1] = \"TAILS_NORTH\";\r\n    CardinalOrientation[CardinalOrientation[\"HEADS_EAST\"] = 2] = \"HEADS_EAST\";\r\n    CardinalOrientation[CardinalOrientation[\"TAILS_EAST\"] = 3] = \"TAILS_EAST\";\r\n    CardinalOrientation[CardinalOrientation[\"HEADS_SOUTH\"] = 4] = \"HEADS_SOUTH\";\r\n    CardinalOrientation[CardinalOrientation[\"TAILS_SOUTH\"] = 5] = \"TAILS_SOUTH\";\r\n    CardinalOrientation[CardinalOrientation[\"HEADS_WEST\"] = 6] = \"HEADS_WEST\";\r\n    CardinalOrientation[CardinalOrientation[\"TAILS_WEST\"] = 7] = \"TAILS_WEST\";\r\n})(CardinalOrientation = exports.CardinalOrientation || (exports.CardinalOrientation = {}));\r\nexports.CARDINAL_ORIENTATIONS = [\r\n    CardinalOrientation.HEADS_NORTH,\r\n    CardinalOrientation.TAILS_NORTH,\r\n    CardinalOrientation.HEADS_EAST,\r\n    CardinalOrientation.TAILS_EAST,\r\n    CardinalOrientation.HEADS_SOUTH,\r\n    CardinalOrientation.TAILS_SOUTH,\r\n    CardinalOrientation.HEADS_WEST,\r\n    CardinalOrientation.TAILS_WEST,\r\n];\r\nconst CARDINAL_ORIENTATIONS_STR = [\r\n    'HN',\r\n    'TN',\r\n    'HE',\r\n    'TE',\r\n    'HS',\r\n    'TS',\r\n    'HW',\r\n    'TW',\r\n];\r\nfunction cardinalOrientationToString(orientation) {\r\n    return CARDINAL_ORIENTATIONS_STR[orientation];\r\n}\r\nexports.cardinalOrientationToString = cardinalOrientationToString;\r\nfunction cardinalOrientationFlip(orientation, axis) {\r\n    if (axis === axis_1.Axis.NORTH_SOUTH) {\r\n        return ((9 - orientation) & 7);\r\n    }\r\n    else {\r\n        return ((13 - orientation) & 7);\r\n    }\r\n}\r\nexports.cardinalOrientationFlip = cardinalOrientationFlip;\r\nfunction cardinalOrientationReverse(orientation) {\r\n    if (orientation === CardinalOrientation.HEADS_EAST) {\r\n        return CardinalOrientation.HEADS_WEST;\r\n    }\r\n    else if (orientation === CardinalOrientation.HEADS_WEST) {\r\n        return CardinalOrientation.HEADS_EAST;\r\n    }\r\n    else {\r\n        return orientation;\r\n    }\r\n}\r\nexports.cardinalOrientationReverse = cardinalOrientationReverse;\r\n// conversion\r\nfunction cardinalOrientationFromFlipAndCardinalDirection(flip, dir) {\r\n    return (dir * 2 + (flip !== flip_1.Flip.HEADS ? 1 : 0));\r\n}\r\nexports.cardinalOrientationFromFlipAndCardinalDirection = cardinalOrientationFromFlipAndCardinalDirection;\r\n// math\r\nfunction cardinalOrientationAddCardinalTurn(orientation, turn) {\r\n    return ((orientation + turn * 2) & 7);\r\n}\r\nexports.cardinalOrientationAddCardinalTurn = cardinalOrientationAddCardinalTurn;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.cardinalTurnAddCardinalTurn = exports.cardinalTurnFromTurn = exports.cardinalTurnFromCardinalDirections = exports.cardinalTurnReverse = exports.cardinalTurnToDegrees = exports.cardinalTurnToString = exports.CARDINAL_TURNS = exports.CardinalTurn = void 0;\r\nvar CardinalTurn;\r\n(function (CardinalTurn) {\r\n    CardinalTurn[CardinalTurn[\"NONE\"] = 0] = \"NONE\";\r\n    CardinalTurn[CardinalTurn[\"RIGHT\"] = 1] = \"RIGHT\";\r\n    CardinalTurn[CardinalTurn[\"AROUND\"] = 2] = \"AROUND\";\r\n    CardinalTurn[CardinalTurn[\"LEFT\"] = 3] = \"LEFT\";\r\n})(CardinalTurn = exports.CardinalTurn || (exports.CardinalTurn = {}));\r\nexports.CARDINAL_TURNS = [\r\n    CardinalTurn.NONE,\r\n    CardinalTurn.RIGHT,\r\n    CardinalTurn.AROUND,\r\n    CardinalTurn.LEFT,\r\n];\r\nconst CARDINAL_TURNS_STR = [\r\n    'T0',\r\n    'T+90',\r\n    'T180',\r\n    'T-90',\r\n];\r\nfunction cardinalTurnToString(dir) {\r\n    return CARDINAL_TURNS_STR[dir];\r\n}\r\nexports.cardinalTurnToString = cardinalTurnToString;\r\nfunction cardinalTurnToDegrees(turn) {\r\n    return turn * 90;\r\n}\r\nexports.cardinalTurnToDegrees = cardinalTurnToDegrees;\r\nfunction cardinalTurnReverse(dir) {\r\n    return ((4 - dir) & 3);\r\n}\r\nexports.cardinalTurnReverse = cardinalTurnReverse;\r\n// conversion\r\nfunction cardinalTurnFromCardinalDirections(from, to) {\r\n    return ((to - from) & 3);\r\n}\r\nexports.cardinalTurnFromCardinalDirections = cardinalTurnFromCardinalDirections;\r\nfunction cardinalTurnFromTurn(turn) {\r\n    return (turn >> 1);\r\n}\r\nexports.cardinalTurnFromTurn = cardinalTurnFromTurn;\r\n// math\r\nfunction cardinalTurnAddCardinalTurn(turn1, turn2) {\r\n    return ((turn1 + turn2) & 3);\r\n}\r\nexports.cardinalTurnAddCardinalTurn = cardinalTurnAddCardinalTurn;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.directionAddCardinalTurn = exports.directionAddTurn = exports.directionFromCardinalDirection = exports.directionOpposite = exports.directionIsCardinal = exports.directionToString = exports.DIRECTIONS = exports.Direction = void 0;\r\nvar Direction;\r\n(function (Direction) {\r\n    Direction[Direction[\"NORTH\"] = 0] = \"NORTH\";\r\n    Direction[Direction[\"NORTHEAST\"] = 1] = \"NORTHEAST\";\r\n    Direction[Direction[\"EAST\"] = 2] = \"EAST\";\r\n    Direction[Direction[\"SOUTHEAST\"] = 3] = \"SOUTHEAST\";\r\n    Direction[Direction[\"SOUTH\"] = 4] = \"SOUTH\";\r\n    Direction[Direction[\"SOUTHWEST\"] = 5] = \"SOUTHWEST\";\r\n    Direction[Direction[\"WEST\"] = 6] = \"WEST\";\r\n    Direction[Direction[\"NORTHWEST\"] = 7] = \"NORTHWEST\";\r\n})(Direction = exports.Direction || (exports.Direction = {}));\r\nexports.DIRECTIONS = [\r\n    Direction.NORTH,\r\n    Direction.NORTHEAST,\r\n    Direction.EAST,\r\n    Direction.SOUTHEAST,\r\n    Direction.SOUTH,\r\n    Direction.SOUTHWEST,\r\n    Direction.WEST,\r\n    Direction.NORTHWEST,\r\n];\r\nconst DIRECTIONS_STR = [\r\n    'N',\r\n    'NE',\r\n    'E',\r\n    'SE',\r\n    'S',\r\n    'SW',\r\n    'W',\r\n    'NW',\r\n];\r\nfunction directionToString(dir) {\r\n    return DIRECTIONS_STR[dir];\r\n}\r\nexports.directionToString = directionToString;\r\nfunction directionIsCardinal(dir) {\r\n    return (dir & 1) === 0;\r\n}\r\nexports.directionIsCardinal = directionIsCardinal;\r\nfunction directionOpposite(dir) {\r\n    return ((dir + 4) & 7);\r\n}\r\nexports.directionOpposite = directionOpposite;\r\n// conversion\r\nfunction directionFromCardinalDirection(dir) {\r\n    return (dir << 1);\r\n}\r\nexports.directionFromCardinalDirection = directionFromCardinalDirection;\r\n// math\r\nfunction directionAddTurn(dir, turn) {\r\n    return ((dir + turn) & 7);\r\n}\r\nexports.directionAddTurn = directionAddTurn;\r\nfunction directionAddCardinalTurn(dir, turn) {\r\n    return ((dir + turn * 2) & 7);\r\n}\r\nexports.directionAddCardinalTurn = directionAddCardinalTurn;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.flipFromCardinalOrientation = exports.flipFromBoolean = exports.flipOpposite = exports.flipToString = exports.FLIPS = exports.Flip = void 0;\r\nvar Flip;\r\n(function (Flip) {\r\n    Flip[Flip[\"HEADS\"] = 0] = \"HEADS\";\r\n    Flip[Flip[\"TAILS\"] = 1] = \"TAILS\";\r\n})(Flip = exports.Flip || (exports.Flip = {}));\r\nexports.FLIPS = [\r\n    Flip.HEADS,\r\n    Flip.TAILS,\r\n];\r\nconst FLIPS_STR = [\r\n    'H',\r\n    'T',\r\n];\r\nfunction flipToString(flip) {\r\n    return FLIPS_STR[flip];\r\n}\r\nexports.flipToString = flipToString;\r\nfunction flipOpposite(flip) {\r\n    return (flip ^ 1);\r\n}\r\nexports.flipOpposite = flipOpposite;\r\n// conversion\r\nfunction flipFromBoolean(tails) {\r\n    return tails ? Flip.TAILS : Flip.HEADS;\r\n}\r\nexports.flipFromBoolean = flipFromBoolean;\r\nfunction flipFromCardinalOrientation(orientation) {\r\n    return (orientation & 1);\r\n}\r\nexports.flipFromCardinalOrientation = flipFromCardinalOrientation;\r\n","\"use strict\";\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n__exportStar(require(\"./direction\"), exports);\r\n__exportStar(require(\"./turn\"), exports);\r\n__exportStar(require(\"./cardinal-direction\"), exports);\r\n__exportStar(require(\"./cardinal-turn\"), exports);\r\n__exportStar(require(\"./cardinal-direction-flags\"), exports);\r\n__exportStar(require(\"./flip\"), exports);\r\n__exportStar(require(\"./cardinal-orientation\"), exports);\r\n__exportStar(require(\"./axis\"), exports);\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.turnAddTurn = exports.turnFromDirections = exports.turnFromCardinalTurn = exports.turnFromCardinalDirections = exports.turnReverse = exports.turnIsCardinal = exports.turnToDegrees = exports.turnToString = exports.TURNS = exports.Turn = void 0;\r\nvar Turn;\r\n(function (Turn) {\r\n    Turn[Turn[\"NONE\"] = 0] = \"NONE\";\r\n    Turn[Turn[\"R_45\"] = 1] = \"R_45\";\r\n    Turn[Turn[\"R_90\"] = 2] = \"R_90\";\r\n    Turn[Turn[\"R_135\"] = 3] = \"R_135\";\r\n    Turn[Turn[\"T_180\"] = 4] = \"T_180\";\r\n    Turn[Turn[\"L_135\"] = 5] = \"L_135\";\r\n    Turn[Turn[\"L_90\"] = 6] = \"L_90\";\r\n    Turn[Turn[\"L_45\"] = 7] = \"L_45\";\r\n})(Turn = exports.Turn || (exports.Turn = {}));\r\nexports.TURNS = [\r\n    Turn.NONE,\r\n    Turn.R_45,\r\n    Turn.R_90,\r\n    Turn.R_135,\r\n    Turn.T_180,\r\n    Turn.L_135,\r\n    Turn.L_90,\r\n    Turn.L_45,\r\n];\r\nconst TURNS_STR = [\r\n    'T0',\r\n    'T+45',\r\n    'T+90',\r\n    'T+135',\r\n    'T180',\r\n    'T-135',\r\n    'T-90',\r\n    'T-45',\r\n];\r\nfunction turnToString(turn) {\r\n    return TURNS_STR[turn];\r\n}\r\nexports.turnToString = turnToString;\r\nfunction turnToDegrees(turn) {\r\n    return turn * 45;\r\n}\r\nexports.turnToDegrees = turnToDegrees;\r\nfunction turnIsCardinal(turn) {\r\n    return (turn & 1) === 0;\r\n}\r\nexports.turnIsCardinal = turnIsCardinal;\r\nfunction turnReverse(turn) {\r\n    return ((8 - turn) & 7);\r\n}\r\nexports.turnReverse = turnReverse;\r\n// conversion\r\nfunction turnFromCardinalDirections(from, to) {\r\n    return (((to - from) * 2) & 7);\r\n}\r\nexports.turnFromCardinalDirections = turnFromCardinalDirections;\r\nfunction turnFromCardinalTurn(turn) {\r\n    return (turn << 1);\r\n}\r\nexports.turnFromCardinalTurn = turnFromCardinalTurn;\r\nfunction turnFromDirections(from, to) {\r\n    return ((to - from) & 7);\r\n}\r\nexports.turnFromDirections = turnFromDirections;\r\n// math\r\nfunction turnAddTurn(turn1, turn2) {\r\n    return ((turn1 + turn2) & 7);\r\n}\r\nexports.turnAddTurn = turnAddTurn;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.CardinalPath = void 0;\r\nconst compass_1 = require(\"../compass\");\r\nconst offset_1 = require(\"./offset\");\r\nconst rectangle_1 = require(\"./rectangle\");\r\nconst raster_mask_1 = require(\"./raster-mask\");\r\nconst LOCAL_OFF = new offset_1.Offset();\r\nfunction sortedInsert(array, value) {\r\n    array.push(value);\r\n    let i = array.length - 1;\r\n    while (i > 0 && value < array[i - 1]) {\r\n        array[i] = array[i - 1];\r\n        i--;\r\n    }\r\n    array[i] = value;\r\n}\r\nclass CardinalPath {\r\n    constructor(start, segments) {\r\n        this._start = new offset_1.Offset();\r\n        this._start.copyFrom(start);\r\n        this._segments = segments;\r\n    }\r\n    // accessors\r\n    toString() {\r\n        return `${this._start.toString()}:`\r\n            + `${this._segments.map((segment) => compass_1.cardinalDirectionToString(segment)).join('')}`;\r\n    }\r\n    equals(other) {\r\n        return this._start.equals(other._start)\r\n            && this._segments.length === other._segments.length\r\n            && this._segments.every((v, i) => v === other._segments[i]);\r\n    }\r\n    get length() {\r\n        return this._segments.length;\r\n    }\r\n    // utilities\r\n    getIsClosed() {\r\n        LOCAL_OFF.copyFrom(this._start);\r\n        for (const segment of this._segments) {\r\n            LOCAL_OFF.addCardinalDirection(segment);\r\n        }\r\n        return this._start.equals(LOCAL_OFF);\r\n    }\r\n    *offsets() {\r\n        let { x, y } = this._start;\r\n        yield { x, y };\r\n        for (const segment of this._segments) {\r\n            LOCAL_OFF.setFromCardinalDirection(segment);\r\n            x += LOCAL_OFF.x;\r\n            y += LOCAL_OFF.y;\r\n            yield { x, y };\r\n        }\r\n    }\r\n    getBounds() {\r\n        let northY = this._start.y;\r\n        let southY = northY;\r\n        let westX = this._start.x;\r\n        let eastX = westX;\r\n        LOCAL_OFF.copyFrom(this._start);\r\n        for (const segment of this._segments) {\r\n            LOCAL_OFF.addCardinalDirection(segment);\r\n            switch (segment) {\r\n                case compass_1.CardinalDirection.NORTH:\r\n                    northY = Math.min(northY, LOCAL_OFF.y);\r\n                    break;\r\n                case compass_1.CardinalDirection.EAST:\r\n                    eastX = Math.max(eastX, LOCAL_OFF.x);\r\n                    break;\r\n                case compass_1.CardinalDirection.SOUTH:\r\n                    southY = Math.max(southY, LOCAL_OFF.y);\r\n                    break;\r\n                case compass_1.CardinalDirection.WEST:\r\n                    westX = Math.min(westX, LOCAL_OFF.x);\r\n                    break;\r\n                // istanbul ignore next\r\n                default:\r\n                    throw new Error(`bad direction ${segment} in cardinal path`);\r\n            }\r\n        }\r\n        return new rectangle_1.Rectangle(westX, northY, eastX - westX + 1, southY - northY + 1);\r\n    }\r\n    getArea() {\r\n        let total = 0;\r\n        LOCAL_OFF.copyFrom(this._start);\r\n        for (const segment of this._segments) {\r\n            LOCAL_OFF.addCardinalDirection(segment);\r\n            switch (segment) {\r\n                case compass_1.CardinalDirection.NORTH:\r\n                    total -= LOCAL_OFF.x;\r\n                    break;\r\n                case compass_1.CardinalDirection.SOUTH:\r\n                    total += LOCAL_OFF.x;\r\n                    break;\r\n            }\r\n        }\r\n        return Math.abs(total);\r\n    }\r\n    rasterize(bounds) {\r\n        const lines = new Array();\r\n        if (typeof bounds === 'undefined') {\r\n            bounds = this.getBounds();\r\n        }\r\n        // assert(this.getIsClosed())\r\n        LOCAL_OFF.copyFrom(this._start);\r\n        const { northY } = bounds;\r\n        const southY = northY + bounds.height - 1;\r\n        for (let y = northY; y < southY; y++) {\r\n            lines.push([]);\r\n        }\r\n        LOCAL_OFF.copyFrom(this._start);\r\n        // assert(LOCAL_OFF.y >= northY && LOCAL_OFF.y <= southY)\r\n        for (const segment of this._segments) {\r\n            if (segment === compass_1.CardinalDirection.SOUTH) {\r\n                sortedInsert(lines[LOCAL_OFF.y - northY], LOCAL_OFF.x);\r\n            }\r\n            LOCAL_OFF.addCardinalDirection(segment);\r\n            // assert(LOCAL_OFF.y >= northY && LOCAL_OFF.y <= southY)\r\n            if (segment === compass_1.CardinalDirection.NORTH) {\r\n                sortedInsert(lines[LOCAL_OFF.y - northY], LOCAL_OFF.x);\r\n            }\r\n        }\r\n        return new raster_mask_1.RasterMask({\r\n            westX: bounds.westX,\r\n            northY: bounds.northY,\r\n            width: bounds.width - 1,\r\n            height: bounds.height - 1,\r\n        }, lines);\r\n    }\r\n}\r\nexports.CardinalPath = CardinalPath;\r\n","\"use strict\";\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n__exportStar(require(\"./offset\"), exports);\r\n__exportStar(require(\"./size\"), exports);\r\n__exportStar(require(\"./rectangle\"), exports);\r\n__exportStar(require(\"./mask\"), exports);\r\n__exportStar(require(\"./mask-rectangle\"), exports);\r\n__exportStar(require(\"./raster-mask\"), exports);\r\n__exportStar(require(\"./cardinal-path\"), exports);\r\n__exportStar(require(\"./transform-rectangle\"), exports);\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.MaskRectangle = void 0;\r\nconst rectangle_1 = require(\"./rectangle\");\r\nconst mask_1 = require(\"./mask\");\r\nclass MaskRectangle {\r\n    constructor(rect, initialValue = false, outsideValue = false) {\r\n        this._rect = new rectangle_1.Rectangle();\r\n        if (typeof rect !== 'undefined') {\r\n            this._rect.copyFrom(rect);\r\n        }\r\n        this._mask = new mask_1.Mask(rect, initialValue);\r\n        this._outsideValue = outsideValue;\r\n    }\r\n    // accessors\r\n    toString() {\r\n        return `${this._rect.northWest}/${this._outsideValue}\\n${this._mask}`;\r\n    }\r\n    equals(other) {\r\n        return this._rect.equals(other._rect)\r\n            && this._mask.equals(other._mask)\r\n            && this._outsideValue === other._outsideValue;\r\n    }\r\n    get westX() {\r\n        return this._rect.westX;\r\n    }\r\n    get northY() {\r\n        return this._rect.northY;\r\n    }\r\n    get width() {\r\n        return this._rect.width;\r\n    }\r\n    get height() {\r\n        return this._rect.height;\r\n    }\r\n    get(x, y) {\r\n        if (!this._rect.contains(x, y)) {\r\n            return this._outsideValue;\r\n        }\r\n        return this._mask.get(x - this.westX, y - this.northY);\r\n    }\r\n    getAtIndex(index) {\r\n        return this._mask.getAtIndex(index);\r\n    }\r\n    getAtOffset(off) {\r\n        return this.get(off.x, off.y);\r\n    }\r\n    // mutators\r\n    copyFrom(other) {\r\n        this._rect.copyFrom(other._rect);\r\n        this._mask.copyFrom(other._mask);\r\n        this._outsideValue = other._outsideValue;\r\n        return this;\r\n    }\r\n    set(x, y, value) {\r\n        this._mask.set(x - this.westX, y - this.northY, value);\r\n        return this;\r\n    }\r\n    setAtOffset(off, value) {\r\n        return this.set(off.x, off.y, value);\r\n    }\r\n    setAtIndex(index, value) {\r\n        this._mask.setAtIndex(index, value);\r\n        return this;\r\n    }\r\n    // utilities\r\n    index(x, y) {\r\n        return this._mask.index(x - this.westX, y - this.northY);\r\n    }\r\n    *locations() {\r\n        for (const loc of this._mask.locations()) {\r\n            const x = loc.x + this.westX;\r\n            const y = loc.y + this.northY;\r\n            const { value } = loc;\r\n            yield { x, y, value };\r\n        }\r\n    }\r\n    *offsetsWithTrue() {\r\n        for (const off of this._mask.offsetsWithTrue()) {\r\n            const x = off.x + this.westX;\r\n            const y = off.y + this.northY;\r\n            yield { x, y };\r\n        }\r\n    }\r\n}\r\nexports.MaskRectangle = MaskRectangle;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Mask = void 0;\r\nconst size_1 = require(\"./size\");\r\nclass Mask {\r\n    constructor(size, initialValue = false) {\r\n        this._size = new size_1.Size();\r\n        if (typeof size !== 'undefined') {\r\n            this._size.copyFrom(size);\r\n        }\r\n        this._bits = new Array(Math.ceil(this._size.area / 32)).fill(initialValue ? 0xffffffff : 0);\r\n    }\r\n    // accessors\r\n    toString() {\r\n        let ret = '';\r\n        for (let y = 0; y < this.height; y++) {\r\n            for (let x = 0; x < this.width; x++) {\r\n                ret += this.get(x, y) ? '☑' : '☐';\r\n            }\r\n            ret += '\\n';\r\n        }\r\n        return ret;\r\n    }\r\n    equals(other) {\r\n        return this._size.equals(other._size)\r\n            && this._bits.length === other._bits.length\r\n            && this._bits.every((v, i) => v === other._bits[i]);\r\n    }\r\n    get width() {\r\n        return this._size.width;\r\n    }\r\n    get height() {\r\n        return this._size.height;\r\n    }\r\n    get(x, y) {\r\n        return this.getAtIndex(this.index(x, y));\r\n    }\r\n    getAtOffset(off) {\r\n        return this.get(off.x, off.y);\r\n    }\r\n    getAtIndex(index) {\r\n        // assert(index >= 0 && index < this._size.area)\r\n        const arrayIndex = index >>> 5;\r\n        const bitMask = 1 << (index & 31);\r\n        return (this._bits[arrayIndex] & bitMask) !== 0;\r\n    }\r\n    // mutators\r\n    copyFrom(other) {\r\n        this._size.copyFrom(other._size);\r\n        this._bits = other._bits.slice();\r\n        return this;\r\n    }\r\n    set(x, y, value) {\r\n        return this.setAtIndex(this.index(x, y), value);\r\n    }\r\n    setAtOffset(off, value) {\r\n        return this.set(off.x, off.y, value);\r\n    }\r\n    setAtIndex(index, value) {\r\n        // assert(index >= 0 && index < this._size.area)\r\n        const arrayIndex = index >>> 5;\r\n        const bitMask = 1 << (index & 31);\r\n        if (value) {\r\n            this._bits[arrayIndex] |= bitMask;\r\n        }\r\n        else {\r\n            this._bits[arrayIndex] &= ~bitMask;\r\n        }\r\n        return this;\r\n    }\r\n    // utilities\r\n    index(x, y) {\r\n        return this._size.index(x, y);\r\n    }\r\n    *locations() {\r\n        let arrayIndex = 0;\r\n        let bitMask = 1;\r\n        for (const { x, y } of this._size.offsets()) {\r\n            const value = (this._bits[arrayIndex] & bitMask) !== 0;\r\n            yield { x, y, value };\r\n            if (bitMask === (1 << 31)) {\r\n                bitMask = 1;\r\n                arrayIndex++;\r\n            }\r\n            else {\r\n                bitMask <<= 1;\r\n            }\r\n        }\r\n    }\r\n    *offsetsWithTrue() {\r\n        for (const { x, y, value } of this.locations()) {\r\n            if (value) {\r\n                yield { x, y };\r\n            }\r\n        }\r\n    }\r\n}\r\nexports.Mask = Mask;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Offset = void 0;\r\nconst compass_1 = require(\"../compass\");\r\nconst X_FROM_DIRECTION = [0, 1, 1, 1, 0, -1, -1, -1];\r\nconst Y_FROM_DIRECTION = [-1, -1, 0, 1, 1, 1, 0, -1];\r\nconst X_FROM_CARDINAL_DIRECTION = [0, 1, 0, -1];\r\nconst Y_FROM_CARDINAL_DIRECTION = [-1, 0, 1, 0];\r\nclass Offset {\r\n    constructor(x, y) {\r\n        if (typeof x === 'undefined') {\r\n            x = 0;\r\n        }\r\n        if (typeof y === 'undefined') {\r\n            y = 0;\r\n        }\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n    // accessors\r\n    toString() {\r\n        return `(${this.x},${this.y})`;\r\n    }\r\n    equals(other) {\r\n        return this.x === other.x && this.y === other.y;\r\n    }\r\n    // mutators\r\n    set(x, y) {\r\n        this.x = x;\r\n        this.y = y;\r\n        return this;\r\n    }\r\n    copyFrom(other) {\r\n        return this.set(other.x, other.y);\r\n    }\r\n    setFromDirection(dir) {\r\n        return this.set(X_FROM_DIRECTION[dir], Y_FROM_DIRECTION[dir]);\r\n    }\r\n    setFromCardinalDirection(dir) {\r\n        return this.set(X_FROM_CARDINAL_DIRECTION[dir], Y_FROM_CARDINAL_DIRECTION[dir]);\r\n    }\r\n    add(x, y) {\r\n        this.x += x;\r\n        this.y += y;\r\n        return this;\r\n    }\r\n    addSize(size) {\r\n        return this.add(size.width, size.height);\r\n    }\r\n    addOffset(off) {\r\n        return this.add(off.x, off.y);\r\n    }\r\n    addDirection(dir) {\r\n        return this.add(X_FROM_DIRECTION[dir], Y_FROM_DIRECTION[dir]);\r\n    }\r\n    addCardinalDirection(dir) {\r\n        return this.add(X_FROM_CARDINAL_DIRECTION[dir], Y_FROM_CARDINAL_DIRECTION[dir]);\r\n    }\r\n    subtractOffset(off) {\r\n        return this.add(-off.x, -off.y);\r\n    }\r\n    multiply(factor) {\r\n        this.x *= factor;\r\n        this.y *= factor;\r\n        return this;\r\n    }\r\n    rotate(turn, anchor) {\r\n        if (anchor) {\r\n            return this.subtractOffset(anchor).rotate(turn).addOffset(anchor);\r\n        }\r\n        else {\r\n            const dir = compass_1.cardinalDirectionFromNorthTurn(turn);\r\n            const { x, y } = this;\r\n            const dirx = X_FROM_CARDINAL_DIRECTION[dir];\r\n            const diry = Y_FROM_CARDINAL_DIRECTION[dir];\r\n            const nx = -y * dirx - x * diry;\r\n            const ny = x * dirx - y * diry;\r\n            return this.set(nx, ny);\r\n        }\r\n    }\r\n    // utilities\r\n    // chebyshev: can move in any direction (diagonals are ok)\r\n    distanceChebyshev(other) {\r\n        return Math.max(Math.abs(this.x - other.x), Math.abs(this.y - other.y));\r\n    }\r\n    // manhattan: can move only in cardinal directions (no diagonals)\r\n    distanceManhattan(other) {\r\n        return Math.abs(this.x - other.x) + Math.abs(this.y - other.y);\r\n    }\r\n    // chebyshev: can move in any direction (diagonals are ok)\r\n    *nearbyChebyshevOffsets(cursor, radius) {\r\n        if (radius >= 0) {\r\n            for (let dy = -radius; dy <= radius; dy++) {\r\n                for (let dx = -radius; dx <= radius; dx++) {\r\n                    yield cursor.set(this.x + dx, this.y + dy);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\nexports.Offset = Offset;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.RasterMask = void 0;\r\nconst rectangle_1 = require(\"./rectangle\");\r\nclass RasterMask {\r\n    constructor(bounds, lines) {\r\n        this._rect = new rectangle_1.Rectangle();\r\n        if (lines.length !== bounds.height) {\r\n            throw new Error(`bad lines array length ${lines.length} for bounds ${bounds}`);\r\n        }\r\n        this._rect.copyFrom(bounds);\r\n        this._lines = lines;\r\n    }\r\n    // accessors\r\n    toString() {\r\n        let shape = '';\r\n        const { eastX } = this._rect;\r\n        for (let y = 0; y < this.height; y++) {\r\n            const line = this._lines[y];\r\n            let x = this.westX;\r\n            for (let i = 0; i < line.length; i += 2) {\r\n                const start = line[i];\r\n                const end = line[i + 1];\r\n                while (x < start) {\r\n                    shape += '∙';\r\n                    x++;\r\n                }\r\n                while (x < end) {\r\n                    shape += '█';\r\n                    x++;\r\n                }\r\n            }\r\n            while (x <= eastX) {\r\n                shape += '∙';\r\n                x++;\r\n            }\r\n            shape += '\\n';\r\n        }\r\n        return `(${this._rect.westX},${this._rect.northY})\\n${shape}`;\r\n    }\r\n    equals(other) {\r\n        return this._rect.equals(other._rect)\r\n            && this._lines.length === other._lines.length\r\n            && this._lines.every((v, i) => (v.length === other._lines[i].length\r\n                && v.every((w, j) => w === other._lines[i][j])));\r\n    }\r\n    get northY() {\r\n        return this._rect.northY;\r\n    }\r\n    get southY() {\r\n        return this._rect.southY;\r\n    }\r\n    get westX() {\r\n        return this._rect.westX;\r\n    }\r\n    get width() {\r\n        return this._rect.width;\r\n    }\r\n    get height() {\r\n        return this._rect.height;\r\n    }\r\n    get(x, y) {\r\n        if (y < this.northY || y > this._rect.southY) {\r\n            return false;\r\n        }\r\n        const line = this._lines[y - this.northY];\r\n        for (let i = 0; i < line.length; i += 2) {\r\n            if (x >= line[i] && x < line[i + 1]) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    getAtOffset(off) {\r\n        return this.get(off.x, off.y);\r\n    }\r\n    // utilities\r\n    *bandsAt(y) {\r\n        if (y >= this.northY && y <= this._rect.southY) {\r\n            const line = this._lines[y - this.northY];\r\n            for (let i = 0; i < line.length; i += 2) {\r\n                yield {\r\n                    westX: line[i],\r\n                    eastX: line[i + 1] - 1,\r\n                };\r\n            }\r\n        }\r\n    }\r\n}\r\nexports.RasterMask = RasterMask;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Rectangle = void 0;\r\nconst size_1 = require(\"./size\");\r\nconst offset_1 = require(\"./offset\");\r\nconst ROTATE_CORNER_X = [0, 0, 1, 1];\r\nconst ROTATE_CORNER_Y = [0, 1, 1, 0];\r\nclass Rectangle {\r\n    constructor(westX, northY, width, height) {\r\n        if (typeof westX === 'undefined') {\r\n            westX = 0;\r\n        }\r\n        if (typeof northY === 'undefined') {\r\n            northY = 0;\r\n        }\r\n        if (typeof width === 'undefined') {\r\n            width = 0;\r\n        }\r\n        if (typeof height === 'undefined') {\r\n            height = 0;\r\n        }\r\n        this.northWest = new offset_1.Offset(westX, northY);\r\n        this.size = new size_1.Size(width, height);\r\n    }\r\n    // accessors\r\n    toString() {\r\n        return `(${this.westX},${this.northY} ${this.width}x${this.height})`;\r\n    }\r\n    equals(other) {\r\n        return this.westX === other.westX && this.northY === other.northY && this.size.equals(other);\r\n    }\r\n    get northY() {\r\n        return this.northWest.y;\r\n    }\r\n    get southY() {\r\n        return this.northWest.y + this.size.height - 1;\r\n    }\r\n    get westX() {\r\n        return this.northWest.x;\r\n    }\r\n    get eastX() {\r\n        return this.northWest.x + this.size.width - 1;\r\n    }\r\n    get width() {\r\n        return this.size.width;\r\n    }\r\n    get height() {\r\n        return this.size.height;\r\n    }\r\n    get empty() {\r\n        return this.size.empty;\r\n    }\r\n    get area() {\r\n        return this.size.area;\r\n    }\r\n    // mutators\r\n    set(westX, northY, width, height) {\r\n        this.northWest.set(westX, northY);\r\n        this.size.set(width, height);\r\n        return this;\r\n    }\r\n    setFromCorners(off1, off2) {\r\n        const westX = Math.min(off1.x, off2.x);\r\n        const eastX = Math.max(off1.x, off2.x);\r\n        const northY = Math.min(off1.y, off2.y);\r\n        const southY = Math.max(off1.y, off2.y);\r\n        return this.set(westX, northY, eastX - westX + 1, southY - northY + 1);\r\n    }\r\n    copyFrom(other) {\r\n        return this.set(other.westX, other.northY, other.width, other.height);\r\n    }\r\n    addOffset(off) {\r\n        this.northWest.addOffset(off);\r\n        return this;\r\n    }\r\n    scale(factor) {\r\n        this.northWest.multiply(factor);\r\n        this.size.multiply(factor);\r\n        return this;\r\n    }\r\n    rotate(turn, anchor) {\r\n        const cx = ROTATE_CORNER_X[turn];\r\n        const cy = ROTATE_CORNER_Y[turn];\r\n        this.northWest.add(cx * (this.width - 1), cy * (this.height - 1)).rotate(turn, anchor);\r\n        this.size.rotate(turn);\r\n        return this;\r\n    }\r\n    extendToInclude(off) {\r\n        const dx = off.x - this.westX;\r\n        if (dx < 0) {\r\n            this.size.width -= dx;\r\n            this.northWest.x = off.x;\r\n        }\r\n        else if (dx >= this.size.width) {\r\n            this.size.width = dx + 1;\r\n        }\r\n        const dy = off.y - this.northWest.y;\r\n        if (dy < 0) {\r\n            this.size.height -= dy;\r\n            this.northWest.y = off.y;\r\n        }\r\n        else if (dy >= this.size.height) {\r\n            this.size.height = dy + 1;\r\n        }\r\n        return this;\r\n    }\r\n    // utilities\r\n    contains(x, y) {\r\n        return this.size.contains(x - this.westX, y - this.northY);\r\n    }\r\n    index(x, y) {\r\n        return this.size.index(x - this.westX, y - this.northY);\r\n    }\r\n    containsOffset(off) {\r\n        return this.contains(off.x, off.y);\r\n    }\r\n    containsRectangle(other) {\r\n        if (other.width === 0 && other.height === 0) {\r\n            return false;\r\n        }\r\n        const x = other.westX - this.westX;\r\n        const y = other.northY - this.northY;\r\n        if (!this.size.contains(x, y)) {\r\n            return false;\r\n        }\r\n        return this.size.contains(x + other.width - 1, y + other.height - 1);\r\n    }\r\n    overlapsRectangle(other) {\r\n        return this.northY <= other.northY + other.height - 1\r\n            && this.southY >= other.northY\r\n            && this.westX <= other.westX + other.width - 1\r\n            && this.eastX >= other.westX\r\n            && !this.empty\r\n            && other.width !== 0 && other.height !== 0;\r\n    }\r\n    *offsets() {\r\n        const { eastX, southY } = this;\r\n        for (let y = this.northY; y <= southY; y++) {\r\n            for (let x = this.westX; x <= eastX; x++) {\r\n                yield { x, y };\r\n            }\r\n        }\r\n    }\r\n    anyOf(predicate) {\r\n        for (const { x, y } of this.offsets()) {\r\n            if (predicate(x, y)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}\r\nexports.Rectangle = Rectangle;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Size = void 0;\r\nconst compass_1 = require(\"../compass\");\r\nclass Size {\r\n    constructor(width, height) {\r\n        if (typeof width === 'undefined') {\r\n            width = 0;\r\n        }\r\n        if (typeof height === 'undefined') {\r\n            height = 0;\r\n        }\r\n        if (width < 0 || height < 0) {\r\n            throw new Error(`bad size (${width}x${height})`);\r\n        }\r\n        this.width = width;\r\n        this.height = height;\r\n    }\r\n    // accessors\r\n    toString() {\r\n        return `(${this.width}x${this.height})`;\r\n    }\r\n    equals(other) {\r\n        return this.width === other.width && this.height === other.height;\r\n    }\r\n    get empty() {\r\n        return this.width === 0 || this.height === 0;\r\n    }\r\n    get area() {\r\n        return this.width * this.height;\r\n    }\r\n    // mutators\r\n    set(width, height) {\r\n        if (width < 0 || height < 0) {\r\n            throw new Error(`bad size (${width}x${height})`);\r\n        }\r\n        this.width = width;\r\n        this.height = height;\r\n        return this;\r\n    }\r\n    copyFrom(other) {\r\n        return this.set(other.width, other.height);\r\n    }\r\n    add(width, height) {\r\n        this.width += width;\r\n        this.height += height;\r\n        return this;\r\n    }\r\n    multiply(factor) {\r\n        this.width *= factor;\r\n        this.height *= factor;\r\n        return this;\r\n    }\r\n    rotate(turn) {\r\n        if (compass_1.axisFromNorthSouthTurn(turn) === compass_1.Axis.WEST_EAST) {\r\n            this.set(this.height, this.width);\r\n        }\r\n        return this;\r\n    }\r\n    // utilities\r\n    contains(x, y) {\r\n        return x >= 0 && y >= 0 && x < this.width && y < this.height;\r\n    }\r\n    containsOffset(off) {\r\n        return this.contains(off.x, off.y);\r\n    }\r\n    index(x, y) {\r\n        return y * this.width + x;\r\n    }\r\n    *offsets() {\r\n        for (let y = 0; y < this.height; y++) {\r\n            for (let x = 0; x < this.width; x++) {\r\n                yield { x, y };\r\n            }\r\n        }\r\n    }\r\n    anyOf(predicate) {\r\n        for (const { x, y } of this.offsets()) {\r\n            if (predicate(x, y)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}\r\nexports.Size = Size;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.TransformRectangle = void 0;\r\nconst rectangle_1 = require(\"./rectangle\");\r\nconst compass_1 = require(\"../compass\");\r\nconst offset_1 = require(\"./offset\");\r\nconst size_1 = require(\"./size\");\r\nconst LOCAL_OFF = new offset_1.Offset();\r\nconst LOCAL_OFF2 = new offset_1.Offset();\r\nconst LOCAL_SIZE = new size_1.Size();\r\nclass TransformRectangle {\r\n    constructor(width, height) {\r\n        this._size = new size_1.Size();\r\n        this._flip = compass_1.Flip.HEADS;\r\n        this._rotate = compass_1.CardinalTurn.NONE;\r\n        this._translate = new offset_1.Offset();\r\n        this._matrix = [1, 0, 0, 0, 1, 0];\r\n        this._targetRect = new rectangle_1.Rectangle();\r\n        if (typeof width === 'undefined') {\r\n            // nothing\r\n        }\r\n        else if (typeof width === 'number') {\r\n            this._size.set(width, height);\r\n        }\r\n        else {\r\n            this._size.copyFrom(width);\r\n        }\r\n        this._update();\r\n    }\r\n    // accessors\r\n    toString() {\r\n        return `[${this._size}`\r\n            + ` -> ${compass_1.flipToString(this._flip)} ${compass_1.cardinalTurnToString(this._rotate)} ${this._translate}`\r\n            + ` -> ${this._targetRect}]`;\r\n    }\r\n    equals(other) {\r\n        return this._size.equals(other._size)\r\n            && this._flip === other._flip\r\n            && this._rotate === other._rotate\r\n            && this._translate.equals(other._translate);\r\n    }\r\n    get flip() {\r\n        return this._flip;\r\n    }\r\n    get rotate() {\r\n        return this._rotate;\r\n    }\r\n    get northY() {\r\n        return this._translate.y;\r\n    }\r\n    get southY() {\r\n        return this._translate.y + this._targetRect.height - 1;\r\n    }\r\n    get westX() {\r\n        return this._translate.x;\r\n    }\r\n    get eastX() {\r\n        return this._translate.x + this._targetRect.width - 1;\r\n    }\r\n    get width() {\r\n        return this._targetRect.width;\r\n    }\r\n    get height() {\r\n        return this._targetRect.height;\r\n    }\r\n    // internal\r\n    // 0\r\n    //    0 -1\r\n    // +90\r\n    //    1  0\r\n    // 180\r\n    //    0  1\r\n    // -90\r\n    //   -1  0\r\n    //\r\n    // heads:\r\n    //   0\r\n    //      1  0  x\r\n    //      0  1  y\r\n    //   +90\r\n    //      0 -1  x + h - 1\r\n    //      1  0  y\r\n    //   180\r\n    //     -1  0  x + w - 1\r\n    //      0 -1  y + h - 1\r\n    //   -90\r\n    //      0  1  x\r\n    //     -1  0  y + w - 1\r\n    //\r\n    // tails:\r\n    //   0\r\n    //     -1  0  x + w - 1\r\n    //      0  1  y\r\n    //   +90\r\n    //      0 -1  x + h - 1\r\n    //     -1  0  y + w - 1\r\n    //   180\r\n    //      1  0  x\r\n    //      0 -1  y + h - 1\r\n    //   -90\r\n    //      0  1  x\r\n    //      1  0  y\r\n    _update() {\r\n        LOCAL_OFF.setFromCardinalDirection(compass_1.cardinalDirectionFromNorthTurn(this._rotate));\r\n        const flipSign = this._flip === compass_1.Flip.TAILS ? -1 : 1;\r\n        this._matrix[0] = -LOCAL_OFF.y * flipSign;\r\n        this._matrix[1] = -LOCAL_OFF.x;\r\n        this._matrix[2] = this._translate.x;\r\n        this._matrix[3] = LOCAL_OFF.x * flipSign;\r\n        this._matrix[4] = -LOCAL_OFF.y;\r\n        this._matrix[5] = this._translate.y;\r\n        switch (this._rotate) {\r\n            case compass_1.CardinalTurn.NONE:\r\n                if (this._flip === compass_1.Flip.TAILS) {\r\n                    this._matrix[2] += this._size.width - 1;\r\n                }\r\n                break;\r\n            case compass_1.CardinalTurn.RIGHT:\r\n                this._matrix[2] += this._size.height - 1;\r\n                if (this._flip === compass_1.Flip.TAILS) {\r\n                    this._matrix[5] += this._size.width - 1;\r\n                }\r\n                break;\r\n            case compass_1.CardinalTurn.AROUND:\r\n                this._matrix[5] += this._size.height - 1;\r\n                if (this._flip === compass_1.Flip.HEADS) {\r\n                    this._matrix[2] += this._size.width - 1;\r\n                }\r\n                break;\r\n            case compass_1.CardinalTurn.LEFT:\r\n                if (this._flip === compass_1.Flip.HEADS) {\r\n                    this._matrix[5] += this._size.width - 1;\r\n                }\r\n                break;\r\n        }\r\n        LOCAL_SIZE.copyFrom(this._size).rotate(this._rotate);\r\n        this._targetRect.set(this._translate.x, this._translate.y, LOCAL_SIZE.width, LOCAL_SIZE.height);\r\n        return this;\r\n    }\r\n    // mutators\r\n    copyFrom(other) {\r\n        this._size.copyFrom(other._size);\r\n        this._flip = other._flip;\r\n        this._rotate = other._rotate;\r\n        this._translate.copyFrom(other._translate);\r\n        other._matrix.forEach((v, i) => this._matrix[i] = v);\r\n        this._targetRect.copyFrom(other._targetRect);\r\n        return this;\r\n    }\r\n    reset() {\r\n        this._flip = compass_1.Flip.HEADS;\r\n        this._rotate = compass_1.CardinalTurn.NONE;\r\n        this._translate.set(0, 0);\r\n        return this._update();\r\n    }\r\n    invert() {\r\n        const nrotate = compass_1.cardinalTurnFromCardinalDirections(compass_1.CardinalDirection.NORTH, compass_1.cardinalDirectionFromCardinalOrientation(compass_1.cardinalOrientationReverse(compass_1.cardinalOrientationFromFlipAndCardinalDirection(this._flip, compass_1.cardinalDirectionFromNorthTurn(this._rotate)))));\r\n        this._rotate = nrotate;\r\n        this._size.rotate(nrotate);\r\n        this._translate.multiply(-1);\r\n        return this._update();\r\n    }\r\n    setTransform(flip, rotate, translate) {\r\n        this._flip = flip;\r\n        this._rotate = rotate;\r\n        this._translate.copyFrom(translate);\r\n        return this._update();\r\n    }\r\n    setFlip(flip) {\r\n        this._flip = flip;\r\n        return this._update();\r\n    }\r\n    setRotate(rotate) {\r\n        this._rotate = rotate;\r\n        return this._update();\r\n    }\r\n    setTranslate(x, y) {\r\n        this._translate.set(x, y);\r\n        return this._update();\r\n    }\r\n    setTranslateOffset(translate) {\r\n        this._translate.copyFrom(translate);\r\n        return this._update();\r\n    }\r\n    // utility\r\n    applyToCardinalOrientation(orientation) {\r\n        if (this._flip === compass_1.Flip.TAILS) {\r\n            orientation = compass_1.cardinalOrientationFlip(orientation, compass_1.Axis.NORTH_SOUTH);\r\n        }\r\n        return compass_1.cardinalOrientationAddCardinalTurn(orientation, this._rotate);\r\n    }\r\n    unapplyFromCardinalOrientation(orientation) {\r\n        orientation = compass_1.cardinalOrientationAddCardinalTurn(orientation, compass_1.cardinalTurnReverse(this._rotate));\r\n        if (this._flip === compass_1.Flip.TAILS) {\r\n            orientation = compass_1.cardinalOrientationFlip(orientation, compass_1.Axis.NORTH_SOUTH);\r\n        }\r\n        return orientation;\r\n    }\r\n    applyToCardinalDirection(orientation) {\r\n        return compass_1.cardinalDirectionFromCardinalOrientation(this.applyToCardinalOrientation(compass_1.cardinalOrientationFromFlipAndCardinalDirection(compass_1.Flip.HEADS, orientation)));\r\n    }\r\n    unapplyFromCardinalDirection(orientation) {\r\n        return compass_1.cardinalDirectionFromCardinalOrientation(this.unapplyFromCardinalOrientation(compass_1.cardinalOrientationFromFlipAndCardinalDirection(compass_1.Flip.HEADS, orientation)));\r\n    }\r\n    applyTo(offOut, x, y) {\r\n        const nx = x * this._matrix[0] + y * this._matrix[1] + this._matrix[2];\r\n        const ny = x * this._matrix[3] + y * this._matrix[4] + this._matrix[5];\r\n        return offOut.set(nx, ny);\r\n    }\r\n    unapplyFrom(offOut, x, y) {\r\n        const tx = x - this._matrix[2];\r\n        const ty = y - this._matrix[5];\r\n        const nx = tx * this._matrix[0] + ty * this._matrix[3];\r\n        const ny = tx * this._matrix[1] + ty * this._matrix[4];\r\n        return offOut.set(nx, ny);\r\n    }\r\n    applyToOffset(offOut, off) {\r\n        if (typeof off === 'undefined') {\r\n            off = offOut;\r\n        }\r\n        return this.applyTo(offOut, off.x, off.y);\r\n    }\r\n    unapplyFromOffset(offOut, off) {\r\n        if (typeof off === 'undefined') {\r\n            off = offOut;\r\n        }\r\n        return this.unapplyFrom(offOut, off.x, off.y);\r\n    }\r\n    applyToRectangle(rectOut, rect) {\r\n        if (typeof rect !== 'undefined') {\r\n            rectOut.copyFrom(rect);\r\n        }\r\n        LOCAL_OFF.set(rectOut.westX, rectOut.northY);\r\n        LOCAL_OFF2.set(rectOut.eastX, rectOut.southY);\r\n        this.applyToOffset(LOCAL_OFF);\r\n        this.applyToOffset(LOCAL_OFF2);\r\n        return rectOut.setFromCorners(LOCAL_OFF, LOCAL_OFF2);\r\n    }\r\n    unapplyFromRectangle(rectOut, rect) {\r\n        if (typeof rect !== 'undefined') {\r\n            rectOut.copyFrom(rect);\r\n        }\r\n        LOCAL_OFF.set(rectOut.westX, rectOut.northY);\r\n        LOCAL_OFF2.set(rectOut.eastX, rectOut.southY);\r\n        this.unapplyFromOffset(LOCAL_OFF);\r\n        this.unapplyFromOffset(LOCAL_OFF2);\r\n        return rectOut.setFromCorners(LOCAL_OFF, LOCAL_OFF2);\r\n    }\r\n}\r\nexports.TransformRectangle = TransformRectangle;\r\n","\"use strict\";\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n__exportStar(require(\"./compass\"), exports);\r\n__exportStar(require(\"./grid\"), exports);\r\n","\"use strict\";\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n});\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.computeFieldOfView = void 0;\r\nconst geom = __importStar(require(\"tiled-geometry\"));\r\nconst constants = __importStar(require(\"./constants\"));\r\nconst wedge_1 = require(\"./wedge\");\r\nconst tile_flags_1 = require(\"./tile-flags\");\r\nconst field_of_view_impl_1 = require(\"./field-of-view-impl\");\r\nconst warp_data_1 = require(\"./warp-data\");\r\n/* eslint-disable indent */\r\n/**\r\n * Compute the field of view for a camera at the given tile.\r\n * chebyshevRadius is the vision radius.  It uses chebyshev distance\r\n * (https://en.wikipedia.org/wiki/Chebyshev_distance), which just means\r\n * that the limit of vision in a large empty field will be square.\r\n *\r\n * This returns a WarpRect, which indicates which tiles are visible\r\n * and which map is seen in each tile.  warpRect.getMask(x, y) will return\r\n * true for visible tiles, warpRect.getMap(x, y) will return\r\n * the map for that tile, and warpRect.getOffset(x, y) will return the\r\n * location in that map which is visible there.\r\n */\r\nfunction computeFieldOfView(map, x, y, chebyshevRadius) {\r\n    if (!map.contains(x, y)) {\r\n        throw new Error(`origin is not on the map`);\r\n    }\r\n    const origin = new geom.Offset(x, y);\r\n    const field = new field_of_view_impl_1.FieldOfViewImpl(map, origin, chebyshevRadius);\r\n    const warpDataCache = new warp_data_1.WarpDataCache();\r\n    const baseWarp = warpDataCache.get(map, 0, x, y);\r\n    // the field is divided into quadrants\r\n    quadrant(field, origin, chebyshevRadius, -1, -1, warpDataCache, baseWarp);\r\n    quadrant(field, origin, chebyshevRadius, 1, -1, warpDataCache, baseWarp);\r\n    quadrant(field, origin, chebyshevRadius, -1, 1, warpDataCache, baseWarp);\r\n    quadrant(field, origin, chebyshevRadius, 1, 1, warpDataCache, baseWarp);\r\n    return field;\r\n}\r\nexports.computeFieldOfView = computeFieldOfView;\r\nfunction quadrant(field, origin, chebyshevRadius, xSign, ySign, warpDataCache, baseWarp) {\r\n    const yDir = [geom.CardinalDirection.NORTH, geom.CardinalDirection.SOUTH][(ySign + 1) / 2];\r\n    const xDir = [geom.CardinalDirection.WEST, geom.CardinalDirection.EAST][(xSign + 1) / 2];\r\n    const farYFlag = [tile_flags_1.TileFlags.WALL_NORTH, tile_flags_1.TileFlags.WALL_SOUTH][(ySign + 1) / 2];\r\n    const farXFlag = [tile_flags_1.TileFlags.WALL_WEST, tile_flags_1.TileFlags.WALL_EAST][(xSign + 1) / 2];\r\n    let wedges = wedge_1.initWedges(baseWarp);\r\n    for (let ny = 0; ny <= chebyshevRadius; ny++) {\r\n        const dy = ny * ySign;\r\n        for (let nx = 0; nx <= chebyshevRadius; nx++) {\r\n            const dx = nx * xSign;\r\n            // the slopes of the four corners of this tile\r\n            // these are named as follows:\r\n            //   slopeY is the slope closest to the Y axis\r\n            //   slopeFar is the slope to the farthest corner\r\n            //   slopeMid is the slope to the center\r\n            //   slopeX is the slope closest to the X axis\r\n            // these are always true:\r\n            //   slopeY < slopeFar < slopeX\r\n            //   slopeY < slopeMid < slopeX\r\n            //\r\n            // O = origin, C = current\r\n            // +---+---+---+\r\n            // | O |   |   |\r\n            // +---+---+---X\r\n            // |   |   | C |\r\n            // +---+---Y---F\r\n            const slopeY = (nx - 0.5) / (ny + 0.5);\r\n            const slopeFar = (nx + 0.5) / (ny + 0.5);\r\n            const slopeMid = ny !== 0 ? nx / ny : Number.POSITIVE_INFINITY;\r\n            const slopeX = ny !== 0 ? (nx + 0.5) / (ny - 0.5) : Number.POSITIVE_INFINITY;\r\n            // among all non-shadow wedges that intersect this tile,\r\n            // choose the one closest to slopeMid (with additional rules\r\n            // for breaking ties)\r\n            {\r\n                const wedge = wedge_1.getBestWedge(wedges, slopeY, slopeMid, slopeX);\r\n                field.warps[field.visible.index(dx, dy)] = wedge.warp;\r\n                if (wedge.shadow) {\r\n                    field.visible.set(dx, dy, false);\r\n                }\r\n            }\r\n            const newWedges = [];\r\n            // add shadows and warps to each wedge that passes through this tile\r\n            for (const wedge of wedges) {\r\n                if (wedge.low >= slopeX || wedge.high <= slopeY) {\r\n                    newWedges.push(wedge);\r\n                    continue;\r\n                }\r\n                const warpData = wedge.warp;\r\n                const map = warpData.map;\r\n                const x = warpData.shiftX + dx;\r\n                const y = warpData.shiftY + dy;\r\n                if (!map.contains(x, y)) {\r\n                    newWedges.push(wedge);\r\n                    continue;\r\n                }\r\n                // the walls of this tile\r\n                // these are named as follows:\r\n                //   wallY is the farthest horizontal wall (slopeY to slopeFar)\r\n                //   wallX is the farthest vertical wall (slopeFar to slopeX)\r\n                //\r\n                // O = origin, C = current\r\n                // +---+---+---+\r\n                // | O |   |   |\r\n                // +---+---+---+\r\n                // |   |   | C X\r\n                // +---+---+-Y-+\r\n                const mapIndex = map.index(x, y);\r\n                const tileFlags = map.getTileFlagsAtIndex(mapIndex);\r\n                const warpY = map.getWarpAtIndex(mapIndex, yDir);\r\n                const warpX = map.getWarpAtIndex(mapIndex, xDir);\r\n                // warps override walls\r\n                const wallY = !warpY && (tileFlags & farYFlag) !== 0;\r\n                const wallX = !warpX && (tileFlags & farXFlag) !== 0;\r\n                // shadows\r\n                // /- slopeY - WALL_OUTSET\r\n                // |  /- slopeY\r\n                // |  .  /- slopeY + BODY_INSET\r\n                // |  .  |     /- slopeFar - WALL_OUTSET\r\n                // |  .  |     |  /- slopeFar\r\n                // |  .  |     |  .  /- slopeFar + WALL_OUTSET\r\n                // |  .  |     |  .  |     /- slopeX - BODY_INSET\r\n                // |  .  |     |  .  |     |  /- slopeX\r\n                // |  .  |     |  .  |     |  .  /- slopeX + WALL_OUTSET\r\n                // |  .  |     |  .  |     |  .  |\r\n                // |  .  |     |  .  |     |  .  |\r\n                // =======wallY=======\r\n                //       ========body=======\r\n                //             =======wallX=======\r\n                let shadowWedges;\r\n                if (wallY && wallX) {\r\n                    // add full shadow, covering wallY and wallX\r\n                    shadowWedges = wedge_1.addShadow(wedge, slopeY - constants.WALL_OUTSET, slopeX + constants.WALL_OUTSET);\r\n                }\r\n                else {\r\n                    const body = (nx !== 0 || ny !== 0) && (tileFlags & tile_flags_1.TileFlags.BODY) !== 0;\r\n                    if (body) {\r\n                        if (wallY) {\r\n                            // add shadow covering wallY and body\r\n                            shadowWedges = wedge_1.addShadow(wedge, slopeY - constants.WALL_OUTSET, slopeX - constants.BODY_INSET);\r\n                        }\r\n                        else if (wallX) {\r\n                            // add shadow covering body and wallX\r\n                            shadowWedges = wedge_1.addShadow(wedge, slopeY + constants.BODY_INSET, slopeX + constants.WALL_OUTSET);\r\n                        }\r\n                        else {\r\n                            // add shadow covering body\r\n                            shadowWedges = wedge_1.addShadow(wedge, slopeY + constants.BODY_INSET, slopeX - constants.BODY_INSET);\r\n                        }\r\n                    }\r\n                    else if (wallY) {\r\n                        // add shadow covering wallY\r\n                        shadowWedges = wedge_1.addShadow(wedge, slopeY - constants.WALL_OUTSET, slopeFar + constants.WALL_OUTSET);\r\n                    }\r\n                    else if (wallX) {\r\n                        // add shadow covering wallX\r\n                        shadowWedges = wedge_1.addShadow(wedge, slopeFar - constants.WALL_OUTSET, slopeX + constants.WALL_OUTSET);\r\n                    }\r\n                    else {\r\n                        // no new shadows\r\n                        shadowWedges = [wedge];\r\n                    }\r\n                }\r\n                for (const shadowWedge of shadowWedges) {\r\n                    // warps\r\n                    // /- slopeY - WARP_OUTSET\r\n                    // |  /- slopeY\r\n                    // |  .     /- slopeFar - WARP_OUTSET\r\n                    // |  .     |  /- slopeFar\r\n                    // |  .     |  .  /- slopeFar + WARP_OUTSET\r\n                    // |  .     |  .  |     /- slopeX\r\n                    // |  .     |  .  |     .  /- slopeX + WARP_OUTSET\r\n                    // |  .     |  .  |     .  |\r\n                    // |  .     |  .  |     .  |\r\n                    // =====warpY======\r\n                    //          =====warpX======\r\n                    // if warpY and warpX, then they don't overlap:\r\n                    // ====warpY====\r\n                    //             ====warpX====\r\n                    if (warpY && warpX) {\r\n                        // add warp from slopeY - WARP_OUTSET to slopeFar\r\n                        const warpDataY = warpDataCache.get(warpY.map, warpData.warpCount + 1, warpData.shiftX + warpY.offsetShift.x, warpData.shiftY + warpY.offsetShift.y);\r\n                        const warpWedges = wedge_1.addWarp(shadowWedge, warpDataY, slopeY - constants.WARP_OUTSET, slopeFar);\r\n                        // add warp from slopeFar to slopeX + WARP_OUTSET\r\n                        const warpDataX = warpDataCache.get(warpX.map, warpData.warpCount + 1, warpData.shiftX + warpX.offsetShift.x, warpData.shiftY + warpX.offsetShift.y);\r\n                        for (const warpWedge of warpWedges) {\r\n                            newWedges.push(...wedge_1.addWarp(warpWedge, warpDataX, slopeFar, slopeX + constants.WARP_OUTSET));\r\n                        }\r\n                    }\r\n                    else if (warpY) {\r\n                        // no warpX\r\n                        // add warp from slopeY - WARP_OUTSET to slopeFar + WARP_OUTSET\r\n                        const warpDataY = warpDataCache.get(warpY.map, warpData.warpCount + 1, warpData.shiftX + warpY.offsetShift.x, warpData.shiftY + warpY.offsetShift.y);\r\n                        newWedges.push(...wedge_1.addWarp(shadowWedge, warpDataY, slopeY - constants.WARP_OUTSET, slopeFar + constants.WARP_OUTSET));\r\n                    }\r\n                    else if (warpX) {\r\n                        // no warpY\r\n                        // add warp from slopeFar - WARP_OUTSET to slopeX + WARP_OUTSET\r\n                        const warpDataX = warpDataCache.get(warpX.map, warpData.warpCount + 1, warpData.shiftX + warpX.offsetShift.x, warpData.shiftY + warpX.offsetShift.y);\r\n                        newWedges.push(...wedge_1.addWarp(shadowWedge, warpDataX, slopeFar - constants.WARP_OUTSET, slopeX + constants.WARP_OUTSET));\r\n                    }\r\n                    else {\r\n                        // no warps\r\n                        newWedges.push(shadowWedge);\r\n                    }\r\n                }\r\n            }\r\n            wedges = wedge_1.mergeWedges(newWedges);\r\n        }\r\n    }\r\n}\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.PICK_WEDGE_EPSILON = exports.WARP_OUTSET = exports.WALL_OUTSET = exports.BODY_INSET = void 0;\r\n/**\r\n * A smallish number, to adjust some wedges.\r\n */\r\nconst EPSILON = 0.00001;\r\n/**\r\n * Bodies in this algorithm do not entirely fill their tiles.  This is\r\n * implemented by adjusting the angles of the shadows the bodies cast,\r\n * making the wedge very slightly narrower.  BODY_INSET represents the\r\n * amount of reduction on either side of the wedge.\r\n */\r\nexports.BODY_INSET = EPSILON;\r\n/**\r\n * Walls do fill the entire tile edge.  With infinite precision, there would be\r\n * no need to adjust the shadow cast by a wall.  But we're using floating point\r\n * math here, which means imprecision can creep in and cause angles not to line\r\n * up properly.  To fix that, we widen the wedges of the shadows cast by walls.\r\n * We must make sure not to widen them as much as we narrow the body shadows,\r\n * or else they might close the gap we want between a body and a wall.\r\n */\r\nexports.WALL_OUTSET = exports.BODY_INSET / 4;\r\n// TODO make this / 10 so it's easier to see in the number\r\n/**\r\n * Warps also fill the entire tile edge.  But we don't extend warps as much as\r\n * walls, just in case a sliver of warp might make it past a wall on the other\r\n * side of the warp, at the edge of the warp range.\r\n */\r\nexports.WARP_OUTSET = exports.WALL_OUTSET / 4;\r\n// TODO make this / 10 so it's easier to see in the number\r\n// must be bigger than WALL_OUTSET\r\nexports.PICK_WEDGE_EPSILON = exports.WALL_OUTSET * 2;\r\n","\"use strict\";\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n});\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.FieldOfViewImpl = void 0;\r\nconst geom = __importStar(require(\"tiled-geometry\"));\r\nclass FieldOfViewImpl {\r\n    constructor(map, origin, chebyshevRadius) {\r\n        this.map = map;\r\n        this.origin = origin;\r\n        this.chebyshevRadius = chebyshevRadius;\r\n        const boundRect = new geom.Rectangle(-chebyshevRadius, -chebyshevRadius, chebyshevRadius * 2 + 1, chebyshevRadius * 2 + 1);\r\n        this.visible = new geom.MaskRectangle(boundRect, true);\r\n        // the origin is always visible\r\n        this.visible.set(0, 0, true);\r\n        this.warps = new Array(boundRect.area);\r\n    }\r\n    getVisible(dx, dy) {\r\n        return this.visible.get(dx, dy);\r\n    }\r\n    getTargetMap(dx, dy) {\r\n        return this._getWarp(dx, dy).map;\r\n    }\r\n    getTargetOffset(dx, dy) {\r\n        const warp = this._getWarp(dx, dy);\r\n        return { x: warp.shiftX + dx, y: warp.shiftY + dy };\r\n    }\r\n    toString() {\r\n        let ret = '';\r\n        for (let dy = -this.chebyshevRadius; dy <= this.chebyshevRadius; dy++) {\r\n            for (let dx = -this.chebyshevRadius; dx <= this.chebyshevRadius; dx++) {\r\n                if (dx === 0 && dy === 0) {\r\n                    ret += '@';\r\n                }\r\n                else if (this.getVisible(dx, dy)) {\r\n                    const warp = this._getWarp(dx, dy);\r\n                    ret += warp.map.id[0];\r\n                }\r\n                else {\r\n                    ret += '.';\r\n                }\r\n            }\r\n            ret += '\\n';\r\n        }\r\n        return ret;\r\n    }\r\n    // internal\r\n    _getWarp(dx, dy) {\r\n        return this.warps[this.visible.index(dx, dy)];\r\n    }\r\n}\r\nexports.FieldOfViewImpl = FieldOfViewImpl;\r\n","\"use strict\";\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n});\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.FieldOfViewMap = void 0;\r\nconst geom = __importStar(require(\"tiled-geometry\"));\r\nconst tile_flags_1 = require(\"./tile-flags\");\r\n/**\r\n * We avoid heap allocations during the core part of the algorithm by using this\r\n * preallocated offset object.\r\n */\r\nconst LOCAL_OFF = new geom.Offset();\r\n/**\r\n * The FieldOfViewMap class describes the map over which the field of view will be\r\n * computed.  It starts empty.\r\n */\r\nclass FieldOfViewMap {\r\n    constructor(id, width, height, addEdgeWalls = false) {\r\n        this._size = new geom.Size();\r\n        this._warps = new Array();\r\n        this.id = id;\r\n        this._size.set(width, height);\r\n        this._tileFlags = new Array(this._size.area).fill(0);\r\n        if (addEdgeWalls) {\r\n            for (let y = 0; y < this._size.height; y++) {\r\n                this._addFlag(0, y, tile_flags_1.TileFlags.WALL_WEST);\r\n                this._addFlag(this._size.width - 1, y, tile_flags_1.TileFlags.WALL_EAST);\r\n            }\r\n            for (let x = 0; x < this._size.width; x++) {\r\n                this._addFlag(x, 0, tile_flags_1.TileFlags.WALL_NORTH);\r\n                this._addFlag(x, this._size.height - 1, tile_flags_1.TileFlags.WALL_SOUTH);\r\n            }\r\n        }\r\n        this._tileWarpIds = geom.CARDINAL_DIRECTIONS.map(() => new Array(this._size.area).fill(-1));\r\n    }\r\n    get width() {\r\n        return this._size.width;\r\n    }\r\n    get height() {\r\n        return this._size.height;\r\n    }\r\n    // bodies\r\n    addBody(x, y) {\r\n        this._addFlag(x, y, tile_flags_1.TileFlags.BODY);\r\n        return this;\r\n    }\r\n    removeBody(x, y) {\r\n        this._removeFlag(x, y, tile_flags_1.TileFlags.BODY);\r\n        return this;\r\n    }\r\n    getBody(x, y) {\r\n        const index = this.index(x, y);\r\n        return (this._tileFlags[index] & tile_flags_1.TileFlags.BODY) !== 0;\r\n    }\r\n    // walls\r\n    /**\r\n     * Adds a wall at a particular edge.  This automatically adds the\r\n     * corresponding wall on the other side.\r\n     */\r\n    addWall(x, y, dir, oneWay = false) {\r\n        this._addFlag(x, y, 1 << dir);\r\n        LOCAL_OFF.set(x, y);\r\n        LOCAL_OFF.addCardinalDirection(dir);\r\n        if (!oneWay && this._size.containsOffset(LOCAL_OFF)) {\r\n            this._addFlag(LOCAL_OFF.x, LOCAL_OFF.y, 1 << geom.cardinalDirectionOpposite(dir));\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Removes a wall at a particular edge.  This automatically removes the\r\n     * corresponding wall on the other side.\r\n     */\r\n    removeWall(x, y, dir, oneWay = false) {\r\n        this._removeFlag(x, y, 1 << dir);\r\n        LOCAL_OFF.set(x, y);\r\n        LOCAL_OFF.addCardinalDirection(dir);\r\n        if (!oneWay && this._size.containsOffset(LOCAL_OFF)) {\r\n            this._removeFlag(LOCAL_OFF.x, LOCAL_OFF.y, 1 << geom.cardinalDirectionOpposite(dir));\r\n        }\r\n        return this;\r\n    }\r\n    getWalls(x, y) {\r\n        const index = this.index(x, y);\r\n        return this._tileFlags[index] & geom.CardinalDirectionFlags.ALL;\r\n    }\r\n    getWall(x, y, dir) {\r\n        return (this.getWalls(x, y) & (1 << dir)) !== 0;\r\n    }\r\n    // warps\r\n    // TODO add length argument\r\n    addWarp(sourceX, sourceY, dir, targetMap, targetX, targetY, oneWay) {\r\n        if (!oneWay) {\r\n            LOCAL_OFF.set(sourceX - targetX, sourceY - targetY)\r\n                .addCardinalDirection(dir);\r\n            const targetWarpId = targetMap._findOrMakeWarp(this, LOCAL_OFF);\r\n            targetMap._addWarp(targetX, targetY, geom.cardinalDirectionOpposite(dir), targetWarpId);\r\n        }\r\n        LOCAL_OFF.set(targetX - sourceX, targetY - sourceY)\r\n            .addCardinalDirection(geom.cardinalDirectionOpposite(dir));\r\n        const warpId = this._findOrMakeWarp(targetMap, LOCAL_OFF);\r\n        this._addWarp(sourceX, sourceY, dir, warpId);\r\n        return this;\r\n    }\r\n    // TODO add length argument\r\n    removeWarp(sourceX, sourceY, dir, oneWay = false) {\r\n        if (!oneWay) {\r\n            const warp = this._getWarp(sourceX, sourceY, dir);\r\n            if (!warp) {\r\n                return this;\r\n            }\r\n            LOCAL_OFF.set(sourceX, sourceY)\r\n                .addCardinalDirection(dir)\r\n                .addOffset(warp.offsetShift);\r\n            warp.map._removeWarp(LOCAL_OFF.x, LOCAL_OFF.y, geom.cardinalDirectionOpposite(dir));\r\n        }\r\n        this._removeWarp(sourceX, sourceY, dir);\r\n        return this;\r\n    }\r\n    getWarpFlags(sourceX, sourceY) {\r\n        let ret = geom.CardinalDirectionFlags.NONE;\r\n        geom.CARDINAL_DIRECTIONS.forEach((dir) => {\r\n            if (this._getWarp(sourceX, sourceY, dir)) {\r\n                ret = geom.cardinalDirectionFlagsSetCardinalDirection(ret, dir);\r\n            }\r\n        });\r\n        return ret;\r\n    }\r\n    getWarpFlag(sourceX, sourceY, dir) {\r\n        return !!this._getWarp(sourceX, sourceY, dir);\r\n    }\r\n    getWarpTargetMap(sourceX, sourceY, dir) {\r\n        var _a;\r\n        return (_a = this._getWarp(sourceX, sourceY, dir)) === null || _a === void 0 ? void 0 : _a.map;\r\n    }\r\n    getWarpTargetOffset(sourceX, sourceY, dir) {\r\n        var _a;\r\n        const shift = (_a = this._getWarp(sourceX, sourceY, dir)) === null || _a === void 0 ? void 0 : _a.offsetShift;\r\n        if (shift) {\r\n            LOCAL_OFF.copyFrom(shift)\r\n                .add(sourceX, sourceY)\r\n                .addCardinalDirection(dir);\r\n            return { x: LOCAL_OFF.x, y: LOCAL_OFF.y };\r\n        }\r\n        return undefined;\r\n    }\r\n    // internal\r\n    index(x, y) {\r\n        return this._size.index(x, y);\r\n    }\r\n    _addFlag(x, y, flag) {\r\n        const index = this.index(x, y);\r\n        this._tileFlags[index] |= flag;\r\n    }\r\n    _removeFlag(x, y, flag) {\r\n        const index = this.index(x, y);\r\n        this._tileFlags[index] &= ~flag;\r\n    }\r\n    _makeWarp(map, offsetShiftX, offsetShiftY) {\r\n        const id = this._warps.length;\r\n        this._warps.push({\r\n            map,\r\n            offsetShift: new geom.Offset(offsetShiftX, offsetShiftY),\r\n        });\r\n        return id;\r\n    }\r\n    _findOrMakeWarp(map, offsetShift) {\r\n        for (let fid = 0; fid < this._warps.length; fid++) {\r\n            const fwarp = this._warps[fid];\r\n            if (fwarp.map === map && fwarp.offsetShift.equals(offsetShift)) {\r\n                return fid;\r\n            }\r\n        }\r\n        return this._makeWarp(map, offsetShift.x, offsetShift.y);\r\n    }\r\n    _addWarp(x, y, dir, warpId) {\r\n        const index = this.index(x, y);\r\n        this._tileWarpIds[dir][index] = warpId;\r\n    }\r\n    _removeWarp(x, y, dir) {\r\n        const index = this.index(x, y);\r\n        delete this._tileWarpIds[dir][index];\r\n    }\r\n    _getWarp(x, y, dir) {\r\n        const index = this.index(x, y);\r\n        return this.getWarpAtIndex(index, dir);\r\n    }\r\n    contains(x, y) {\r\n        return this._size.contains(x, y);\r\n    }\r\n    getTileFlagsAtIndex(index) {\r\n        return this._tileFlags[index];\r\n    }\r\n    getWarpAtIndex(index, dir) {\r\n        const warpId = this._tileWarpIds[dir][index];\r\n        if (warpId === -1) {\r\n            return undefined;\r\n        }\r\n        else {\r\n            return this._warps[warpId];\r\n        }\r\n    }\r\n}\r\nexports.FieldOfViewMap = FieldOfViewMap;\r\n","\"use strict\";\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n});\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.TileFlags = void 0;\r\nconst geom = __importStar(require(\"tiled-geometry\"));\r\n/**\r\n * These flags determine whether a given tile has walls in any of the cardinal\r\n * directions, and whether there is a \"body\" in the tile.\r\n */\r\nvar TileFlags;\r\n(function (TileFlags) {\r\n    TileFlags[TileFlags[\"NONE\"] = 0] = \"NONE\";\r\n    TileFlags[TileFlags[\"WALL_NORTH\"] = 1] = \"WALL_NORTH\";\r\n    TileFlags[TileFlags[\"WALL_EAST\"] = 2] = \"WALL_EAST\";\r\n    TileFlags[TileFlags[\"WALL_WEST\"] = 8] = \"WALL_WEST\";\r\n    TileFlags[TileFlags[\"WALL_SOUTH\"] = 4] = \"WALL_SOUTH\";\r\n    TileFlags[TileFlags[\"BODY\"] = 1 << geom.CARDINAL_DIRECTIONS.length] = \"BODY\";\r\n})(TileFlags = exports.TileFlags || (exports.TileFlags = {}));\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.WarpDataCache = void 0;\r\nclass WarpDataCache {\r\n    constructor() {\r\n        this._data = {};\r\n    }\r\n    get(map, warpCount, shiftX, shiftY) {\r\n        let wcData = this._data[map.id];\r\n        if (!wcData) {\r\n            this._data[map.id] = wcData = {};\r\n        }\r\n        let mapData = wcData[warpCount];\r\n        if (!mapData) {\r\n            wcData[warpCount] = mapData = {};\r\n        }\r\n        let yData = mapData[shiftY];\r\n        if (!yData) {\r\n            mapData[shiftY] = yData = {};\r\n        }\r\n        let data = yData[shiftX];\r\n        if (data) {\r\n            return data;\r\n        }\r\n        yData[shiftX] = data = {\r\n            map,\r\n            warpCount,\r\n            shiftX,\r\n            shiftY,\r\n        };\r\n        return data;\r\n    }\r\n}\r\nexports.WarpDataCache = WarpDataCache;\r\n","\"use strict\";\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n});\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.mergeWedges = exports.addWarp = exports.addShadow = exports.getBestWedge = exports.initWedges = void 0;\r\nconst constants = __importStar(require(\"./constants\"));\r\nfunction initWedges(warp) {\r\n    return [{\r\n            low: 0,\r\n            high: Number.POSITIVE_INFINITY,\r\n            shadow: false,\r\n            warp,\r\n        }];\r\n}\r\nexports.initWedges = initWedges;\r\nfunction getBestWedge(wedges, low, middle, high) {\r\n    let bestWedge;\r\n    let bestDist = Number.POSITIVE_INFINITY;\r\n    for (const wedge of wedges) {\r\n        if (wedge.low >= high) {\r\n            break;\r\n        }\r\n        if (wedge.high <= low) {\r\n            continue;\r\n        }\r\n        const curDist = Math.max(middle - wedge.high, wedge.low - middle);\r\n        if (!bestWedge || wedgeIsBetter(bestWedge, wedge, bestDist, curDist)) {\r\n            bestWedge = wedge;\r\n            bestDist = curDist;\r\n        }\r\n    }\r\n    // istanbul ignore next\r\n    if (!bestWedge) {\r\n        throw new Error(`[bug] no wedge found`);\r\n    }\r\n    return bestWedge;\r\n}\r\nexports.getBestWedge = getBestWedge;\r\nfunction wedgeIsBetter(target, candidate, targetDist, candidateDist) {\r\n    // prefer visible wedges\r\n    if (target.shadow !== candidate.shadow) {\r\n        return target.shadow;\r\n    }\r\n    // prefer wedges closer to the target\r\n    if (candidateDist > targetDist + constants.PICK_WEDGE_EPSILON) {\r\n        return false;\r\n    }\r\n    if (targetDist > candidateDist + constants.PICK_WEDGE_EPSILON) {\r\n        return true;\r\n    }\r\n    // two wedges are close\r\n    // use the one with the lowest warp count\r\n    if (candidate.warp.warpCount !== target.warp.warpCount) {\r\n        return candidate.warp.warpCount < target.warp.warpCount;\r\n    }\r\n    // they have the same warp count\r\n    // use the one with the lowest map id\r\n    if (candidate.warp.map.id !== target.warp.map.id) {\r\n        return candidate.warp.map.id < target.warp.map.id;\r\n    }\r\n    // they have the same map id\r\n    // arbitrarily pick one based on the offsets\r\n    // at this point it doesn't really matter how we choose but we want to be deterministic\r\n    if (candidate.warp.shiftY !== target.warp.shiftY) {\r\n        return candidate.warp.shiftY < target.warp.shiftY;\r\n    }\r\n    if (candidate.warp.shiftX !== target.warp.shiftX) {\r\n        return candidate.warp.shiftX < target.warp.shiftX;\r\n    }\r\n    return false;\r\n}\r\nfunction addShadow(wedge, low, high) {\r\n    if (wedge.shadow || high <= wedge.low || low >= wedge.high) {\r\n        return [wedge];\r\n    }\r\n    if (low <= wedge.low) {\r\n        if (high >= wedge.high) {\r\n            // wedge is entirely in shadow\r\n            wedge.shadow = true;\r\n            return [wedge];\r\n        }\r\n        else {\r\n            // low part of wedge is in shadow, split it\r\n            const newWedge = Object.assign(Object.assign({}, wedge), { shadow: true, high });\r\n            wedge.low = high;\r\n            return [newWedge, wedge];\r\n        }\r\n    }\r\n    else if (high >= wedge.high) {\r\n        // high part of wedge is in shadow, split it\r\n        const newWedge = Object.assign(Object.assign({}, wedge), { shadow: true, low });\r\n        wedge.high = low;\r\n        return [wedge, newWedge];\r\n    }\r\n    else {\r\n        // middle part of wedge is in shadow, split it\r\n        return [Object.assign(Object.assign({}, wedge), { high: low }), Object.assign(Object.assign({}, wedge), { shadow: true, low, high }), Object.assign(Object.assign({}, wedge), { low: high })];\r\n    }\r\n}\r\nexports.addShadow = addShadow;\r\nfunction addWarp(wedge, warp, low, high) {\r\n    if (wedge.warp === warp || high <= wedge.low || low >= wedge.high) {\r\n        return [wedge];\r\n    }\r\n    if (low <= wedge.low) {\r\n        if (high >= wedge.high) {\r\n            // wedge is entirely in warp\r\n            wedge.warp = warp;\r\n            return [wedge];\r\n        }\r\n        else {\r\n            // low part of wedge is in warp, split it\r\n            const newWedge = Object.assign(Object.assign({}, wedge), { warp, high });\r\n            wedge.low = high;\r\n            return [newWedge, wedge];\r\n        }\r\n    }\r\n    else if (high >= wedge.high) {\r\n        // high part of wedge is in warp, split it\r\n        const newWedge = Object.assign(Object.assign({}, wedge), { warp, low });\r\n        wedge.high = low;\r\n        return [wedge, newWedge];\r\n    }\r\n    else {\r\n        // middle part of wedge is in warp, split it\r\n        return [Object.assign(Object.assign({}, wedge), { high: low }), Object.assign(Object.assign({}, wedge), { warp, low, high }), Object.assign(Object.assign({}, wedge), { low: high })];\r\n    }\r\n}\r\nexports.addWarp = addWarp;\r\nfunction mergeWedges(wedges) {\r\n    // istanbul ignore next\r\n    if (wedges.length === 0) {\r\n        throw new Error(`[bug] no wedges`);\r\n    }\r\n    if (wedges.length === 1) {\r\n        return wedges;\r\n    }\r\n    const ret = [];\r\n    for (const wedge of wedges) {\r\n        if (ret.length === 0 || !wedgesMatch(ret[ret.length - 1], wedge)) {\r\n            ret.push(wedge);\r\n        }\r\n        else {\r\n            ret[ret.length - 1].high = wedge.high;\r\n        }\r\n    }\r\n    return ret;\r\n}\r\nexports.mergeWedges = mergeWedges;\r\nfunction wedgesMatch(a, b) {\r\n    return a.shadow === b.shadow && a.warp === b.warp;\r\n}\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\"use strict\";\r\n/*\r\n *  WarpField\r\n *  github.com/sbj42/warp-field\r\n *  James Clark\r\n *  Licensed under the MIT license.\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Offset = exports.CardinalDirectionFlags = exports.CardinalDirection = exports.computeFieldOfView = exports.FieldOfViewMap = void 0;\r\nvar field_of_view_map_1 = require(\"./field-of-view-map\");\r\nObject.defineProperty(exports, \"FieldOfViewMap\", { enumerable: true, get: function () { return field_of_view_map_1.FieldOfViewMap; } });\r\nvar compute_1 = require(\"./compute\");\r\nObject.defineProperty(exports, \"computeFieldOfView\", { enumerable: true, get: function () { return compute_1.computeFieldOfView; } });\r\nvar tiled_geometry_1 = require(\"tiled-geometry\");\r\nObject.defineProperty(exports, \"CardinalDirection\", { enumerable: true, get: function () { return tiled_geometry_1.CardinalDirection; } });\r\nObject.defineProperty(exports, \"CardinalDirectionFlags\", { enumerable: true, get: function () { return tiled_geometry_1.CardinalDirectionFlags; } });\r\nObject.defineProperty(exports, \"Offset\", { enumerable: true, get: function () { return tiled_geometry_1.Offset; } });\r\n"],"names":[],"sourceRoot":""}