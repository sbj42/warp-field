{"version":3,"sources":["webpack://WarpField/webpack/bootstrap","webpack://WarpField/./src/geom/index.ts","webpack://WarpField/./src/index.ts","webpack://WarpField/./src/warp-rect.ts","webpack://WarpField/./src/fov-util.ts","webpack://WarpField/./src/geom/mask-rect.ts","webpack://WarpField/./src/geom/mask.ts","webpack://WarpField/./src/geom/rectangle.ts","webpack://WarpField/./src/geom/size.ts","webpack://WarpField/./src/geom/offset.ts","webpack://WarpField/./src/geom/direction-flags.ts","webpack://WarpField/./src/geom/direction.ts","webpack://WarpField/./src/field-of-view.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","__export","field_of_view_1","FieldOfViewMap","warp_rect_1","WarpRect","geom_1","Direction","DirectionFlags","Offset","geom","LOCAL_OFF","rect","initialValue","outsideValue","this","_rectangle","Rectangle","copyFrom","_mask","Mask","_warps","Array","area","_warpsToString","ret","off","y","height","x","width","set","addOffset","northWest","getMask","warp","_getWarp","map","id","_getWarpAt","index","toString","westX","northY","subtractOffset","getMaskAt","getAt","containsOffset","getMapIdAt","getMap","getOffsetAt","offset","getOffset","setAt","rangeToString","low","high","toFixed","wedgeToString","wedge","wedgesToString","wedges","join","TileFlag","DIRECTIONS","length","BODY_EPSILON","WALL_EPSILON","WARP_EPSILON","DEBUG_CUTWEDGE","cutWedge","console","info","nextWedge","warpCount","cutWedges","_i","wedges_1","push","apply","DEBUG_WARPWEDGE","warpWedge","middleWedge","highWedge","warpWedges","wedges_2","whichWedge","wedgeIndex","centerSlope","cur","Math","abs","MaskRect","_outsideValue","size","_size","Size","_bits","fill","equals","other","empty","extendToInclude","dx","dy","containsRectangle","add","overlapsRectangle","southY","eastX","multiply","factor","X_FROM_DIRECTION","Y_FROM_DIRECTION","max","setFromDirection","dir","addSize","addDirection","addCardinalDirection","distanceChebyshev","magnitudeChebyshev","distanceManhattan","magnitudeManhattan","directionFlagsToString","flags","NORTH","EAST","SOUTH","WEST","directionFlagsFromDirection","DIRECTIONS_STR","directionToString","directionOpposite","fov_util_1","_1","addEdgeWalls","_this","_tileFlags","_addFlag","WALL_WEST","WALL_EAST","WALL_NORTH","WALL_SOUTH","_tileWarpIds","flag","_removeFlag","_getFlag","_findOrMakeWarp","fid","fwarp","_addWarp","warpId","_removeWarp","addWall","oneWay","removeWall","getWalls","ALL","addBody","BODY","removeBody","getBody","addWarp","sourceX","sourceY","targetMap","targetX","targetY","removeWarp","getWarpFlags","forEach","getFieldOfView","chebyshevRadius","origin","boundRect","mask","undefined","_quadrant","xDir","yDir","startX","startY","endDXY","farYFlag","farXFlag","yWarpDir","yWarps","xWarpDir","xWarps","startMapIndex","startMaskIndex","Number","POSITIVE_INFINITY","yMapIndex","yMaskIndex","divYpos","divYneg","divYmid","mapIndex","maskIndex","slopeY","slopeX","slopeFar","slopeMid","centerWedge","wedgeIndexInner","newWedges","wallY","wallX","body","warpY","warpX","nextWarpCount","splice","concat"],"mappings":"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","file":"warp-field-1.0.0.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/bin/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","export * from './direction';\r\nexport * from './direction-flags';\r\nexport * from './offset';\r\nexport * from './size';\r\nexport * from './rectangle';\r\nexport * from './mask';\r\nexport * from './mask-rect';\r\n","/*\r\n *  WarpField\r\n *  github.com/sbj42/warp-field\r\n *  James Clark\r\n *  Licensed under the MIT license.\r\n */\r\n\r\nexport {FieldOfViewMap} from './field-of-view';\r\nexport {Warp} from './fov-util';\r\nexport {WarpRect} from './warp-rect';\r\nexport {Direction, DirectionFlags, Offset} from './geom';\r\n","import * as geom from './geom';\r\nimport {FieldOfViewMap} from '.';\r\n\r\nconst LOCAL_OFF = new geom.Offset();\r\n\r\nexport interface Warp {\r\n    map: FieldOfViewMap;\r\n    offset: geom.Offset;\r\n}\r\n\r\nimport {Offset} from './geom';\r\n\r\nexport class WarpRect implements geom.RectangleLike {\r\n    private readonly _rectangle = new geom.Rectangle();\r\n    private readonly _mask: geom.Mask;\r\n    private readonly _warps: Warp[];\r\n\r\n    constructor(rect: geom.RectangleLike, initialValue = false, outsideValue = false) {\r\n        this._rectangle.copyFrom(rect);\r\n        this._mask = new geom.Mask(rect, initialValue);\r\n        this._warps = new Array<Warp>(this._rectangle.area);\r\n    }\r\n\r\n    private _warpsToString() {\r\n        let ret = '';\r\n        const off = new geom.Offset();\r\n        for (let y = 0; y < this._rectangle.height; y ++) {\r\n            for (let x = 0; x < this._rectangle.width; x ++) {\r\n                off.set(x, y).addOffset(this._rectangle.northWest);\r\n                if (this.getMask(off.x, off.y)) {\r\n                    const warp = this._getWarp(off);\r\n                    if (typeof warp === 'undefined') {\r\n                        ret += '-';\r\n                    } else {\r\n                        ret += warp.map.id[0];\r\n                    }\r\n                } else {\r\n                    ret += '.';\r\n                }\r\n            }\r\n            ret += '\\n';\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    private _getWarpAt(index: number) {\r\n        return this._warps[index];\r\n    }\r\n\r\n    private _getWarp(off: geom.OffsetLike) {\r\n        return this._warps[this._rectangle.index(off)];\r\n    }\r\n\r\n    // accessors\r\n\r\n    toString() {\r\n        return `${this._rectangle.northWest}\\n${this._warpsToString()}`;\r\n    }\r\n\r\n    get westX() {\r\n        return this._rectangle.westX;\r\n    }\r\n\r\n    get northY() {\r\n        return this._rectangle.northY;\r\n    }\r\n\r\n    get width() {\r\n        return this._rectangle.width;\r\n    }\r\n\r\n    get height() {\r\n        return this._rectangle.height;\r\n    }\r\n\r\n    index(x: number, y: number) {\r\n        LOCAL_OFF.set(x, y).subtractOffset(this._rectangle.northWest);\r\n        return this._mask.index(LOCAL_OFF);\r\n    }\r\n\r\n    getMaskAt(index: number) {\r\n        return this._mask.getAt(index);\r\n    }\r\n\r\n    getMask(x: number, y: number) {\r\n        LOCAL_OFF.set(x, y);\r\n        if (!this._rectangle.containsOffset(LOCAL_OFF)) {\r\n            return false;\r\n        }\r\n        return this._mask.getAt(this._rectangle.index(LOCAL_OFF));\r\n    }\r\n\r\n    getMapIdAt(index: number) {\r\n        const warp = this._getWarpAt(index);\r\n        if (warp) {\r\n            return warp.map;\r\n        } else {\r\n            return undefined;\r\n        }\r\n    }\r\n\r\n    getMap(x: number, y: number) {\r\n        LOCAL_OFF.set(x, y);\r\n        const warp = this._getWarp(LOCAL_OFF);\r\n        if (warp) {\r\n            return warp.map;\r\n        } else {\r\n            return undefined;\r\n        }\r\n    }\r\n\r\n    getOffsetAt(index: number): Offset {\r\n        const warp = this._getWarpAt(index);\r\n        if (warp) {\r\n            return warp.offset;\r\n        } else {\r\n            return undefined;\r\n        }\r\n    }\r\n\r\n    getOffset(x: number, y: number): Offset {\r\n        LOCAL_OFF.set(x, y);\r\n        const warp = this._getWarp(LOCAL_OFF);\r\n        if (warp) {\r\n            return warp.offset;\r\n        } else {\r\n            return undefined;\r\n        }\r\n    }\r\n\r\n    // mutators\r\n\r\n    setAt(index: number, value: boolean, warp: Warp) {\r\n        this._mask.setAt(index, value);\r\n        this._warps[index] = warp;\r\n        return this;\r\n    }\r\n\r\n    set(off: geom.OffsetLike, value: boolean, warp: Warp) {\r\n        this._mask.setAt(this._rectangle.index(off), value);\r\n        this._warps[this._rectangle.index(off)] = warp;\r\n        return this;\r\n    }\r\n}\r\n","import * as geom from './geom';\r\nimport {FieldOfViewMap} from '.';\r\n\r\n// tslint:disable:no-bitwise\r\n\r\n/**\r\n * These flags determine whether a given tile has walls in any of the cardinal\r\n * directions, and whether there is a \"body\" in the tile.\r\n */\r\nexport enum TileFlag {\r\n    WALL_NORTH = 1 << geom.Direction.NORTH,\r\n    WALL_EAST  = 1 << geom.Direction.EAST,\r\n    WALL_WEST  = 1 << geom.Direction.WEST,\r\n    WALL_SOUTH = 1 << geom.Direction.SOUTH,\r\n    BODY       = 1 << geom.DIRECTIONS.length,\r\n}\r\n\r\nexport interface Warp {\r\n    map: FieldOfViewMap;\r\n    offset: geom.Offset;\r\n}\r\n\r\n/**\r\n * In the shadowcasting algorithm, each shadow is represented by a \"wedge\",\r\n * running from a \"low\" angle to a \"high\" angle.  To support warps, we also\r\n * track for each wedge a map (if we've gone through a warp), and an offset\r\n * (the location within the target map relative to the player's location in\r\n * the source map).\r\n */\r\nexport interface Wedge {\r\n    low: number;\r\n    high: number;\r\n    warp: Warp | undefined;\r\n    warpCount: number;\r\n}\r\n\r\nfunction rangeToString(low: number, high: number) {\r\n    return `${low.toFixed(7)}-${high.toFixed(7)}`;\r\n}\r\n\r\nfunction wedgeToString(wedge: Wedge) {\r\n    return `{${rangeToString(wedge.low, wedge.high)}`\r\n        + `${typeof wedge.warp !== 'undefined' ? `~${wedge.warp.map.id}` : ''}}`;\r\n}\r\n\r\nfunction wedgesToString(wedges: Wedge[]) {\r\n    return `[${wedges.map(wedgeToString).join(', ')}]`;\r\n}\r\n\r\n/**\r\n * Bodies in this algorithm do not entirely fill their tiles.  This is\r\n * implemented by adjusting the angles of the shadows the bodies cast,\r\n * making the wedge very slightly narrower.  BODY_EPSILON represents the\r\n * amount of reduction on either side of the wedge.\r\n */\r\nexport const BODY_EPSILON = 0.00001;\r\n\r\n/**\r\n * Walls do fill the entire tile edge.  With infinite precision, there would be\r\n * no need to adjust the shadow cast by a wall.  But we're using floating point\r\n * math here, which means imprecision can creep in and cause angles not to line\r\n * up properly.  To fix that, we widen the wedges of the shadows cast by walls.\r\n * We must make sure not to widen them as much as we narrow the body shadows,\r\n * or else they might close the gap we want between a body and a wall.\r\n */\r\nexport const WALL_EPSILON = BODY_EPSILON / 4;\r\n\r\n/**\r\n * Warps also fill the entire tile edge.  But we don't extend warps as much as\r\n * walls, just in case a sliver of warp might make it past a wall on the other\r\n * side of the warp, at the edge of the warp range.\r\n */\r\nexport const WARP_EPSILON = WALL_EPSILON / 4;\r\n\r\nconst DEBUG_CUTWEDGE: boolean = false;\r\n\r\n/**\r\n * This function cuts a range of angles out of a wedge.\r\n */\r\nexport function cutWedge(wedge: Wedge, low: number, high: number): Wedge[] {\r\n    if (DEBUG_CUTWEDGE) {\r\n        // tslint:disable-next-line:no-console\r\n        console.info(`cut ${wedgeToString(wedge)} ${rangeToString(low, high)}`);\r\n    }\r\n    let ret: Wedge[];\r\n    if (low <= wedge.low) {\r\n        if (high >= wedge.high) {\r\n            // wedge is entirely occluded, remove it\r\n            ret = [];\r\n        } else if (high >= wedge.low) {\r\n            // low part of wedge is occluded, trim it\r\n            wedge.low = high;\r\n            ret = [wedge];\r\n        } else {\r\n            // cut doesn't reach the wedge\r\n            ret = [wedge];\r\n        }\r\n    } else if (high >= wedge.high) {\r\n        if (low <= wedge.high) {\r\n            // high part of wedge is occluded, trim it\r\n            wedge.high = low;\r\n            ret = [wedge];\r\n        } else {\r\n            // cut doesn't reach the wedge\r\n            ret = [wedge];\r\n        }\r\n    } else {\r\n        // middle part of wedge is occluded, split it\r\n        const nextWedge = {\r\n            low: high,\r\n            high: wedge.high,\r\n            warp: wedge.warp,\r\n            warpCount: wedge.warpCount,\r\n        };\r\n        wedge.high = low;\r\n        ret = [wedge, nextWedge];\r\n    }\r\n    if (DEBUG_CUTWEDGE) {\r\n        // tslint:disable-next-line:no-console\r\n        console.info(`--> ${wedgesToString(ret)}`);\r\n    }\r\n    return ret;\r\n}\r\n\r\nexport function cutWedges(wedges: Wedge[], low: number, high: number): Wedge[] {\r\n    const ret = new Array<Wedge>();\r\n    for (const wedge of wedges) {\r\n        ret.push(...cutWedge(wedge, low, high));\r\n    }\r\n    return ret;\r\n}\r\n\r\nconst DEBUG_WARPWEDGE: boolean = false;\r\n\r\nexport function warpWedge(wedge: Wedge, low: number, high: number, warp: Warp, warpCount: number): Wedge[] {\r\n    if (DEBUG_WARPWEDGE) {\r\n        // tslint:disable-next-line:no-console\r\n        console.info(`warp ${wedgeToString(wedge)} ${rangeToString(low, high)} ${warp.map.id}`);\r\n    }\r\n    let ret: Wedge[];\r\n    if (low <= wedge.low) {\r\n        if (high >= wedge.high) {\r\n            // wedge is entirely warped\r\n            wedge.warp = warp;\r\n            wedge.warpCount = warpCount;\r\n            ret = [wedge];\r\n        } else if (high >= wedge.low) {\r\n            // low part of wedge is warped, split it into two\r\n            const nextWedge = {\r\n                low: high,\r\n                high: wedge.high,\r\n                warp: wedge.warp,\r\n                warpCount: wedge.warpCount,\r\n            };\r\n            wedge.high = high;\r\n            wedge.warp = warp;\r\n            wedge.warpCount = warpCount;\r\n            ret = [wedge, nextWedge];\r\n        } else {\r\n            // warp doesn't reach the wedge\r\n            ret = [wedge];\r\n        }\r\n    } else if (high >= wedge.high) {\r\n        if (low <= wedge.high) {\r\n            // high part of wedge is occluded, split it into two\r\n            const nextWedge = {\r\n                low,\r\n                high: wedge.high,\r\n                warp,\r\n                warpCount,\r\n            };\r\n            wedge.high = low;\r\n            ret = [wedge, nextWedge];\r\n        } else {\r\n            // warp doesn't reach the wedge\r\n            ret = [wedge];\r\n        }\r\n    } else {\r\n        // middle part of wedge is occluded, split it into three\r\n        const middleWedge = {\r\n            low,\r\n            high,\r\n            warp,\r\n            warpCount,\r\n        };\r\n        const highWedge = {\r\n            low: high,\r\n            high: wedge.high,\r\n            warp: wedge.warp,\r\n            warpCount: wedge.warpCount,\r\n        };\r\n        wedge.high = low;\r\n        ret = [wedge, middleWedge, highWedge];\r\n    }\r\n    if (DEBUG_WARPWEDGE) {\r\n        // tslint:disable-next-line:no-console\r\n        console.info(`--> ${wedgesToString(ret)}`);\r\n    }\r\n    return ret;\r\n}\r\n\r\nexport function warpWedges(wedges: Wedge[], low: number, high: number, warp: Warp, warpCount: number): Wedge[] {\r\n    const ret = new Array<Wedge>();\r\n    for (const wedge of wedges) {\r\n        ret.push(...warpWedge(wedge, low, high, warp, warpCount));\r\n    }\r\n    return ret;\r\n}\r\n\r\nexport function whichWedge(wedges: Wedge[], wedgeIndex: number, centerSlope: number) {\r\n    // determine the wedge containing centerSlope,\r\n    // or if there isn't one, then the one nearest to centerSlope\r\n    // or if two are very close, the one with the least warp count\r\n    // or if they both have the same warp count, the one with the lowest map id\r\n    let cur = wedgeIndex;\r\n    // skip to the next wedge while it starts before before centerSlope\r\n    while (cur < wedges.length - 1 && wedges[cur + 1].low < centerSlope - WALL_EPSILON * 2) {\r\n        cur ++;\r\n    }\r\n    if (cur >= wedges.length - 1 || wedges[cur].high > centerSlope + WALL_EPSILON * 2) {\r\n        // the current wedge contains centerSlope or is past it, so this is the closest\r\n        return cur;\r\n    } else if (wedges[cur].high < centerSlope - WALL_EPSILON * 2) {\r\n        // the current wedge isn't very close to centerSlope\r\n        // choose the closest one\r\n        if (Math.abs(wedges[cur].high - centerSlope) < Math.abs(wedges[cur + 1].low - centerSlope)) {\r\n            return cur;\r\n        } else {\r\n            return cur + 1;\r\n        }\r\n    } else {\r\n        // the current wedge is very close to centerSlope\r\n        if (wedges[cur + 1].low < centerSlope + WALL_EPSILON * 2) {\r\n            // the next wedge is very close to centerSlope too\r\n            // compare warp counts\r\n            if (wedges[cur].warpCount < wedges[cur + 1].warpCount) {\r\n                return cur;\r\n            } else if (wedges[cur].warpCount > wedges[cur + 1].warpCount) {\r\n                return cur + 1;\r\n            } else {\r\n                // same warp count\r\n                // compare map ids\r\n                if (wedges[cur].warp.map.id < wedges[cur + 1].warp.map.id) {\r\n                    return cur;\r\n                } else {\r\n                    return cur + 1;\r\n                }\r\n            }\r\n        } else {\r\n            // the next wedge isn't very close to centerSlope, use the current one\r\n            return cur;\r\n        }\r\n    }\r\n}\r\n","import * as geom from '.';\r\n\r\nconst LOCAL_OFF = new geom.Offset();\r\n\r\nexport class MaskRect implements geom.RectangleLike {\r\n    private readonly _rectangle = new geom.Rectangle();\r\n    private readonly _mask: geom.Mask;\r\n    private readonly _outsideValue: boolean;\r\n\r\n    constructor(rect: geom.RectangleLike, initialValue = false, outsideValue = false) {\r\n        this._rectangle.copyFrom(rect);\r\n        this._mask = new geom.Mask(rect, initialValue);\r\n        this._outsideValue = outsideValue;\r\n    }\r\n\r\n    // accessors\r\n\r\n    toString() {\r\n        return `${this._rectangle.northWest}/${this._outsideValue}\\n${this._mask}`;\r\n    }\r\n\r\n    get westX() {\r\n        return this._rectangle.westX;\r\n    }\r\n\r\n    get northY() {\r\n        return this._rectangle.northY;\r\n    }\r\n\r\n    get width() {\r\n        return this._rectangle.width;\r\n    }\r\n\r\n    get height() {\r\n        return this._rectangle.height;\r\n    }\r\n\r\n    index(off: geom.OffsetLike) {\r\n        return this._mask.index(LOCAL_OFF.copyFrom(off).subtractOffset(this._rectangle.northWest));\r\n    }\r\n\r\n    getAt(index: number) {\r\n        return this._mask.getAt(index);\r\n    }\r\n\r\n    get(off: geom.OffsetLike) {\r\n        if (!this._rectangle.containsOffset(off)) {\r\n            return this._outsideValue;\r\n        }\r\n        return this._mask.getAt(this._rectangle.index(off));\r\n    }\r\n\r\n    // mutators\r\n\r\n    setAt(index: number, value: boolean) {\r\n        this._mask.setAt(index, value);\r\n        return this;\r\n    }\r\n\r\n    set(off: geom.OffsetLike, value: boolean) {\r\n        this._mask.setAt(this._rectangle.index(off), value);\r\n        return this;\r\n    }\r\n}\r\n","import * as geom from '.';\r\n\r\nexport class Mask implements geom.SizeLike {\r\n    private readonly _size = new geom.Size();\r\n    private readonly _bits: boolean[];\r\n    // TODO consider Uint8Array for bits\r\n\r\n    constructor(size: geom.SizeLike, initialValue = false) {\r\n        this._size.copyFrom(size);\r\n        this._bits = new Array<boolean>(this._size.area).fill(initialValue);\r\n    }\r\n\r\n    // accessors\r\n\r\n    toString() {\r\n        let ret = '';\r\n        const off = new geom.Offset();\r\n        for (let y = 0; y < this._size.height; y ++) {\r\n            for (let x = 0; x < this._size.width; x ++) {\r\n                off.set(x, y);\r\n                ret += this.get(off.set(x, y)) ? '☑' : '☐';\r\n            }\r\n            ret += '\\n';\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    get width() {\r\n        return this._size.width;\r\n    }\r\n\r\n    get height() {\r\n        return this._size.height;\r\n    }\r\n\r\n    index(off: geom.OffsetLike) {\r\n        return this._size.index(off);\r\n    }\r\n\r\n    getAt(index: number) {\r\n        return this._bits[index];\r\n    }\r\n\r\n    get(off: geom.OffsetLike) {\r\n        return this.getAt(this.index(off));\r\n    }\r\n\r\n    // mutators\r\n\r\n    setAt(index: number, value: boolean) {\r\n        this._bits[index] = value;\r\n        return this;\r\n    }\r\n\r\n    set(off: geom.OffsetLike, value: boolean) {\r\n        return this.setAt(this.index(off), value);\r\n    }\r\n}\r\n","import * as geom from '.';\r\n\r\nexport interface RectangleLike extends geom.SizeLike {\r\n    readonly westX: number;\r\n    readonly northY: number;\r\n}\r\n\r\nconst LOCAL_OFF = new geom.Offset();\r\n\r\nexport class Rectangle implements RectangleLike, geom.SizeLike {\r\n    northWest: geom.Offset;\r\n    size: geom.Size;\r\n\r\n    constructor();\r\n    constructor(westX: number, northY: number, width: number, height: number);\r\n    constructor(westX?: number, northY?: number, width?: number, height?: number) {\r\n        if (typeof westX === 'undefined') {\r\n            westX = 0;\r\n        }\r\n        if (typeof northY === 'undefined') {\r\n            northY = 0;\r\n        }\r\n        if (typeof width === 'undefined') {\r\n            width = 0;\r\n        }\r\n        if (typeof height === 'undefined') {\r\n            height = 0;\r\n        }\r\n        this.northWest = new geom.Offset(westX, northY);\r\n        this.size = new geom.Size(width, height);\r\n    }\r\n\r\n    // accessors\r\n\r\n    toString() {\r\n        return `(${this.westX},${this.northY} ${this.width}x${this.height})`;\r\n    }\r\n\r\n    equals(other: RectangleLike) {\r\n        return this.westX === other.westX && this.northY === other.northY && this.size.equals(other);\r\n    }\r\n\r\n    get northY() {\r\n        return this.northWest.y;\r\n    }\r\n\r\n    get southY() {\r\n        return this.northWest.y + this.size.height - 1;\r\n    }\r\n\r\n    get westX() {\r\n        return this.northWest.x;\r\n    }\r\n\r\n    get eastX() {\r\n        return this.northWest.x + this.size.width - 1;\r\n    }\r\n\r\n    get width() {\r\n        return this.size.width;\r\n    }\r\n\r\n    get height() {\r\n        return this.size.height;\r\n    }\r\n\r\n    get empty() {\r\n        return this.size.empty;\r\n    }\r\n\r\n    get area() {\r\n        return this.size.area;\r\n    }\r\n\r\n    // mutators\r\n\r\n    set(westX: number, northY: number, width: number, height: number) {\r\n        this.northWest.set(westX, northY);\r\n        this.size.set(width, height);\r\n        return this;\r\n    }\r\n\r\n    copyFrom(other: RectangleLike) {\r\n        this.northWest.set(other.westX, other.northY);\r\n        this.size.set(other.width, other.height);\r\n        return this;\r\n    }\r\n\r\n    extendToInclude(off: geom.OffsetLike) {\r\n        const dx = off.x - this.westX;\r\n        if (dx < 0) {\r\n            this.size.width -= dx;\r\n            this.northWest.x = off.x;\r\n        } else if (dx >= this.size.width) {\r\n            this.size.width = dx + 1;\r\n        }\r\n        const dy = off.y - this.northWest.y;\r\n        if (dy < 0) {\r\n            this.size.height -= dy;\r\n            this.northWest.y = off.y;\r\n        } else if (dy >= this.size.height) {\r\n            this.size.height = dy + 1;\r\n        }\r\n        return this;\r\n    }\r\n\r\n    // utilities\r\n\r\n    containsOffset(off: geom.OffsetLike) {\r\n        return this.size.containsOffset(LOCAL_OFF.copyFrom(off).subtractOffset(this.northWest));\r\n    }\r\n\r\n    containsRectangle(other: RectangleLike) {\r\n        LOCAL_OFF.set(other.westX, other.northY).subtractOffset(this.northWest);\r\n        if (!this.size.containsOffset(LOCAL_OFF)) {\r\n            return false;\r\n        }\r\n        if (other.width === 0 && other.height === 0) {\r\n            return false;\r\n        }\r\n        return this.size.containsOffset(LOCAL_OFF.add(other.width - 1, other.height - 1));\r\n    }\r\n\r\n    overlapsRectangle(other: RectangleLike) {\r\n        return this.northY <= other.northY + other.height - 1\r\n            && this.southY >= other.northY\r\n            && this.westX <= other.westX + other.width - 1\r\n            && this.eastX >= other.westX\r\n            && !this.empty\r\n            && other.width !== 0 && other.height !== 0;\r\n    }\r\n\r\n    index(off: geom.OffsetLike) {\r\n        return this.size.index(LOCAL_OFF.copyFrom(off).subtractOffset(this.northWest));\r\n    }\r\n}\r\n","import * as geom from '.';\r\n\r\nexport interface SizeLike {\r\n    readonly width: number;\r\n    readonly height: number;\r\n}\r\n\r\nexport class Size implements SizeLike {\r\n    width: number;\r\n    height: number;\r\n\r\n    constructor();\r\n    constructor(width: number, height: number);\r\n    constructor(width?: number, height?: number) {\r\n        if (typeof width === 'undefined') {\r\n            width = 0;\r\n        }\r\n        if (typeof height === 'undefined') {\r\n            height = 0;\r\n        }\r\n        this.width = width;\r\n        this.height = height;\r\n    }\r\n\r\n    // accessors\r\n\r\n    toString() {\r\n        return `(${this.width}x${this.height})`;\r\n    }\r\n\r\n    equals(other: SizeLike) {\r\n        return this.width === other.width && this.height === other.height;\r\n    }\r\n\r\n    get empty() {\r\n        return this.width === 0 || this.height === 0;\r\n    }\r\n\r\n    get area() {\r\n        return this.width * this.height;\r\n    }\r\n\r\n    // mutators\r\n\r\n    set(width: number, height: number) {\r\n        this.width = width;\r\n        this.height = height;\r\n        return this;\r\n    }\r\n\r\n    copyFrom(other: SizeLike) {\r\n        this.width = other.width;\r\n        this.height = other.height;\r\n        return this;\r\n    }\r\n\r\n    add(width: number, height: number) {\r\n        this.width += width;\r\n        this.height += height;\r\n        return this;\r\n    }\r\n\r\n    addOffset(off: geom.OffsetLike) {\r\n        this.width += off.x;\r\n        this.height += off.y;\r\n        return this;\r\n    }\r\n\r\n    multiply(factor: number) {\r\n        this.width *= factor;\r\n        this.height *= factor;\r\n        return this;\r\n    }\r\n\r\n    // TODO: rotate\r\n\r\n    // utilities\r\n\r\n    containsOffset(off: geom.OffsetLike) {\r\n        return off.x >= 0 && off.y >= 0 && off.x < this.width && off.y < this.height;\r\n    }\r\n\r\n    index(off: geom.OffsetLike) {\r\n        return off.y * this.width + off.x;\r\n    }\r\n}\r\n","import * as geom from '.';\r\n\r\nconst X_FROM_DIRECTION = [  0, 1, 0, -1 ];\r\nconst Y_FROM_DIRECTION = [ -1, 0, 1,  0 ];\r\n\r\nexport interface OffsetLike {\r\n    readonly x: number;\r\n    readonly y: number;\r\n}\r\n\r\nexport class Offset implements OffsetLike {\r\n    x: number;\r\n    y: number;\r\n\r\n    constructor();\r\n    constructor(x: number, y: number);\r\n    constructor(x?: number, y?: number) {\r\n        if (typeof x === 'undefined') {\r\n            x = 0;\r\n        }\r\n        if (typeof y === 'undefined') {\r\n            y = 0;\r\n        }\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n\r\n    // accessors\r\n\r\n    toString() {\r\n        return `(${this.x},${this.y})`;\r\n    }\r\n\r\n    equals(other: OffsetLike) {\r\n        return this.x === other.x && this.y === other.y;\r\n    }\r\n\r\n    // chebyshev: can move in any direction (diagonals are ok)\r\n    get magnitudeChebyshev() {\r\n        return Math.max(Math.abs(this.x), Math.abs(this.y));\r\n    }\r\n\r\n    // manhattan: can move only in cardinal directions (no diagonals)\r\n    get magnitudeManhattan(): number {\r\n        return Math.abs(this.x) + Math.abs(this.y);\r\n    }\r\n\r\n    // mutators\r\n\r\n    set(x: number, y: number) {\r\n        this.x = x;\r\n        this.y = y;\r\n        return this;\r\n    }\r\n\r\n    copyFrom(other: OffsetLike) {\r\n        this.x = other.x;\r\n        this.y = other.y;\r\n        return this;\r\n    }\r\n\r\n    setFromDirection(dir: geom.Direction) {\r\n        this.x = X_FROM_DIRECTION[dir];\r\n        this.y = Y_FROM_DIRECTION[dir];\r\n        return this;\r\n    }\r\n\r\n    add(x: number, y: number) {\r\n        this.x += x;\r\n        this.y += y;\r\n        return this;\r\n    }\r\n\r\n    addSize(size: geom.SizeLike) {\r\n        this.x += size.width;\r\n        this.y += size.height;\r\n        return this;\r\n    }\r\n\r\n    addOffset(off: OffsetLike) {\r\n        this.x += off.x;\r\n        this.y += off.y;\r\n        return this;\r\n    }\r\n\r\n    addDirection(dir: geom.Direction) {\r\n        this.x += X_FROM_DIRECTION[dir];\r\n        this.y += Y_FROM_DIRECTION[dir];\r\n        return this;\r\n    }\r\n\r\n    addCardinalDirection(dir: geom.Direction) {\r\n        this.x += X_FROM_DIRECTION[dir];\r\n        this.y += Y_FROM_DIRECTION[dir];\r\n        return this;\r\n    }\r\n\r\n    subtractOffset(off: OffsetLike) {\r\n        this.x -= off.x;\r\n        this.y -= off.y;\r\n        return this;\r\n    }\r\n\r\n    multiply(factor: number) {\r\n        this.x *= factor;\r\n        this.y *= factor;\r\n        return this;\r\n    }\r\n\r\n    // utilities\r\n\r\n    // chebyshev: can move in any direction (diagonals are ok)\r\n    distanceChebyshev(other: OffsetLike) {\r\n        return this.subtractOffset(other).magnitudeChebyshev;\r\n    }\r\n\r\n    // manhattan: can move only in cardinal directions (no diagonals)\r\n    distanceManhattan(other?: OffsetLike): number {\r\n        return this.subtractOffset(other).magnitudeManhattan;\r\n    }\r\n}\r\n","import * as geom from '.';\r\n\r\n// tslint:disable:no-bitwise\r\n\r\nexport enum DirectionFlags {\r\n    NONE  = 0,\r\n    NORTH = 1,\r\n    EAST  = 2,\r\n    SOUTH = 4,\r\n    WEST  = 8,\r\n    ALL   = 15,\r\n}\r\n\r\nexport function directionFlagsToString(flags: DirectionFlags) {\r\n    let ret = '[';\r\n    if ((flags & DirectionFlags.NORTH) !== 0) {\r\n        ret += 'N';\r\n    }\r\n    if ((flags & DirectionFlags.EAST) !== 0) {\r\n        ret += 'E';\r\n    }\r\n    if ((flags & DirectionFlags.SOUTH) !== 0) {\r\n        ret += 'S';\r\n    }\r\n    if ((flags & DirectionFlags.WEST) !== 0) {\r\n        ret += 'W';\r\n    }\r\n    return ret + ']';\r\n}\r\n\r\n// conversion\r\n\r\nexport function directionFlagsFromDirection(dir: geom.Direction) {\r\n    return (1 << dir) as DirectionFlags;\r\n}\r\n","// tslint:disable:no-bitwise\r\n\r\nexport enum Direction {\r\n    NORTH = 0,\r\n    EAST  = 1,\r\n    SOUTH = 2,\r\n    WEST  = 3,\r\n}\r\n\r\nexport const DIRECTIONS = [\r\n    Direction.NORTH,\r\n    Direction.EAST,\r\n    Direction.SOUTH,\r\n    Direction.WEST,\r\n];\r\n\r\nconst DIRECTIONS_STR = [\r\n    'N',\r\n    'E',\r\n    'S',\r\n    'W',\r\n];\r\n\r\nexport function directionToString(dir: Direction) {\r\n    return DIRECTIONS_STR[dir];\r\n}\r\n\r\nexport function directionOpposite(dir: Direction) {\r\n    return ((dir + 2) & 3) as Direction;\r\n}\r\n","import * as geom from './geom';\r\nimport {\r\n    TileFlag,\r\n    Warp,\r\n    Wedge,\r\n    WALL_EPSILON,\r\n    BODY_EPSILON,\r\n    WARP_EPSILON,\r\n    cutWedges,\r\n    warpWedges,\r\n    whichWedge,\r\n} from './fov-util';\r\nimport {WarpRect} from '.';\r\n\r\n// tslint:disable:no-bitwise\r\n\r\n/**\r\n * We avoid heap allocations during the core part of the algorithm by using this\r\n * preallocated offset object.\r\n */\r\nconst LOCAL_OFF = new geom.Offset();\r\n\r\n/**\r\n * The FieldOFViewMap represents the map over which the field of view will be\r\n * computed.  It starts out empty.  You can add walls and bodies to it, and then\r\n * use getFieldOfView() to compute the field of view from a given point.\r\n */\r\nexport class FieldOfViewMap {\r\n    readonly id: string;\r\n    private readonly _size = new geom.Size();\r\n    private readonly _tileFlags: number[];\r\n\r\n    private readonly _warps = new Array<Warp>();\r\n    private readonly _tileWarpIds: number[][];\r\n\r\n    constructor(id: string, width: number, height: number, addEdgeWalls = false) {\r\n        this.id = id;\r\n        this._size.set(width, height);\r\n        this._tileFlags = new Array<number>(this._size.area).fill(0);\r\n        if (addEdgeWalls) {\r\n            for (let y = 0; y < this._size.height; y ++) {\r\n                this._addFlag(LOCAL_OFF.set(0, y), TileFlag.WALL_WEST);\r\n                this._addFlag(LOCAL_OFF.set(this._size.width - 1, y), TileFlag.WALL_EAST);\r\n            }\r\n            for (let x = 0; x < this._size.width; x ++) {\r\n                this._addFlag(LOCAL_OFF.set(x, 0), TileFlag.WALL_NORTH);\r\n                this._addFlag(LOCAL_OFF.set(x, this._size.height - 1), TileFlag.WALL_SOUTH);\r\n            }\r\n        }\r\n        this._tileWarpIds = geom.DIRECTIONS.map(() => new Array<number>(this._size.area).fill(-1));\r\n    }\r\n\r\n    private _addFlag(off: geom.OffsetLike, flag: TileFlag) {\r\n        const index = this._size.index(off);\r\n        this._tileFlags[index] |= flag;\r\n    }\r\n\r\n    private _removeFlag(off: geom.OffsetLike, flag: TileFlag) {\r\n        const index = this._size.index(off);\r\n        this._tileFlags[index] &= ~flag;\r\n    }\r\n\r\n    private _getFlag(off: geom.OffsetLike, flag: TileFlag) {\r\n        const index = this._size.index(off);\r\n        return (this._tileFlags[index] & flag) !== 0;\r\n    }\r\n\r\n    private _findOrMakeWarp(map: FieldOfViewMap, offset: geom.OffsetLike) {\r\n        for (let fid = 0; fid < this._warps.length; fid ++) {\r\n            const fwarp = this._warps[fid];\r\n            if (fwarp.map === map && fwarp.offset.equals(offset)) {\r\n                return fid;\r\n            }\r\n        }\r\n        const warp = {\r\n            map,\r\n            offset: new geom.Offset().copyFrom(offset),\r\n        };\r\n        const id = this._warps.length;\r\n        this._warps.push(warp);\r\n        return id;\r\n    }\r\n\r\n    private _addWarp(off: geom.OffsetLike, dir: geom.Direction, warpId: number) {\r\n        const index = this._size.index(off);\r\n        this._tileWarpIds[dir][index] = warpId;\r\n    }\r\n\r\n    private _removeWarp(off: geom.OffsetLike, dir: geom.Direction) {\r\n        const index = this._size.index(off);\r\n        delete this._tileWarpIds[dir][index];\r\n    }\r\n\r\n    private _getWarp(off: geom.OffsetLike, dir: geom.Direction) {\r\n        const index = this._size.index(off);\r\n        const warpId = this._tileWarpIds[dir][index];\r\n        if (warpId === -1) {\r\n            return undefined;\r\n        } else {\r\n            return this._warps[warpId];\r\n        }\r\n    }\r\n\r\n    // setup and maintenance\r\n\r\n    /**\r\n     * Adds a wall at a particular edge.  This automatically adds the\r\n     * corresponding wall on the other side.\r\n     */\r\n    addWall(x: number, y: number, dir: geom.Direction, oneWay = false) {\r\n        LOCAL_OFF.set(x, y);\r\n        this._addFlag(LOCAL_OFF, 1 << dir);\r\n        LOCAL_OFF.addCardinalDirection(dir);\r\n        if (!oneWay && this._size.containsOffset(LOCAL_OFF)) {\r\n            this._addFlag(LOCAL_OFF, 1 << geom.directionOpposite(dir));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes a wall at a particular edge.  This automatically removes the\r\n     * corresponding wall on the other side.\r\n     */\r\n    removeWall(x: number, y: number, dir: geom.Direction, oneWay = false) {\r\n        LOCAL_OFF.set(x, y);\r\n        this._removeFlag(LOCAL_OFF, 1 << dir);\r\n        LOCAL_OFF.addCardinalDirection(dir);\r\n        if (!oneWay && this._size.containsOffset(LOCAL_OFF)) {\r\n            this._removeFlag(LOCAL_OFF, 1 << geom.directionOpposite(dir));\r\n        }\r\n    }\r\n\r\n    getWalls(x: number, y: number) {\r\n        LOCAL_OFF.set(x, y);\r\n        const index = this._size.index(LOCAL_OFF);\r\n        return this._tileFlags[index] & geom.DirectionFlags.ALL;\r\n    }\r\n\r\n    addBody(x: number, y: number) {\r\n        LOCAL_OFF.set(x, y);\r\n        this._addFlag(LOCAL_OFF, TileFlag.BODY);\r\n    }\r\n\r\n    removeBody(x: number, y: number) {\r\n        LOCAL_OFF.set(x, y);\r\n        this._removeFlag(LOCAL_OFF, TileFlag.BODY);\r\n    }\r\n\r\n    getBody(x: number, y: number) {\r\n        LOCAL_OFF.set(x, y);\r\n        const index = this._size.index(LOCAL_OFF);\r\n        return this._tileFlags[index] & TileFlag.BODY;\r\n    }\r\n\r\n    // TODO add length argument\r\n    addWarp(sourceX: number, sourceY: number, dir: geom.Direction,\r\n            targetMap: FieldOfViewMap, targetX: number, targetY: number) {\r\n        LOCAL_OFF.set(targetX - sourceX, targetY - sourceY)\r\n                .addCardinalDirection(geom.directionOpposite(dir));\r\n        const warpId = this._findOrMakeWarp(targetMap, LOCAL_OFF);\r\n        LOCAL_OFF.set(sourceX, sourceY);\r\n        this._addWarp(LOCAL_OFF, dir, warpId);\r\n    }\r\n\r\n    // TODO add length argument\r\n    removeWarp(sourceX: number, sourceY: number, dir: geom.Direction) {\r\n        LOCAL_OFF.set(sourceX, sourceY);\r\n        this._removeWarp(LOCAL_OFF, dir);\r\n    }\r\n\r\n    getWarpFlags(sourceX: number, sourceY: number) {\r\n        LOCAL_OFF.set(sourceX, sourceY);\r\n        let ret = 0;\r\n        geom.DIRECTIONS.forEach((dir) => {\r\n            if (this._getWarp(LOCAL_OFF, dir)) {\r\n                ret |= 1 << dir;\r\n            }\r\n        });\r\n        return ret;\r\n    }\r\n\r\n    // execution\r\n\r\n    /**\r\n     * Compute the field of view for a camera at the given tile.\r\n     * chebyshevRadius is the vision radius.  It uses chebyshev distance\r\n     * (https://en.wikipedia.org/wiki/Chebyshev_distance), which just means\r\n     * that the limit of vision in a large empty field will be square.\r\n     *\r\n     * This returns a MaskRect, which indicates which tiles are visible.\r\n     * maskRect.get(x, y) will return true for visible tiles.\r\n     */\r\n    getFieldOfView(x: number, y: number, chebyshevRadius: number) {\r\n        const origin = new geom.Offset(x, y);\r\n        const boundRect = new geom.Rectangle().set(\r\n            origin.x - chebyshevRadius, origin.y - chebyshevRadius,\r\n            chebyshevRadius * 2 + 1, chebyshevRadius * 2 + 1,\r\n        );\r\n        const mask = new WarpRect(boundRect);\r\n        // the player can always see itself\r\n        mask.set(origin, true, undefined);\r\n        // the field is divided into quadrants\r\n        this._quadrant(mask, origin, chebyshevRadius, -1, -1);\r\n        this._quadrant(mask, origin, chebyshevRadius,  1, -1);\r\n        this._quadrant(mask, origin, chebyshevRadius, -1,  1);\r\n        this._quadrant(mask, origin, chebyshevRadius,  1,  1);\r\n        return mask;\r\n    }\r\n\r\n    private _quadrant(mask: WarpRect, origin: geom.OffsetLike, chebyshevRadius: number,\r\n                      xDir: number, yDir: number) {\r\n        const {x: startX, y: startY} = origin;\r\n        const endDXY = (chebyshevRadius + 1);\r\n        if (endDXY < 0 || !this._size.containsOffset(origin)) {\r\n            return;\r\n        }\r\n        const farYFlag = [TileFlag.WALL_NORTH, TileFlag.WALL_SOUTH][(yDir + 1) / 2];\r\n        const farXFlag = [TileFlag.WALL_WEST, TileFlag.WALL_EAST][(xDir + 1) / 2];\r\n        const yWarpDir = [geom.Direction.NORTH, geom.Direction.SOUTH][(yDir + 1) / 2];\r\n        const yWarps = this._tileWarpIds[yWarpDir];\r\n        const xWarpDir = [geom.Direction.WEST, geom.Direction.EAST][(xDir + 1) / 2];\r\n        const xWarps = this._tileWarpIds[xWarpDir];\r\n        const startMapIndex = this._size.index(origin);\r\n        const startMaskIndex = mask.index(origin.x, origin.y);\r\n        // Initial wedge is from slope zero to slope infinity (i.e. the whole quadrant)\r\n        const wedges = [{\r\n            low: 0,\r\n            high: Number.POSITIVE_INFINITY,\r\n            warp: undefined,\r\n            warpCount: 0,\r\n        } as Wedge];\r\n        // X += Y must be written as X = X + Y, in order not to trigger deoptimization due to\r\n        // http://stackoverflow.com/questions/34595356/what-does-compound-let-const-assignment-mean\r\n        for (let dy = 0, yMapIndex = startMapIndex, yMaskIndex = startMaskIndex;\r\n             dy !== endDXY && wedges.length > 0;\r\n             dy ++, yMapIndex = yMapIndex + yDir * this._size.width, yMaskIndex = yMaskIndex + yDir * mask.width\r\n        ) {\r\n            const divYpos = 1 / (dy + 0.5);\r\n            const divYneg = dy === 0 ? Number.POSITIVE_INFINITY : 1 / (dy - 0.5);\r\n            const divYmid = 1 / dy;\r\n            let wedgeIndex = 0;\r\n            // X += Y must be written as X = X + Y, in order not to trigger deoptimization due to\r\n            // http://stackoverflow.com/questions/34595356/what-does-compound-let-const-assignment-mean\r\n            for (let dx = 0, mapIndex = yMapIndex, maskIndex = yMaskIndex,\r\n                 slopeY = -0.5 * divYpos, slopeX = 0.5 * divYneg,\r\n                 slopeFar = 0.5 * divYpos, slopeMid = 0;\r\n                 dx !== endDXY && wedgeIndex !== wedges.length;\r\n                 dx ++, mapIndex = mapIndex + xDir, maskIndex = maskIndex + xDir,\r\n                 slopeY = slopeY + divYpos, slopeX = slopeX + divYneg,\r\n                 slopeFar = slopeFar + divYpos, slopeMid = slopeMid + divYmid\r\n            ) {\r\n                // the slopes of the four corners of this tile\r\n                // these are named as follows:\r\n                //   slopeY is the slope closest to the Y axis\r\n                //   slopeFar is the slope to the farthest corner\r\n                //   slopeMid is the slope to the center\r\n                //   slopeX is the slope closest to the X axis\r\n                // these are always true:\r\n                //   slopeY < slopeFar < slopeX\r\n                //   slopeY < slopeMid < slopeX\r\n                //\r\n                // O = origin, C = current\r\n                // +---+---+---+\r\n                // | O |   |   |\r\n                // +---+---+---X\r\n                // |   |   | C |\r\n                // +---+---Y---F\r\n\r\n                // the walls of this tile\r\n                // these are named as follows:\r\n                //   wallY is the farthest horizontal wall (slopeY to slopeFar)\r\n                //   wallX is the farthest vertical wall (slopeFar to slopeX)\r\n                //\r\n                // O = origin, C = current\r\n                // +---+---+---+\r\n                // | O |   |   |\r\n                // +---+---+---+\r\n                // |   |   | C X\r\n                // +---+---+-Y-+\r\n\r\n                // advance the wedge index until this tile is not after the current wedge\r\n                while (slopeY >= wedges[wedgeIndex].high) {\r\n                    wedgeIndex ++;\r\n                    if (wedgeIndex >= wedges.length) {\r\n                        break;\r\n                    }\r\n                }\r\n                if (wedgeIndex >= wedges.length) {\r\n                    break;\r\n                }\r\n\r\n                // if the current wedge is after this tile, move on\r\n                if (slopeX <= wedges[wedgeIndex].low) {\r\n                    continue;\r\n                }\r\n\r\n                {\r\n                    const centerWedge = whichWedge(wedges, wedgeIndex, slopeMid);\r\n                    mask.setAt(maskIndex, true, wedges[centerWedge].warp);\r\n                }\r\n\r\n                {\r\n                    let wedgeIndexInner = wedgeIndex;\r\n                    while (wedgeIndexInner < wedges.length && slopeX > wedges[wedgeIndexInner].low) {\r\n                        let newWedges = [wedges[wedgeIndexInner]];\r\n                        const {warp} = wedges[wedgeIndexInner];\r\n                        let wallY: boolean;\r\n                        let wallX: boolean;\r\n                        let body: boolean;\r\n                        let warpY: Warp;\r\n                        let warpX: Warp;\r\n                        const nextWarpCount = wedges[wedgeIndexInner].warpCount + 1;\r\n\r\n                        if (typeof warp === 'undefined') {\r\n                            wallY = (this._tileFlags[mapIndex] & farYFlag) !== 0;\r\n                            wallX = (this._tileFlags[mapIndex] & farXFlag) !== 0;\r\n                            body = (dx !== 0 || dy !== 0) && (this._tileFlags[mapIndex] & TileFlag.BODY) !== 0;\r\n                            warpY = this._warps[yWarps[mapIndex]];\r\n                            warpX = this._warps[xWarps[mapIndex]];\r\n                        } else {\r\n                            const {map, offset} = warp;\r\n                            LOCAL_OFF.copyFrom(offset).add(startX + dx * xDir, startY + dy * yDir);\r\n                            wallY = map._getFlag(LOCAL_OFF, farYFlag);\r\n                            wallX = map._getFlag(LOCAL_OFF, farXFlag);\r\n                            body = (dx !== 0 || dy !== 0) && map._getFlag(LOCAL_OFF, TileFlag.BODY);\r\n                            warpY = map._getWarp(LOCAL_OFF, yWarpDir);\r\n                            warpX = map._getWarp(LOCAL_OFF, xWarpDir);\r\n                        }\r\n\r\n                        if (wallX && wallY) {\r\n                            // this tile has both far walls\r\n                            // so we can't see beyond it and the whole range should be cut out of the wedge(s)\r\n                            newWedges = cutWedges(newWedges, slopeY - WALL_EPSILON, slopeX + WALL_EPSILON);\r\n                        } else if (wallX) {\r\n                            if (typeof warpY !== 'undefined') {\r\n                                newWedges = warpWedges(newWedges,\r\n                                    slopeY - WARP_EPSILON, slopeFar + WARP_EPSILON, warpY, nextWarpCount);\r\n                            }\r\n                            if (body) {\r\n                                newWedges = cutWedges(newWedges,\r\n                                    slopeY + BODY_EPSILON, slopeX + WALL_EPSILON);\r\n                            } else {\r\n                                newWedges = cutWedges(newWedges,\r\n                                    slopeFar - WALL_EPSILON, slopeX + WALL_EPSILON);\r\n                            }\r\n                        } else if (wallY) {\r\n                            if (body) {\r\n                                newWedges = cutWedges(newWedges,\r\n                                    slopeY - WALL_EPSILON, slopeX - BODY_EPSILON);\r\n                            } else {\r\n                                newWedges = cutWedges(newWedges,\r\n                                    slopeY - WALL_EPSILON, slopeFar + WALL_EPSILON);\r\n                            }\r\n                            if (typeof warpX !== 'undefined') {\r\n                                newWedges = warpWedges(newWedges,\r\n                                    slopeFar - WARP_EPSILON, slopeX + WARP_EPSILON, warpX, nextWarpCount);\r\n                            }\r\n                        } else {\r\n                            if (typeof warpY !== 'undefined') {\r\n                                newWedges = warpWedges(newWedges,\r\n                                    slopeY - WARP_EPSILON, slopeFar + WARP_EPSILON, warpY, nextWarpCount);\r\n                            }\r\n                            if (body) {\r\n                                newWedges = cutWedges(newWedges,\r\n                                    slopeY + BODY_EPSILON, slopeX - BODY_EPSILON);\r\n                            }\r\n                            if (typeof warpX !== 'undefined') {\r\n                                newWedges = warpWedges(newWedges,\r\n                                    slopeFar - WARP_EPSILON, slopeX + WARP_EPSILON, warpX, nextWarpCount);\r\n                            }\r\n                        }\r\n\r\n                        if (newWedges.length !== 1) {\r\n                            wedges.splice(wedgeIndexInner, 1, ...newWedges);\r\n                        }\r\n                        // X += Y must be written as X = X + Y, in order not to trigger deoptimization due to\r\n                        // http://stackoverflow.com/questions/34595356/what-does-compound-let-const-assignment-mean\r\n                        wedgeIndexInner = wedgeIndexInner + newWedges.length;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n"],"sourceRoot":""}