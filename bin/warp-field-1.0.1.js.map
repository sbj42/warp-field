{"version":3,"sources":["webpack://WarpField/webpack/bootstrap","webpack://WarpField/./src/geom/index.ts","webpack://WarpField/./src/index.ts","webpack://WarpField/./src/warp-rect.ts","webpack://WarpField/./src/fov-util.ts","webpack://WarpField/./src/geom/mask.ts","webpack://WarpField/./src/geom/rectangle.ts","webpack://WarpField/./src/geom/size.ts","webpack://WarpField/./src/geom/offset.ts","webpack://WarpField/./src/geom/direction-flags.ts","webpack://WarpField/./src/geom/direction.ts","webpack://WarpField/./src/field-of-view.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","__export","field_of_view_1","FieldOfViewMap","warp_rect_1","WarpRect","geom_1","Direction","DirectionFlags","Offset","geom","LOCAL_OFF","rect","initialValue","this","_rectangle","Rectangle","copyFrom","_mask","Mask","_warps","Array","area","_warpsToString","ret","off","y","height","x","width","set","addOffset","northWest","getMask","warp","_getWarp","map","id","_getWarpAt","index","toString","westX","northY","subtractOffset","getMaskAt","getAt","containsOffset","getMapAt","getMap","getOffsetAt","offset","getOffset","setAt","rangeToString","low","high","toFixed","wedgeToString","wedge","wedgesToString","wedges","join","TileFlag","DIRECTIONS","length","BODY_EPSILON","WALL_EPSILON","WARP_EPSILON","DEBUG_CUTWEDGE","cutWedge","console","info","nextWedge","warpCount","cutWedges","_i","wedges_1","push","apply","DEBUG_WARPWEDGE","warpWedge","middleWedge","highWedge","warpWedges","wedges_2","whichWedge","wedgeIndex","centerSlope","cur","Math","abs","size","_size","Size","_bits","fill","equals","other","empty","extendToInclude","dx","dy","containsRectangle","add","overlapsRectangle","southY","eastX","multiply","factor","X_FROM_DIRECTION","Y_FROM_DIRECTION","max","setFromDirection","dir","addSize","addDirection","addCardinalDirection","distanceChebyshev","magnitudeChebyshev","distanceManhattan","magnitudeManhattan","directionFlagsToString","flags","NORTH","EAST","SOUTH","WEST","directionFlagsFromDirection","DIRECTIONS_STR","directionToString","directionOpposite","fov_util_1","_1","addEdgeWalls","_this","_tileFlags","_addFlag","WALL_WEST","WALL_EAST","WALL_NORTH","WALL_SOUTH","_tileWarpIds","flag","_removeFlag","_getFlag","_findOrMakeWarp","fid","fwarp","_addWarp","warpId","_removeWarp","addWall","oneWay","removeWall","getWalls","ALL","getWall","addBody","BODY","removeBody","getBody","addWarp","sourceX","sourceY","targetMap","targetX","targetY","removeWarp","getWarpFlags","forEach","getWarpFlag","getFieldOfView","chebyshevRadius","origin","boundRect","mask","undefined","_quadrant","xDir","yDir","startX","startY","endDXY","farYFlag","farXFlag","yWarpDir","yWarps","xWarpDir","xWarps","startMapIndex","startMaskIndex","Number","POSITIVE_INFINITY","yMapIndex","yMaskIndex","divYpos","divYneg","divYmid","mapIndex","maskIndex","slopeY","slopeX","slopeFar","slopeMid","centerWedge","wedgeIndexInner","newWedges","wallY","wallX","body","warpY","warpX","nextWarpCount","splice","concat"],"mappings":"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","file":"warp-field-1.0.1.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/bin/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","export * from './direction';\r\nexport * from './direction-flags';\r\nexport * from './offset';\r\nexport * from './size';\r\nexport * from './rectangle';\r\nexport * from './mask';\r\n","/*\r\n *  WarpField\r\n *  github.com/sbj42/warp-field\r\n *  James Clark\r\n *  Licensed under the MIT license.\r\n */\r\n\r\nexport {FieldOfViewMap} from './field-of-view';\r\nexport {Warp} from './fov-util';\r\nexport {WarpRect} from './warp-rect';\r\nexport {Direction, DirectionFlags, Offset} from './geom';\r\n","import * as geom from './geom';\r\nimport {FieldOfViewMap} from '.';\r\n\r\nconst LOCAL_OFF = new geom.Offset();\r\n\r\nexport interface Warp {\r\n    map: FieldOfViewMap;\r\n    offset: geom.Offset;\r\n}\r\n\r\nimport {Offset} from './geom';\r\n\r\nexport class WarpRect implements geom.RectangleLike {\r\n    private readonly _rectangle = new geom.Rectangle();\r\n    private readonly _mask: geom.Mask;\r\n    private readonly _warps: Warp[];\r\n\r\n    constructor(rect: geom.RectangleLike, initialValue = false) {\r\n        this._rectangle.copyFrom(rect);\r\n        this._mask = new geom.Mask(rect, initialValue);\r\n        this._warps = new Array<Warp>(this._rectangle.area);\r\n    }\r\n\r\n    private _warpsToString() {\r\n        let ret = '';\r\n        const off = new geom.Offset();\r\n        for (let y = 0; y < this._rectangle.height; y ++) {\r\n            for (let x = 0; x < this._rectangle.width; x ++) {\r\n                off.set(x, y).addOffset(this._rectangle.northWest);\r\n                if (this.getMask(off.x, off.y)) {\r\n                    const warp = this._getWarp(off);\r\n                    if (typeof warp === 'undefined') {\r\n                        ret += '-';\r\n                    } else {\r\n                        ret += warp.map.id[0];\r\n                    }\r\n                } else {\r\n                    ret += '.';\r\n                }\r\n            }\r\n            ret += '\\n';\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    private _getWarpAt(index: number) {\r\n        return this._warps[index];\r\n    }\r\n\r\n    private _getWarp(off: geom.OffsetLike) {\r\n        return this._warps[this._rectangle.index(off)];\r\n    }\r\n\r\n    // accessors\r\n\r\n    toString() {\r\n        return `${this._rectangle.northWest}\\n${this._warpsToString()}`;\r\n    }\r\n\r\n    get westX() {\r\n        return this._rectangle.westX;\r\n    }\r\n\r\n    get northY() {\r\n        return this._rectangle.northY;\r\n    }\r\n\r\n    get width() {\r\n        return this._rectangle.width;\r\n    }\r\n\r\n    get height() {\r\n        return this._rectangle.height;\r\n    }\r\n\r\n    index(x: number, y: number) {\r\n        LOCAL_OFF.set(x, y).subtractOffset(this._rectangle.northWest);\r\n        return this._mask.index(LOCAL_OFF);\r\n    }\r\n\r\n    getMaskAt(index: number) {\r\n        return this._mask.getAt(index);\r\n    }\r\n\r\n    getMask(x: number, y: number) {\r\n        LOCAL_OFF.set(x, y);\r\n        if (!this._rectangle.containsOffset(LOCAL_OFF)) {\r\n            return false;\r\n        }\r\n        return this._mask.getAt(this._rectangle.index(LOCAL_OFF));\r\n    }\r\n\r\n    getMapAt(index: number) {\r\n        const warp = this._getWarpAt(index);\r\n        if (warp) {\r\n            return warp.map;\r\n        } else {\r\n            return undefined;\r\n        }\r\n    }\r\n\r\n    getMap(x: number, y: number) {\r\n        LOCAL_OFF.set(x, y);\r\n        const warp = this._getWarp(LOCAL_OFF);\r\n        if (warp) {\r\n            return warp.map;\r\n        } else {\r\n            return undefined;\r\n        }\r\n    }\r\n\r\n    getOffsetAt(index: number): Offset {\r\n        const warp = this._getWarpAt(index);\r\n        if (warp) {\r\n            return warp.offset;\r\n        } else {\r\n            return undefined;\r\n        }\r\n    }\r\n\r\n    getOffset(x: number, y: number): Offset {\r\n        LOCAL_OFF.set(x, y);\r\n        const warp = this._getWarp(LOCAL_OFF);\r\n        if (warp) {\r\n            return warp.offset;\r\n        } else {\r\n            return undefined;\r\n        }\r\n    }\r\n\r\n    // mutators\r\n\r\n    setAt(index: number, value: boolean, warp: Warp | undefined) {\r\n        this._mask.setAt(index, value);\r\n        this._warps[index] = warp;\r\n        return this;\r\n    }\r\n\r\n    set(off: geom.OffsetLike, value: boolean, warp: Warp | undefined) {\r\n        this._mask.setAt(this._rectangle.index(off), value);\r\n        this._warps[this._rectangle.index(off)] = warp;\r\n        return this;\r\n    }\r\n}\r\n","import * as geom from './geom';\r\nimport {FieldOfViewMap} from '.';\r\n\r\n// tslint:disable:no-bitwise\r\n\r\n/**\r\n * These flags determine whether a given tile has walls in any of the cardinal\r\n * directions, and whether there is a \"body\" in the tile.\r\n */\r\nexport enum TileFlag {\r\n    WALL_NORTH = 1 << geom.Direction.NORTH,\r\n    WALL_EAST  = 1 << geom.Direction.EAST,\r\n    WALL_WEST  = 1 << geom.Direction.WEST,\r\n    WALL_SOUTH = 1 << geom.Direction.SOUTH,\r\n    BODY       = 1 << geom.DIRECTIONS.length,\r\n}\r\n\r\nexport interface Warp {\r\n    map: FieldOfViewMap;\r\n    offset: geom.Offset;\r\n}\r\n\r\n/**\r\n * In the shadowcasting algorithm, each shadow is represented by a \"wedge\",\r\n * running from a \"low\" angle to a \"high\" angle.  To support warps, we also\r\n * track for each wedge a map (if we've gone through a warp), and an offset\r\n * (the location within the target map relative to the player's location in\r\n * the source map).\r\n */\r\nexport interface Wedge {\r\n    low: number;\r\n    high: number;\r\n    warp: Warp | undefined;\r\n    warpCount: number;\r\n}\r\n\r\n// istanbul ignore next\r\nfunction rangeToString(low: number, high: number) {\r\n    return `${low.toFixed(7)}-${high.toFixed(7)}`;\r\n}\r\n\r\n// istanbul ignore next\r\nfunction wedgeToString(wedge: Wedge) {\r\n    return `{${rangeToString(wedge.low, wedge.high)}`\r\n        + `${typeof wedge.warp !== 'undefined' ? `~${wedge.warp.map.id}` : ''}}`;\r\n}\r\n\r\n// istanbul ignore next\r\nfunction wedgesToString(wedges: Wedge[]) {\r\n    return `[${wedges.map(wedgeToString).join(', ')}]`;\r\n}\r\n\r\n/**\r\n * Bodies in this algorithm do not entirely fill their tiles.  This is\r\n * implemented by adjusting the angles of the shadows the bodies cast,\r\n * making the wedge very slightly narrower.  BODY_EPSILON represents the\r\n * amount of reduction on either side of the wedge.\r\n */\r\nexport const BODY_EPSILON = 0.00001;\r\n\r\n/**\r\n * Walls do fill the entire tile edge.  With infinite precision, there would be\r\n * no need to adjust the shadow cast by a wall.  But we're using floating point\r\n * math here, which means imprecision can creep in and cause angles not to line\r\n * up properly.  To fix that, we widen the wedges of the shadows cast by walls.\r\n * We must make sure not to widen them as much as we narrow the body shadows,\r\n * or else they might close the gap we want between a body and a wall.\r\n */\r\nexport const WALL_EPSILON = BODY_EPSILON / 4;\r\n\r\n/**\r\n * Warps also fill the entire tile edge.  But we don't extend warps as much as\r\n * walls, just in case a sliver of warp might make it past a wall on the other\r\n * side of the warp, at the edge of the warp range.\r\n */\r\nexport const WARP_EPSILON = WALL_EPSILON / 4;\r\n\r\nconst DEBUG_CUTWEDGE: boolean = false;\r\n\r\n/**\r\n * This function cuts a range of angles out of a wedge.\r\n */\r\nexport function cutWedge(wedge: Wedge, low: number, high: number): Wedge[] {\r\n    if (DEBUG_CUTWEDGE) {\r\n        // istanbul ignore next\r\n        // tslint:disable-next-line:no-console\r\n        console.info(`cut ${wedgeToString(wedge)} ${rangeToString(low, high)}`);\r\n    }\r\n    let ret: Wedge[];\r\n    if (low <= wedge.low) {\r\n        if (high >= wedge.high) {\r\n            // wedge is entirely occluded, remove it\r\n            ret = [];\r\n        } else if (high >= wedge.low) {\r\n            // low part of wedge is occluded, trim it\r\n            wedge.low = high;\r\n            ret = [wedge];\r\n        } else {\r\n            // cut doesn't reach the wedge\r\n            ret = [wedge];\r\n        }\r\n    } else if (high >= wedge.high) {\r\n        if (low <= wedge.high) {\r\n            // high part of wedge is occluded, trim it\r\n            wedge.high = low;\r\n            ret = [wedge];\r\n        } else {\r\n            // cut doesn't reach the wedge\r\n            ret = [wedge];\r\n        }\r\n    } else {\r\n        // middle part of wedge is occluded, split it\r\n        const nextWedge = {\r\n            low: high,\r\n            high: wedge.high,\r\n            warp: wedge.warp,\r\n            warpCount: wedge.warpCount,\r\n        };\r\n        wedge.high = low;\r\n        ret = [wedge, nextWedge];\r\n    }\r\n    if (DEBUG_CUTWEDGE) {\r\n        // istanbul ignore next\r\n        // tslint:disable-next-line:no-console\r\n        console.info(`--> ${wedgesToString(ret)}`);\r\n    }\r\n    return ret;\r\n}\r\n\r\nexport function cutWedges(wedges: Wedge[], low: number, high: number): Wedge[] {\r\n    const ret = new Array<Wedge>();\r\n    for (const wedge of wedges) {\r\n        ret.push(...cutWedge(wedge, low, high));\r\n    }\r\n    return ret;\r\n}\r\n\r\nconst DEBUG_WARPWEDGE: boolean = false;\r\n\r\nexport function warpWedge(wedge: Wedge, low: number, high: number, warp: Warp, warpCount: number): Wedge[] {\r\n    if (DEBUG_WARPWEDGE) {\r\n        // istanbul ignore next\r\n        // tslint:disable-next-line:no-console\r\n        console.info(`warp ${wedgeToString(wedge)} ${rangeToString(low, high)} ${warp.map.id}`);\r\n    }\r\n    let ret: Wedge[];\r\n    if (low <= wedge.low) {\r\n        if (high >= wedge.high) {\r\n            // wedge is entirely warped\r\n            wedge.warp = warp;\r\n            wedge.warpCount = warpCount;\r\n            ret = [wedge];\r\n        } else if (high >= wedge.low) {\r\n            // low part of wedge is warped, split it into two\r\n            const nextWedge = {\r\n                low: high,\r\n                high: wedge.high,\r\n                warp: wedge.warp,\r\n                warpCount: wedge.warpCount,\r\n            };\r\n            wedge.high = high;\r\n            wedge.warp = warp;\r\n            wedge.warpCount = warpCount;\r\n            ret = [wedge, nextWedge];\r\n        } else {\r\n            // warp doesn't reach the wedge\r\n            ret = [wedge];\r\n        }\r\n    } else if (high >= wedge.high) {\r\n        if (low <= wedge.high) {\r\n            // high part of wedge is occluded, split it into two\r\n            const nextWedge = {\r\n                low,\r\n                high: wedge.high,\r\n                warp,\r\n                warpCount,\r\n            };\r\n            wedge.high = low;\r\n            ret = [wedge, nextWedge];\r\n        } else {\r\n            // warp doesn't reach the wedge\r\n            ret = [wedge];\r\n        }\r\n    } else {\r\n        // middle part of wedge is occluded, split it into three\r\n        const middleWedge = {\r\n            low,\r\n            high,\r\n            warp,\r\n            warpCount,\r\n        };\r\n        const highWedge = {\r\n            low: high,\r\n            high: wedge.high,\r\n            warp: wedge.warp,\r\n            warpCount: wedge.warpCount,\r\n        };\r\n        wedge.high = low;\r\n        ret = [wedge, middleWedge, highWedge];\r\n    }\r\n    if (DEBUG_WARPWEDGE) {\r\n        // istanbul ignore next\r\n        // tslint:disable-next-line:no-console\r\n        console.info(`--> ${wedgesToString(ret)}`);\r\n    }\r\n    return ret;\r\n}\r\n\r\nexport function warpWedges(wedges: Wedge[], low: number, high: number, warp: Warp, warpCount: number): Wedge[] {\r\n    const ret = new Array<Wedge>();\r\n    for (const wedge of wedges) {\r\n        ret.push(...warpWedge(wedge, low, high, warp, warpCount));\r\n    }\r\n    return ret;\r\n}\r\n\r\nexport function whichWedge(wedges: Wedge[], wedgeIndex: number, centerSlope: number) {\r\n    // determine the wedge containing centerSlope,\r\n    // or if there isn't one, then the one nearest to centerSlope\r\n    // or if two are very close, the one with the least warp count\r\n    // or if they both have the same warp count, the one with the lowest map id\r\n    let cur = wedgeIndex;\r\n    // skip to the next wedge while it starts before before centerSlope\r\n    while (cur < wedges.length - 1 && wedges[cur + 1].low < centerSlope - WALL_EPSILON * 2) {\r\n        cur ++;\r\n    }\r\n    if (cur >= wedges.length - 1 || wedges[cur].high > centerSlope + WALL_EPSILON * 2) {\r\n        // the current wedge contains centerSlope or is past it, so this is the closest\r\n        return cur;\r\n    } else if (wedges[cur].high < centerSlope - WALL_EPSILON * 2) {\r\n        // the current wedge isn't very close to centerSlope\r\n        // choose the closest one\r\n        if (Math.abs(wedges[cur].high - centerSlope) < Math.abs(wedges[cur + 1].low - centerSlope)) {\r\n            return cur;\r\n        } else {\r\n            return cur + 1;\r\n        }\r\n    } else {\r\n        // the current wedge is very close to centerSlope\r\n        if (wedges[cur + 1].low < centerSlope + WALL_EPSILON * 2) {\r\n            // the next wedge is very close to centerSlope too\r\n            // compare warp counts\r\n            if (wedges[cur].warpCount < wedges[cur + 1].warpCount) {\r\n                return cur;\r\n            } else if (wedges[cur].warpCount > wedges[cur + 1].warpCount) {\r\n                return cur + 1;\r\n            } else {\r\n                // same warp count\r\n                // compare map ids\r\n                if (wedges[cur].warp.map.id < wedges[cur + 1].warp.map.id) {\r\n                    return cur;\r\n                } else {\r\n                    return cur + 1;\r\n                }\r\n            }\r\n        } else {\r\n            // the next wedge isn't very close to centerSlope, use the current one\r\n            return cur;\r\n        }\r\n    }\r\n}\r\n","import * as geom from '.';\r\n\r\nexport class Mask implements geom.SizeLike {\r\n    private readonly _size = new geom.Size();\r\n    private readonly _bits: boolean[];\r\n    // TODO consider Uint8Array for bits\r\n\r\n    constructor(size: geom.SizeLike, initialValue = false) {\r\n        this._size.copyFrom(size);\r\n        this._bits = new Array<boolean>(this._size.area).fill(initialValue);\r\n    }\r\n\r\n    // accessors\r\n\r\n    toString() {\r\n        let ret = '';\r\n        const off = new geom.Offset();\r\n        for (let y = 0; y < this._size.height; y ++) {\r\n            for (let x = 0; x < this._size.width; x ++) {\r\n                off.set(x, y);\r\n                ret += this.get(off.set(x, y)) ? '☑' : '☐';\r\n            }\r\n            ret += '\\n';\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    get width() {\r\n        return this._size.width;\r\n    }\r\n\r\n    get height() {\r\n        return this._size.height;\r\n    }\r\n\r\n    index(off: geom.OffsetLike) {\r\n        return this._size.index(off);\r\n    }\r\n\r\n    getAt(index: number) {\r\n        return this._bits[index];\r\n    }\r\n\r\n    get(off: geom.OffsetLike) {\r\n        return this.getAt(this.index(off));\r\n    }\r\n\r\n    // mutators\r\n\r\n    setAt(index: number, value: boolean) {\r\n        this._bits[index] = value;\r\n        return this;\r\n    }\r\n\r\n    set(off: geom.OffsetLike, value: boolean) {\r\n        return this.setAt(this.index(off), value);\r\n    }\r\n}\r\n","import * as geom from '.';\r\n\r\nexport interface RectangleLike extends geom.SizeLike {\r\n    readonly westX: number;\r\n    readonly northY: number;\r\n}\r\n\r\nconst LOCAL_OFF = new geom.Offset();\r\n\r\nexport class Rectangle implements RectangleLike, geom.SizeLike {\r\n    northWest: geom.Offset;\r\n    size: geom.Size;\r\n\r\n    constructor();\r\n    constructor(westX: number, northY: number, width: number, height: number);\r\n    constructor(westX?: number, northY?: number, width?: number, height?: number) {\r\n        if (typeof westX === 'undefined') {\r\n            westX = 0;\r\n        }\r\n        if (typeof northY === 'undefined') {\r\n            northY = 0;\r\n        }\r\n        if (typeof width === 'undefined') {\r\n            width = 0;\r\n        }\r\n        if (typeof height === 'undefined') {\r\n            height = 0;\r\n        }\r\n        this.northWest = new geom.Offset(westX, northY);\r\n        this.size = new geom.Size(width, height);\r\n    }\r\n\r\n    // accessors\r\n\r\n    toString() {\r\n        return `(${this.westX},${this.northY} ${this.width}x${this.height})`;\r\n    }\r\n\r\n    equals(other: RectangleLike) {\r\n        return this.westX === other.westX && this.northY === other.northY && this.size.equals(other);\r\n    }\r\n\r\n    get northY() {\r\n        return this.northWest.y;\r\n    }\r\n\r\n    get southY() {\r\n        return this.northWest.y + this.size.height - 1;\r\n    }\r\n\r\n    get westX() {\r\n        return this.northWest.x;\r\n    }\r\n\r\n    get eastX() {\r\n        return this.northWest.x + this.size.width - 1;\r\n    }\r\n\r\n    get width() {\r\n        return this.size.width;\r\n    }\r\n\r\n    get height() {\r\n        return this.size.height;\r\n    }\r\n\r\n    get empty() {\r\n        return this.size.empty;\r\n    }\r\n\r\n    get area() {\r\n        return this.size.area;\r\n    }\r\n\r\n    // mutators\r\n\r\n    set(westX: number, northY: number, width: number, height: number) {\r\n        this.northWest.set(westX, northY);\r\n        this.size.set(width, height);\r\n        return this;\r\n    }\r\n\r\n    copyFrom(other: RectangleLike) {\r\n        this.northWest.set(other.westX, other.northY);\r\n        this.size.set(other.width, other.height);\r\n        return this;\r\n    }\r\n\r\n    extendToInclude(off: geom.OffsetLike) {\r\n        const dx = off.x - this.westX;\r\n        if (dx < 0) {\r\n            this.size.width -= dx;\r\n            this.northWest.x = off.x;\r\n        } else if (dx >= this.size.width) {\r\n            this.size.width = dx + 1;\r\n        }\r\n        const dy = off.y - this.northWest.y;\r\n        if (dy < 0) {\r\n            this.size.height -= dy;\r\n            this.northWest.y = off.y;\r\n        } else if (dy >= this.size.height) {\r\n            this.size.height = dy + 1;\r\n        }\r\n        return this;\r\n    }\r\n\r\n    // utilities\r\n\r\n    containsOffset(off: geom.OffsetLike) {\r\n        return this.size.containsOffset(LOCAL_OFF.copyFrom(off).subtractOffset(this.northWest));\r\n    }\r\n\r\n    containsRectangle(other: RectangleLike) {\r\n        LOCAL_OFF.set(other.westX, other.northY).subtractOffset(this.northWest);\r\n        if (!this.size.containsOffset(LOCAL_OFF)) {\r\n            return false;\r\n        }\r\n        if (other.width === 0 && other.height === 0) {\r\n            return false;\r\n        }\r\n        return this.size.containsOffset(LOCAL_OFF.add(other.width - 1, other.height - 1));\r\n    }\r\n\r\n    overlapsRectangle(other: RectangleLike) {\r\n        return this.northY <= other.northY + other.height - 1\r\n            && this.southY >= other.northY\r\n            && this.westX <= other.westX + other.width - 1\r\n            && this.eastX >= other.westX\r\n            && !this.empty\r\n            && other.width !== 0 && other.height !== 0;\r\n    }\r\n\r\n    index(off: geom.OffsetLike) {\r\n        return this.size.index(LOCAL_OFF.copyFrom(off).subtractOffset(this.northWest));\r\n    }\r\n}\r\n","import * as geom from '.';\r\n\r\nexport interface SizeLike {\r\n    readonly width: number;\r\n    readonly height: number;\r\n}\r\n\r\nexport class Size implements SizeLike {\r\n    width: number;\r\n    height: number;\r\n\r\n    constructor();\r\n    constructor(width: number, height: number);\r\n    constructor(width?: number, height?: number) {\r\n        if (typeof width === 'undefined') {\r\n            width = 0;\r\n        }\r\n        if (typeof height === 'undefined') {\r\n            height = 0;\r\n        }\r\n        this.width = width;\r\n        this.height = height;\r\n    }\r\n\r\n    // accessors\r\n\r\n    toString() {\r\n        return `(${this.width}x${this.height})`;\r\n    }\r\n\r\n    equals(other: SizeLike) {\r\n        return this.width === other.width && this.height === other.height;\r\n    }\r\n\r\n    get empty() {\r\n        return this.width === 0 || this.height === 0;\r\n    }\r\n\r\n    get area() {\r\n        return this.width * this.height;\r\n    }\r\n\r\n    // mutators\r\n\r\n    set(width: number, height: number) {\r\n        this.width = width;\r\n        this.height = height;\r\n        return this;\r\n    }\r\n\r\n    copyFrom(other: SizeLike) {\r\n        this.width = other.width;\r\n        this.height = other.height;\r\n        return this;\r\n    }\r\n\r\n    add(width: number, height: number) {\r\n        this.width += width;\r\n        this.height += height;\r\n        return this;\r\n    }\r\n\r\n    addOffset(off: geom.OffsetLike) {\r\n        this.width += off.x;\r\n        this.height += off.y;\r\n        return this;\r\n    }\r\n\r\n    multiply(factor: number) {\r\n        this.width *= factor;\r\n        this.height *= factor;\r\n        return this;\r\n    }\r\n\r\n    // TODO: rotate\r\n\r\n    // utilities\r\n\r\n    containsOffset(off: geom.OffsetLike) {\r\n        return off.x >= 0 && off.y >= 0 && off.x < this.width && off.y < this.height;\r\n    }\r\n\r\n    index(off: geom.OffsetLike) {\r\n        return off.y * this.width + off.x;\r\n    }\r\n}\r\n","import * as geom from '.';\r\n\r\nconst X_FROM_DIRECTION = [  0, 1, 0, -1 ];\r\nconst Y_FROM_DIRECTION = [ -1, 0, 1,  0 ];\r\n\r\nexport interface OffsetLike {\r\n    readonly x: number;\r\n    readonly y: number;\r\n}\r\n\r\nexport class Offset implements OffsetLike {\r\n    x: number;\r\n    y: number;\r\n\r\n    constructor();\r\n    constructor(x: number, y: number);\r\n    constructor(x?: number, y?: number) {\r\n        if (typeof x === 'undefined') {\r\n            x = 0;\r\n        }\r\n        if (typeof y === 'undefined') {\r\n            y = 0;\r\n        }\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n\r\n    // accessors\r\n\r\n    toString() {\r\n        return `(${this.x},${this.y})`;\r\n    }\r\n\r\n    equals(other: OffsetLike) {\r\n        return this.x === other.x && this.y === other.y;\r\n    }\r\n\r\n    // chebyshev: can move in any direction (diagonals are ok)\r\n    get magnitudeChebyshev() {\r\n        return Math.max(Math.abs(this.x), Math.abs(this.y));\r\n    }\r\n\r\n    // manhattan: can move only in cardinal directions (no diagonals)\r\n    get magnitudeManhattan(): number {\r\n        return Math.abs(this.x) + Math.abs(this.y);\r\n    }\r\n\r\n    // mutators\r\n\r\n    set(x: number, y: number) {\r\n        this.x = x;\r\n        this.y = y;\r\n        return this;\r\n    }\r\n\r\n    copyFrom(other: OffsetLike) {\r\n        this.x = other.x;\r\n        this.y = other.y;\r\n        return this;\r\n    }\r\n\r\n    setFromDirection(dir: geom.Direction) {\r\n        this.x = X_FROM_DIRECTION[dir];\r\n        this.y = Y_FROM_DIRECTION[dir];\r\n        return this;\r\n    }\r\n\r\n    add(x: number, y: number) {\r\n        this.x += x;\r\n        this.y += y;\r\n        return this;\r\n    }\r\n\r\n    addSize(size: geom.SizeLike) {\r\n        this.x += size.width;\r\n        this.y += size.height;\r\n        return this;\r\n    }\r\n\r\n    addOffset(off: OffsetLike) {\r\n        this.x += off.x;\r\n        this.y += off.y;\r\n        return this;\r\n    }\r\n\r\n    addDirection(dir: geom.Direction) {\r\n        this.x += X_FROM_DIRECTION[dir];\r\n        this.y += Y_FROM_DIRECTION[dir];\r\n        return this;\r\n    }\r\n\r\n    addCardinalDirection(dir: geom.Direction) {\r\n        this.x += X_FROM_DIRECTION[dir];\r\n        this.y += Y_FROM_DIRECTION[dir];\r\n        return this;\r\n    }\r\n\r\n    subtractOffset(off: OffsetLike) {\r\n        this.x -= off.x;\r\n        this.y -= off.y;\r\n        return this;\r\n    }\r\n\r\n    multiply(factor: number) {\r\n        this.x *= factor;\r\n        this.y *= factor;\r\n        return this;\r\n    }\r\n\r\n    // utilities\r\n\r\n    // chebyshev: can move in any direction (diagonals are ok)\r\n    distanceChebyshev(other: OffsetLike) {\r\n        return this.subtractOffset(other).magnitudeChebyshev;\r\n    }\r\n\r\n    // manhattan: can move only in cardinal directions (no diagonals)\r\n    distanceManhattan(other?: OffsetLike): number {\r\n        return this.subtractOffset(other).magnitudeManhattan;\r\n    }\r\n}\r\n","import * as geom from '.';\r\n\r\n// tslint:disable:no-bitwise\r\n\r\nexport enum DirectionFlags {\r\n    NONE  = 0,\r\n    NORTH = 1,\r\n    EAST  = 2,\r\n    SOUTH = 4,\r\n    WEST  = 8,\r\n    ALL   = 15,\r\n}\r\n\r\nexport function directionFlagsToString(flags: DirectionFlags) {\r\n    let ret = '[';\r\n    if ((flags & DirectionFlags.NORTH) !== 0) {\r\n        ret += 'N';\r\n    }\r\n    if ((flags & DirectionFlags.EAST) !== 0) {\r\n        ret += 'E';\r\n    }\r\n    if ((flags & DirectionFlags.SOUTH) !== 0) {\r\n        ret += 'S';\r\n    }\r\n    if ((flags & DirectionFlags.WEST) !== 0) {\r\n        ret += 'W';\r\n    }\r\n    return ret + ']';\r\n}\r\n\r\n// conversion\r\n\r\nexport function directionFlagsFromDirection(dir: geom.Direction) {\r\n    return (1 << dir) as DirectionFlags;\r\n}\r\n","// tslint:disable:no-bitwise\r\n\r\nexport enum Direction {\r\n    NORTH = 0,\r\n    EAST  = 1,\r\n    SOUTH = 2,\r\n    WEST  = 3,\r\n}\r\n\r\nexport const DIRECTIONS = [\r\n    Direction.NORTH,\r\n    Direction.EAST,\r\n    Direction.SOUTH,\r\n    Direction.WEST,\r\n];\r\n\r\nconst DIRECTIONS_STR = [\r\n    'N',\r\n    'E',\r\n    'S',\r\n    'W',\r\n];\r\n\r\nexport function directionToString(dir: Direction) {\r\n    return DIRECTIONS_STR[dir];\r\n}\r\n\r\nexport function directionOpposite(dir: Direction) {\r\n    return ((dir + 2) & 3) as Direction;\r\n}\r\n","import * as geom from './geom';\r\nimport {\r\n    TileFlag,\r\n    Warp,\r\n    Wedge,\r\n    WALL_EPSILON,\r\n    BODY_EPSILON,\r\n    WARP_EPSILON,\r\n    cutWedges,\r\n    warpWedges,\r\n    whichWedge,\r\n} from './fov-util';\r\nimport {WarpRect} from '.';\r\n\r\n// tslint:disable:no-bitwise\r\n\r\n/**\r\n * We avoid heap allocations during the core part of the algorithm by using this\r\n * preallocated offset object.\r\n */\r\nconst LOCAL_OFF = new geom.Offset();\r\n\r\n/**\r\n * The FieldOFViewMap represents the map over which the field of view will be\r\n * computed.  It starts out empty.  You can add walls and bodies to it, and then\r\n * use getFieldOfView() to compute the field of view from a given point.\r\n */\r\nexport class FieldOfViewMap {\r\n    readonly id: string;\r\n    private readonly _size = new geom.Size();\r\n    private readonly _tileFlags: number[];\r\n\r\n    private readonly _warps = new Array<Warp>();\r\n    private readonly _tileWarpIds: number[][];\r\n\r\n    constructor(id: string, width: number, height: number, addEdgeWalls = false) {\r\n        this.id = id;\r\n        this._size.set(width, height);\r\n        this._tileFlags = new Array<number>(this._size.area).fill(0);\r\n        if (addEdgeWalls) {\r\n            for (let y = 0; y < this._size.height; y ++) {\r\n                this._addFlag(LOCAL_OFF.set(0, y), TileFlag.WALL_WEST);\r\n                this._addFlag(LOCAL_OFF.set(this._size.width - 1, y), TileFlag.WALL_EAST);\r\n            }\r\n            for (let x = 0; x < this._size.width; x ++) {\r\n                this._addFlag(LOCAL_OFF.set(x, 0), TileFlag.WALL_NORTH);\r\n                this._addFlag(LOCAL_OFF.set(x, this._size.height - 1), TileFlag.WALL_SOUTH);\r\n            }\r\n        }\r\n        this._tileWarpIds = geom.DIRECTIONS.map(() => new Array<number>(this._size.area).fill(-1));\r\n    }\r\n\r\n    private _addFlag(off: geom.OffsetLike, flag: TileFlag) {\r\n        const index = this._size.index(off);\r\n        this._tileFlags[index] |= flag;\r\n    }\r\n\r\n    private _removeFlag(off: geom.OffsetLike, flag: TileFlag) {\r\n        const index = this._size.index(off);\r\n        this._tileFlags[index] &= ~flag;\r\n    }\r\n\r\n    private _getFlag(off: geom.OffsetLike, flag: TileFlag) {\r\n        const index = this._size.index(off);\r\n        return (this._tileFlags[index] & flag) !== 0;\r\n    }\r\n\r\n    private _findOrMakeWarp(map: FieldOfViewMap, offset: geom.OffsetLike) {\r\n        for (let fid = 0; fid < this._warps.length; fid ++) {\r\n            const fwarp = this._warps[fid];\r\n            if (fwarp.map === map && fwarp.offset.equals(offset)) {\r\n                return fid;\r\n            }\r\n        }\r\n        const warp = {\r\n            map,\r\n            offset: new geom.Offset().copyFrom(offset),\r\n        };\r\n        const id = this._warps.length;\r\n        this._warps.push(warp);\r\n        return id;\r\n    }\r\n\r\n    private _addWarp(off: geom.OffsetLike, dir: geom.Direction, warpId: number) {\r\n        const index = this._size.index(off);\r\n        this._tileWarpIds[dir][index] = warpId;\r\n    }\r\n\r\n    private _removeWarp(off: geom.OffsetLike, dir: geom.Direction) {\r\n        const index = this._size.index(off);\r\n        delete this._tileWarpIds[dir][index];\r\n    }\r\n\r\n    private _getWarp(off: geom.OffsetLike, dir: geom.Direction) {\r\n        const index = this._size.index(off);\r\n        const warpId = this._tileWarpIds[dir][index];\r\n        if (warpId === -1) {\r\n            return undefined;\r\n        } else {\r\n            return this._warps[warpId];\r\n        }\r\n    }\r\n\r\n    // setup and maintenance\r\n\r\n    /**\r\n     * Adds a wall at a particular edge.  This automatically adds the\r\n     * corresponding wall on the other side.\r\n     */\r\n    addWall(x: number, y: number, dir: geom.Direction, oneWay = false) {\r\n        LOCAL_OFF.set(x, y);\r\n        this._addFlag(LOCAL_OFF, 1 << dir);\r\n        LOCAL_OFF.addCardinalDirection(dir);\r\n        if (!oneWay && this._size.containsOffset(LOCAL_OFF)) {\r\n            this._addFlag(LOCAL_OFF, 1 << geom.directionOpposite(dir));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes a wall at a particular edge.  This automatically removes the\r\n     * corresponding wall on the other side.\r\n     */\r\n    removeWall(x: number, y: number, dir: geom.Direction, oneWay = false) {\r\n        LOCAL_OFF.set(x, y);\r\n        this._removeFlag(LOCAL_OFF, 1 << dir);\r\n        LOCAL_OFF.addCardinalDirection(dir);\r\n        if (!oneWay && this._size.containsOffset(LOCAL_OFF)) {\r\n            this._removeFlag(LOCAL_OFF, 1 << geom.directionOpposite(dir));\r\n        }\r\n    }\r\n\r\n    getWalls(x: number, y: number) {\r\n        LOCAL_OFF.set(x, y);\r\n        const index = this._size.index(LOCAL_OFF);\r\n        return this._tileFlags[index] & geom.DirectionFlags.ALL;\r\n    }\r\n\r\n    getWall(x: number, y: number, dir: geom.Direction) {\r\n        return (this.getWalls(x, y) & (1 << dir)) !== 0;\r\n    }\r\n\r\n    addBody(x: number, y: number) {\r\n        LOCAL_OFF.set(x, y);\r\n        this._addFlag(LOCAL_OFF, TileFlag.BODY);\r\n    }\r\n\r\n    removeBody(x: number, y: number) {\r\n        LOCAL_OFF.set(x, y);\r\n        this._removeFlag(LOCAL_OFF, TileFlag.BODY);\r\n    }\r\n\r\n    getBody(x: number, y: number) {\r\n        LOCAL_OFF.set(x, y);\r\n        const index = this._size.index(LOCAL_OFF);\r\n        return (this._tileFlags[index] & TileFlag.BODY) !== 0;\r\n    }\r\n\r\n    // TODO add length argument\r\n    addWarp(sourceX: number, sourceY: number, dir: geom.Direction,\r\n            targetMap: FieldOfViewMap, targetX: number, targetY: number) {\r\n        LOCAL_OFF.set(targetX - sourceX, targetY - sourceY)\r\n                .addCardinalDirection(geom.directionOpposite(dir));\r\n        const warpId = this._findOrMakeWarp(targetMap, LOCAL_OFF);\r\n        LOCAL_OFF.set(sourceX, sourceY);\r\n        this._addWarp(LOCAL_OFF, dir, warpId);\r\n    }\r\n\r\n    // TODO add length argument\r\n    removeWarp(sourceX: number, sourceY: number, dir: geom.Direction) {\r\n        LOCAL_OFF.set(sourceX, sourceY);\r\n        this._removeWarp(LOCAL_OFF, dir);\r\n    }\r\n\r\n    getWarpFlags(sourceX: number, sourceY: number) {\r\n        LOCAL_OFF.set(sourceX, sourceY);\r\n        let ret = 0;\r\n        geom.DIRECTIONS.forEach((dir) => {\r\n            if (this._getWarp(LOCAL_OFF, dir)) {\r\n                ret |= 1 << dir;\r\n            }\r\n        });\r\n        return ret;\r\n    }\r\n\r\n    getWarpFlag(sourceX: number, sourceY: number, dir: geom.Direction) {\r\n        LOCAL_OFF.set(sourceX, sourceY);\r\n        return this._getWarp(LOCAL_OFF, dir) != null;\r\n    }\r\n\r\n    // execution\r\n\r\n    /**\r\n     * Compute the field of view for a camera at the given tile.\r\n     * chebyshevRadius is the vision radius.  It uses chebyshev distance\r\n     * (https://en.wikipedia.org/wiki/Chebyshev_distance), which just means\r\n     * that the limit of vision in a large empty field will be square.\r\n     *\r\n     * This returns a WarpRect, which indicates which tiles are visible\r\n     * and which map is seen in each tile.  warpRect.getMask(x, y) will return\r\n     * true for visible tiles, warpRect.getMap(x, y) will return\r\n     * the map for that tile, and warpRect.getOffset(x, y) will return the\r\n     * location in that map which is visible there.\r\n     */\r\n    getFieldOfView(x: number, y: number, chebyshevRadius: number) {\r\n        const origin = new geom.Offset(x, y);\r\n        const boundRect = new geom.Rectangle().set(\r\n            origin.x - chebyshevRadius, origin.y - chebyshevRadius,\r\n            chebyshevRadius * 2 + 1, chebyshevRadius * 2 + 1,\r\n        );\r\n        const mask = new WarpRect(boundRect);\r\n        // the player can always see itself\r\n        mask.set(origin, true, undefined);\r\n        // the field is divided into quadrants\r\n        this._quadrant(mask, origin, chebyshevRadius, -1, -1);\r\n        this._quadrant(mask, origin, chebyshevRadius,  1, -1);\r\n        this._quadrant(mask, origin, chebyshevRadius, -1,  1);\r\n        this._quadrant(mask, origin, chebyshevRadius,  1,  1);\r\n        return mask;\r\n    }\r\n\r\n    private _quadrant(mask: WarpRect, origin: geom.OffsetLike, chebyshevRadius: number,\r\n                      xDir: number, yDir: number) {\r\n        const {x: startX, y: startY} = origin;\r\n        const endDXY = (chebyshevRadius + 1);\r\n        if (endDXY < 0 || !this._size.containsOffset(origin)) {\r\n            return;\r\n        }\r\n        const farYFlag = [TileFlag.WALL_NORTH, TileFlag.WALL_SOUTH][(yDir + 1) / 2];\r\n        const farXFlag = [TileFlag.WALL_WEST, TileFlag.WALL_EAST][(xDir + 1) / 2];\r\n        const yWarpDir = [geom.Direction.NORTH, geom.Direction.SOUTH][(yDir + 1) / 2];\r\n        const yWarps = this._tileWarpIds[yWarpDir];\r\n        const xWarpDir = [geom.Direction.WEST, geom.Direction.EAST][(xDir + 1) / 2];\r\n        const xWarps = this._tileWarpIds[xWarpDir];\r\n        const startMapIndex = this._size.index(origin);\r\n        const startMaskIndex = mask.index(origin.x, origin.y);\r\n        // Initial wedge is from slope zero to slope infinity (i.e. the whole quadrant)\r\n        const wedges = [{\r\n            low: 0,\r\n            high: Number.POSITIVE_INFINITY,\r\n            warp: undefined,\r\n            warpCount: 0,\r\n        } as Wedge];\r\n        // X += Y must be written as X = X + Y, in order not to trigger deoptimization due to\r\n        // http://stackoverflow.com/questions/34595356/what-does-compound-let-const-assignment-mean\r\n        for (let dy = 0, yMapIndex = startMapIndex, yMaskIndex = startMaskIndex;\r\n             dy !== endDXY && wedges.length > 0;\r\n             dy ++, yMapIndex = yMapIndex + yDir * this._size.width, yMaskIndex = yMaskIndex + yDir * mask.width\r\n        ) {\r\n            const divYpos = 1 / (dy + 0.5);\r\n            const divYneg = dy === 0 ? Number.POSITIVE_INFINITY : 1 / (dy - 0.5);\r\n            const divYmid = 1 / dy;\r\n            let wedgeIndex = 0;\r\n            // X += Y must be written as X = X + Y, in order not to trigger deoptimization due to\r\n            // http://stackoverflow.com/questions/34595356/what-does-compound-let-const-assignment-mean\r\n            for (let dx = 0, mapIndex = yMapIndex, maskIndex = yMaskIndex,\r\n                 slopeY = -0.5 * divYpos, slopeX = 0.5 * divYneg,\r\n                 slopeFar = 0.5 * divYpos, slopeMid = 0;\r\n                 dx !== endDXY && wedgeIndex !== wedges.length;\r\n                 dx ++, mapIndex = mapIndex + xDir, maskIndex = maskIndex + xDir,\r\n                 slopeY = slopeY + divYpos, slopeX = slopeX + divYneg,\r\n                 slopeFar = slopeFar + divYpos, slopeMid = slopeMid + divYmid\r\n            ) {\r\n                // the slopes of the four corners of this tile\r\n                // these are named as follows:\r\n                //   slopeY is the slope closest to the Y axis\r\n                //   slopeFar is the slope to the farthest corner\r\n                //   slopeMid is the slope to the center\r\n                //   slopeX is the slope closest to the X axis\r\n                // these are always true:\r\n                //   slopeY < slopeFar < slopeX\r\n                //   slopeY < slopeMid < slopeX\r\n                //\r\n                // O = origin, C = current\r\n                // +---+---+---+\r\n                // | O |   |   |\r\n                // +---+---+---X\r\n                // |   |   | C |\r\n                // +---+---Y---F\r\n\r\n                // the walls of this tile\r\n                // these are named as follows:\r\n                //   wallY is the farthest horizontal wall (slopeY to slopeFar)\r\n                //   wallX is the farthest vertical wall (slopeFar to slopeX)\r\n                //\r\n                // O = origin, C = current\r\n                // +---+---+---+\r\n                // | O |   |   |\r\n                // +---+---+---+\r\n                // |   |   | C X\r\n                // +---+---+-Y-+\r\n\r\n                // advance the wedge index until this tile is not after the current wedge\r\n                while (slopeY >= wedges[wedgeIndex].high) {\r\n                    wedgeIndex ++;\r\n                    if (wedgeIndex >= wedges.length) {\r\n                        break;\r\n                    }\r\n                }\r\n                if (wedgeIndex >= wedges.length) {\r\n                    break;\r\n                }\r\n\r\n                // if the current wedge is after this tile, move on\r\n                if (slopeX <= wedges[wedgeIndex].low) {\r\n                    continue;\r\n                }\r\n\r\n                {\r\n                    const centerWedge = whichWedge(wedges, wedgeIndex, slopeMid);\r\n                    mask.setAt(maskIndex, true, wedges[centerWedge].warp);\r\n                }\r\n\r\n                {\r\n                    let wedgeIndexInner = wedgeIndex;\r\n                    while (wedgeIndexInner < wedges.length && slopeX > wedges[wedgeIndexInner].low) {\r\n                        let newWedges = [wedges[wedgeIndexInner]];\r\n                        const {warp} = wedges[wedgeIndexInner];\r\n                        let wallY: boolean;\r\n                        let wallX: boolean;\r\n                        let body: boolean;\r\n                        let warpY: Warp;\r\n                        let warpX: Warp;\r\n                        const nextWarpCount = wedges[wedgeIndexInner].warpCount + 1;\r\n\r\n                        if (typeof warp === 'undefined') {\r\n                            wallY = (this._tileFlags[mapIndex] & farYFlag) !== 0;\r\n                            wallX = (this._tileFlags[mapIndex] & farXFlag) !== 0;\r\n                            body = (dx !== 0 || dy !== 0) && (this._tileFlags[mapIndex] & TileFlag.BODY) !== 0;\r\n                            warpY = this._warps[yWarps[mapIndex]];\r\n                            warpX = this._warps[xWarps[mapIndex]];\r\n                        } else {\r\n                            const {map, offset} = warp;\r\n                            LOCAL_OFF.copyFrom(offset).add(startX + dx * xDir, startY + dy * yDir);\r\n                            wallY = map._getFlag(LOCAL_OFF, farYFlag);\r\n                            wallX = map._getFlag(LOCAL_OFF, farXFlag);\r\n                            body = (dx !== 0 || dy !== 0) && map._getFlag(LOCAL_OFF, TileFlag.BODY);\r\n                            warpY = map._getWarp(LOCAL_OFF, yWarpDir);\r\n                            warpX = map._getWarp(LOCAL_OFF, xWarpDir);\r\n                        }\r\n\r\n                        if (wallX && wallY) {\r\n                            // this tile has both far walls\r\n                            // so we can't see beyond it and the whole range should be cut out of the wedge(s)\r\n                            newWedges = cutWedges(newWedges, slopeY - WALL_EPSILON, slopeX + WALL_EPSILON);\r\n                        } else if (wallX) {\r\n                            if (typeof warpY !== 'undefined') {\r\n                                newWedges = warpWedges(newWedges,\r\n                                    slopeY - WARP_EPSILON, slopeFar + WARP_EPSILON, warpY, nextWarpCount);\r\n                            }\r\n                            if (body) {\r\n                                newWedges = cutWedges(newWedges,\r\n                                    slopeY + BODY_EPSILON, slopeX + WALL_EPSILON);\r\n                            } else {\r\n                                newWedges = cutWedges(newWedges,\r\n                                    slopeFar - WALL_EPSILON, slopeX + WALL_EPSILON);\r\n                            }\r\n                        } else if (wallY) {\r\n                            if (body) {\r\n                                newWedges = cutWedges(newWedges,\r\n                                    slopeY - WALL_EPSILON, slopeX - BODY_EPSILON);\r\n                            } else {\r\n                                newWedges = cutWedges(newWedges,\r\n                                    slopeY - WALL_EPSILON, slopeFar + WALL_EPSILON);\r\n                            }\r\n                            if (typeof warpX !== 'undefined') {\r\n                                newWedges = warpWedges(newWedges,\r\n                                    slopeFar - WARP_EPSILON, slopeX + WARP_EPSILON, warpX, nextWarpCount);\r\n                            }\r\n                        } else {\r\n                            if (typeof warpY !== 'undefined') {\r\n                                newWedges = warpWedges(newWedges,\r\n                                    slopeY - WARP_EPSILON, slopeFar + WARP_EPSILON, warpY, nextWarpCount);\r\n                            }\r\n                            if (body) {\r\n                                newWedges = cutWedges(newWedges,\r\n                                    slopeY + BODY_EPSILON, slopeX - BODY_EPSILON);\r\n                            }\r\n                            if (typeof warpX !== 'undefined') {\r\n                                newWedges = warpWedges(newWedges,\r\n                                    slopeFar - WARP_EPSILON, slopeX + WARP_EPSILON, warpX, nextWarpCount);\r\n                            }\r\n                        }\r\n\r\n                        if (newWedges.length !== 1) {\r\n                            wedges.splice(wedgeIndexInner, 1, ...newWedges);\r\n                        }\r\n                        // X += Y must be written as X = X + Y, in order not to trigger deoptimization due to\r\n                        // http://stackoverflow.com/questions/34595356/what-does-compound-let-const-assignment-mean\r\n                        wedgeIndexInner = wedgeIndexInner + newWedges.length;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n"],"sourceRoot":""}